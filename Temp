package com.cnb.search.model;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Represents the complete search configuration loaded from search-config.json.
 * This includes search fields, repository mappings, result columns, and search settings.
 */
public class SearchConfiguration {
    
    private List<SearchField> searchFields;
    private List<RepositoryConfig> repositories;
    private List<ResultColumn> resultColumns;
    private SearchSettings searchSettings;
    
    private static SearchConfiguration instance;
    private static final String CONFIG_FILE = "/com/cnb/search/model/search_config.json";
    
    private SearchConfiguration() {
        this.searchFields = new ArrayList<SearchField>();
        this.repositories = new ArrayList<RepositoryConfig>();
        this.resultColumns = new ArrayList<ResultColumn>();
        this.searchSettings = new SearchSettings();
    }
    
    /**
     * Gets the singleton instance of SearchConfiguration.
     * Loads configuration from JSON file on first access.
     */
    public static synchronized SearchConfiguration getInstance() {
        if (instance == null) {
            instance = new SearchConfiguration();
            instance.loadConfiguration();
        }
        return instance;
    }
    
    /**
     * Reloads configuration from the JSON file.
     */
    public static synchronized void reload() {
        instance = null;
        getInstance();
    }
    
    /**
     * Loads configuration from the embedded JSON file.
     */
    private void loadConfiguration() {
        try {
        	InputStream is = getClass().getResourceAsStream(CONFIG_FILE);
            if (is == null) {
                throw new RuntimeException("Configuration file not found: " + CONFIG_FILE);
            }
            
            InputStreamReader reader = new InputStreamReader(is, "UTF-8");
            JSONObject config = JSONObject.parse(reader);
            
            // Parse search fields
            JSONArray fieldsArray = (JSONArray) config.get("searchFields");
            if (fieldsArray != null) {
                for (Object fieldObj : fieldsArray) {
                    JSONObject field = (JSONObject) fieldObj;
                    SearchField searchField = new SearchField();
                    searchField.setFieldId((String) field.get("fieldId"));
                    searchField.setFieldLabel((String) field.get("fieldLabel"));
                    searchField.setFieldType((String) field.get("fieldType"));
                    searchField.setOperator((String) field.get("operator"));
                    searchField.setPlaceholder((String) field.get("placeholder"));
                    searchField.setRequired(Boolean.TRUE.equals(field.get("required")));
                    searchFields.add(searchField);
                }
            }
            
            // Parse repositories
            JSONArray reposArray = (JSONArray) config.get("repositories");
            if (reposArray != null) {
                for (Object repoObj : reposArray) {
                    JSONObject repo = (JSONObject) repoObj;
                    RepositoryConfig repoConfig = new RepositoryConfig();
                    repoConfig.setRepoId((String) repo.get("repoId"));
                    repoConfig.setRepoName((String) repo.get("repoName"));
                    repoConfig.setEnabled(Boolean.TRUE.equals(repo.get("enabled")));
                    
                    // Check for new multi-class format (classes array)
                    JSONArray classesArray = (JSONArray) repo.get("classes");
                    if (classesArray != null && !classesArray.isEmpty()) {
                        // New format: multiple classes per repository
                        for (Object classObj : classesArray) {
                            JSONObject classJson = (JSONObject) classObj;
                            ClassMapping classMapping = new ClassMapping();
                            classMapping.setClassName((String) classJson.get("className"));
                            
                            // Parse field mappings for this class
                            JSONObject mappings = (JSONObject) classJson.get("fieldMappings");
                            if (mappings != null) {
                                Map<String, String> fieldMappings = new HashMap<String, String>();
                                for (Object key : mappings.keySet()) {
                                    fieldMappings.put((String) key, (String) mappings.get(key));
                                }
                                classMapping.setFieldMappings(fieldMappings);
                            }
                            
                            repoConfig.addClassMapping(classMapping);
                        }
                    } else {
                        // Legacy format: single className and fieldMappings
                        repoConfig.setClassName((String) repo.get("className"));
                        
                        // Parse field mappings
                        JSONObject mappings = (JSONObject) repo.get("fieldMappings");
                        if (mappings != null) {
                            Map<String, String> fieldMappings = new HashMap<String, String>();
                            for (Object key : mappings.keySet()) {
                                fieldMappings.put((String) key, (String) mappings.get(key));
                            }
                            repoConfig.setFieldMappings(fieldMappings);
                        }
                    }
                    
                    repositories.add(repoConfig);
                }
            }
            
            // Parse result columns
            JSONArray columnsArray = (JSONArray) config.get("resultColumns");
            if (columnsArray != null) {
                for (Object colObj : columnsArray) {
                    JSONObject col = (JSONObject) colObj;
                    ResultColumn column = new ResultColumn();
                    column.setColumnId((String) col.get("columnId"));
                    column.setColumnLabel((String) col.get("columnLabel"));
                    column.setPropertyName((String) col.get("propertyName"));
                    column.setWidth((String) col.get("width"));
                    column.setSortable(Boolean.TRUE.equals(col.get("sortable")));
                    resultColumns.add(column);
                }
            }
            
            // Parse search settings
            JSONObject settings = (JSONObject) config.get("searchSettings");
            if (settings != null) {
                if (settings.get("maxResultsPerRepo") != null) {
                    searchSettings.setMaxResultsPerRepo(((Number) settings.get("maxResultsPerRepo")).intValue());
                }
                if (settings.get("pageSize") != null) {
                    searchSettings.setPageSize(((Number) settings.get("pageSize")).intValue());
                }
                searchSettings.setEnableParallelSearch(Boolean.TRUE.equals(settings.get("enableParallelSearch")));
                if (settings.get("searchTimeout") != null) {
                    searchSettings.setSearchTimeout(((Number) settings.get("searchTimeout")).intValue());
                }
                searchSettings.setShowPartialResults(Boolean.TRUE.equals(settings.get("showPartialResults")));
            }
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to load search configuration", e);
        }
    }
    
    /**
     * Gets only enabled repositories.
     */
    public List<RepositoryConfig> getEnabledRepositories() {
        List<RepositoryConfig> enabled = new ArrayList<RepositoryConfig>();
        for (RepositoryConfig repo : repositories) {
            if (repo.isEnabled()) {
                enabled.add(repo);
            }
        }
        return enabled;
    }
    
    /**
     * Gets a repository by its ID.
     */
    public RepositoryConfig getRepositoryById(String repoId) {
        for (RepositoryConfig repo : repositories) {
            if (repo.getRepoId().equals(repoId)) {
                return repo;
            }
        }
        return null;
    }
    
    /**
     * Gets a search field by its ID.
     */
    public SearchField getSearchFieldById(String fieldId) {
        for (SearchField field : searchFields) {
            if (field.getFieldId().equals(fieldId)) {
                return field;
            }
        }
        return null;
    }
    
    /**
     * Converts configuration to JSON for frontend.
     */
    public JSONObject toJSON() {
        JSONObject json = new JSONObject();
        
        // Search fields
        JSONArray fieldsArray = new JSONArray();
        for (SearchField field : searchFields) {
            fieldsArray.add(field.toJSON());
        }
        json.put("searchFields", fieldsArray);
        
        // Repositories (only enabled)
        JSONArray reposArray = new JSONArray();
        for (RepositoryConfig repo : getEnabledRepositories()) {
            reposArray.add(repo.toJSON());
        }
        json.put("repositories", reposArray);
        
        // Result columns
        JSONArray columnsArray = new JSONArray();
        for (ResultColumn col : resultColumns) {
            columnsArray.add(col.toJSON());
        }
        json.put("resultColumns", columnsArray);
        
        // Search settings
        json.put("searchSettings", searchSettings.toJSON());
        
        return json;
    }
    
    // Getters and Setters
    public List<SearchField> getSearchFields() {
        return searchFields;
    }
    
    public List<RepositoryConfig> getRepositories() {
        return repositories;
    }
    
    public List<ResultColumn> getResultColumns() {
        return resultColumns;
    }
    
    public SearchSettings getSearchSettings() {
        return searchSettings;
    }
}

package com.cnb.search.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import javax.security.auth.Subject;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.cnb.search.model.ClassMapping;
import com.cnb.search.model.RepositoryConfig;
import com.cnb.search.model.ResultColumn;
import com.cnb.search.model.SearchConfiguration;
import com.cnb.search.model.SearchField;
import com.cnb.search.model.SearchSettings;
import com.filenet.api.collection.IndependentObjectSet;
import com.filenet.api.collection.PageIterator;
import com.filenet.api.core.Document;
import com.filenet.api.core.ObjectStore;
import com.filenet.api.property.Properties;
import com.filenet.api.property.Property;
import com.filenet.api.property.FilterElement;
import com.filenet.api.property.PropertyFilter;
import com.filenet.api.query.SearchSQL;
import com.filenet.api.query.SearchScope;
import com.filenet.api.util.UserContext;
import com.ibm.ecm.extension.PluginResponseUtil;
import com.ibm.ecm.extension.PluginService;
import com.ibm.ecm.extension.PluginServiceCallbacks;
import com.ibm.ecm.json.JSONResponse;
import com.ibm.ecm.json.JSONResultSetColumn;
import com.ibm.ecm.json.JSONResultSetResponse;
import com.ibm.ecm.json.JSONResultSetRow;
import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Service that handles multi-repository search requests.
 * Executes searches across multiple P8 object stores in parallel
 * and returns aggregated results.
 */
public class MultiRepoSearchService extends PluginService {

    public static final String SERVICE_ID = "multiRepoSearchService";
    
    // Request parameters
    public static final String PARAM_ACTION = "action_Type";
    public static final String PARAM_SEARCH_CRITERIA = "searchCriteria";
    public static final String PARAM_PAGE_NUMBER = "pageNumber";
    public static final String PARAM_PAGE_SIZE = "pageSize";
    
    // Actions
    public static final String ACTION_GET_CONFIG = "getConfiguration";
    public static final String ACTION_SEARCH = "search";
    public static final String ACTION_LIST_REPOSITORIES = "listRepositories";
    
    @Override
    public String getId() {
        return SERVICE_ID;
    }

    @Override
    public void execute(PluginServiceCallbacks callbacks, HttpServletRequest request, 
                        HttpServletResponse response) throws Exception {
        String methodName = "execute";
        callbacks.getLogger().logEntry(this, methodName, request);
        
        try {
            String action = request.getParameter(PARAM_ACTION);
            System.out.println("[MultiRepoSearchService.execute] Action received: " + action);
            
            if (ACTION_GET_CONFIG.equals(action)) {
                System.out.println("[MultiRepoSearchService.execute] Getting configuration...");
                // Return configuration for UI
                JSONResponse jsonResponse = getConfiguration();
                PluginResponseUtil.writeJSONResponse(request, response, jsonResponse, callbacks, SERVICE_ID);
            } else if (ACTION_LIST_REPOSITORIES.equals(action)) {
                System.out.println("[MultiRepoSearchService.execute] ACTION_LIST_REPOSITORIES - Listing available repositories...");
                // List available repositories
                JSONResponse jsonResponse = listAvailableRepositories(callbacks, request);
                PluginResponseUtil.writeJSONResponse(request, response, jsonResponse, callbacks, SERVICE_ID);
            } else if (ACTION_SEARCH.equals(action)) {
                System.out.println("[MultiRepoSearchService.execute] ACTION_SEARCH - Starting search...");
                // Execute search - returns JSONResultSetResponse
                String searchCriteriaJson = request.getParameter(PARAM_SEARCH_CRITERIA);
                int pageNumber = getIntParameter(request, PARAM_PAGE_NUMBER, 1);
                int pageSize = getIntParameter(request, PARAM_PAGE_SIZE, 50);
                
                System.out.println("[MultiRepoSearchService.execute] Search parameters - Criteria: " + searchCriteriaJson + 
                                  ", Page: " + pageNumber + ", PageSize: " + pageSize);
                
                JSONResultSetResponse jsonResultSet = executeSearch(callbacks, request, searchCriteriaJson, pageNumber, pageSize);
                
                System.out.println("[MultiRepoSearchService.execute] Search completed. Results count: " + jsonResultSet.getRowCount());
                
                // Write JSONResultSetResponse (like sample plugin)
                PluginResponseUtil.writeJSONResponse(request, response, jsonResultSet, callbacks, SERVICE_ID);
            } else {
                System.out.println("[MultiRepoSearchService.execute] Unknown action: " + action);
                JSONResponse jsonResponse = new JSONResponse();
                jsonResponse.put("error", "Unknown action: " + action);
                PluginResponseUtil.writeJSONResponse(request, response, jsonResponse, callbacks, SERVICE_ID);
            }
            
        } catch (Exception e) {
            callbacks.getLogger().logError(this, methodName, request, e);
            JSONResponse jsonResponse = new JSONResponse();
            jsonResponse.put("error", e.getMessage());
            jsonResponse.put("success", false);
            PluginResponseUtil.writeJSONResponse(request, response, jsonResponse, callbacks, SERVICE_ID);
        } finally {
            callbacks.getLogger().logExit(this, methodName, request);
        }
    }
    
    /**
     * Returns the search configuration for the UI.
     */
    private JSONResponse getConfiguration() {
        SearchConfiguration config = SearchConfiguration.getInstance();
        JSONResponse response = new JSONResponse();
        response.put("success", true);
        response.put("configuration", config.toJSON());
        return response;
    }
    
    /**
     * Lists available repositories by attempting to get connections.
     * This helps identify the correct repository IDs to use in search-config.json.
     */
    private JSONResponse listAvailableRepositories(PluginServiceCallbacks callbacks, HttpServletRequest request) {
        System.out.println("[listAvailableRepositories] START - Attempting to discover available repositories");
        JSONResponse response = new JSONResponse();
        JSONArray repositories = new JSONArray();
        
        // Get repositories from configuration
        SearchConfiguration config = SearchConfiguration.getInstance();
        List<RepositoryConfig> configRepos = config.getRepositories();
        
        System.out.println("[listAvailableRepositories] Testing " + configRepos.size() + " repositories from config...");
        
        for (RepositoryConfig configRepo : configRepos) {
            JSONObject repoInfo = new JSONObject();
            repoInfo.put("configRepoId", configRepo.getRepoId());
            repoInfo.put("configRepoName", configRepo.getRepoName());
            repoInfo.put("configClassName", configRepo.getClassName());
            
            System.out.println("[listAvailableRepositories] Testing repository ID: '" + configRepo.getRepoId() + "'");
            
            try {
                Subject subject = callbacks.getP8Subject(configRepo.getRepoId());
                ObjectStore objectStore = callbacks.getP8ObjectStore(configRepo.getRepoId());
                
                    if (subject != null && objectStore != null) {
                        repoInfo.put("available", true);
                        try {
                            repoInfo.put("objectStoreName", objectStore.get_Name());
                        } catch (Exception e) {
                            repoInfo.put("objectStoreName", "N/A");
                        }
                        repoInfo.put("objectStoreId", objectStore.get_Id().toString());
                        String osName = "N/A";
                        try {
                            osName = objectStore.get_Name();
                        } catch (Exception e) {
                            // Ignore
                        }
                        System.out.println("[listAvailableRepositories] âœ“ FOUND: " + configRepo.getRepoId() + 
                                      " -> ObjectStore: " + osName);
                    } else {
                    repoInfo.put("available", false);
                    repoInfo.put("error", "Subject or ObjectStore is NULL");
                    System.out.println("[listAvailableRepositories] âœ— NOT FOUND: " + configRepo.getRepoId());
                }
            } catch (Exception e) {
                repoInfo.put("available", false);
                repoInfo.put("error", e.getMessage());
                System.out.println("[listAvailableRepositories] âœ— ERROR for " + configRepo.getRepoId() + ": " + e.getMessage());
            }
            
            repositories.add(repoInfo);
        }
        
        // Also try to get repository info from request/desktop if available
        try {
            String desktopId = request.getParameter("desktopId");
            if (desktopId == null) {
                desktopId = (String) request.getAttribute("desktopId");
            }
            System.out.println("[listAvailableRepositories] Desktop ID: " + desktopId);
            
            // Try common repository ID patterns
            String[] commonPatterns = {
                "BankingOS", "BankingRepository", "Banking", "banking",
                "EducationOS", "EducationRepository", "Education", "education",
                "GovRecordsOS", "GovRecordsRepository", "GovRecords", "govrecords",
                "P8Repository", "FileNetRepository", "ContentEngine"
            };
            
            System.out.println("[listAvailableRepositories] Testing common repository ID patterns...");
            JSONArray discoveredRepos = new JSONArray();
            
            for (String pattern : commonPatterns) {
                try {
                    Subject subject = callbacks.getP8Subject(pattern);
                    ObjectStore objectStore = callbacks.getP8ObjectStore(pattern);
                    
                    if (subject != null && objectStore != null) {
                        JSONObject discovered = new JSONObject();
                        discovered.put("repoId", pattern);
                        try {
                            discovered.put("objectStoreName", objectStore.get_Name());
                        } catch (Exception e) {
                            discovered.put("objectStoreName", "N/A");
                        }
                        discovered.put("objectStoreId", objectStore.get_Id().toString());
                        discoveredRepos.add(discovered);
                        String osName = "N/A";
                        try {
                            osName = objectStore.get_Name();
                        } catch (Exception e) {
                            // Ignore
                        }
                        System.out.println("[listAvailableRepositories] âœ“ DISCOVERED: " + pattern + 
                                          " -> ObjectStore: " + osName);
                    }
                } catch (Exception e) {
                    // Ignore - this pattern doesn't exist
                }
            }
            
            if (discoveredRepos.size() > 0) {
                response.put("discoveredRepositories", discoveredRepos);
                System.out.println("[listAvailableRepositories] Discovered " + discoveredRepos.size() + " additional repositories");
            }
        } catch (Exception e) {
            System.out.println("[listAvailableRepositories] Error in discovery: " + e.getMessage());
        }
        
        response.put("success", true);
        response.put("repositories", repositories);
        response.put("message", "Check 'repositories' array for availability. Use 'available: true' repository IDs in search-config.json");
        
        System.out.println("[listAvailableRepositories] END - Found " + repositories.size() + " repositories");
        return response;
    }
    
    /**
     * Executes search across all enabled repositories.
     */
    private JSONResultSetResponse executeSearch(PluginServiceCallbacks callbacks, HttpServletRequest request,
                                     String searchCriteriaJson, int pageNumber, int pageSize) throws Exception {
        System.out.println("=========================================");
        System.out.println("[MultiRepoSearchService] executeSearch - START");
        System.out.println("=========================================");
        System.out.println("[executeSearch] searchCriteriaJson: " + searchCriteriaJson);
        System.out.println("[executeSearch] pageNumber: " + pageNumber);
        System.out.println("[executeSearch] pageSize: " + pageSize);
        
        String methodName = "executeSearch";
        callbacks.getLogger().logDebug(this, methodName, request, "Search criteria: " + searchCriteriaJson);
        
        System.out.println("[executeSearch] Loading SearchConfiguration...");
        SearchConfiguration config = SearchConfiguration.getInstance();
        SearchSettings settings = config.getSearchSettings();
        List<RepositoryConfig> repos = config.getEnabledRepositories();
        System.out.println("[executeSearch] Loaded configuration - Enabled repositories count: " + repos.size());
        System.out.println("[executeSearch] Search settings - Parallel: " + settings.isEnableParallelSearch() + 
                          ", MaxResultsPerRepo: " + settings.getMaxResultsPerRepo());
        
        // Parse search criteria
        System.out.println("[executeSearch] Parsing search criteria JSON...");
        JSONObject criteria = JSONObject.parse(searchCriteriaJson);
        Map<String, Object> searchCriteria = new HashMap<String, Object>();
        for (Object key : criteria.keySet()) {
            Object value = criteria.get(key);
            if (value != null && !value.toString().isEmpty()) {
                searchCriteria.put((String) key, value);
                System.out.println("[executeSearch] Search criteria field: " + key + " = " + value);
            } else {
                System.out.println("[executeSearch] Skipping empty field: " + key);
            }
        }
        System.out.println("[executeSearch] Total search criteria fields: " + searchCriteria.size());
        
        // Create JSONResultSetResponse (like sample plugin)
        JSONResultSetResponse jsonResultSet = new JSONResultSetResponse();
        jsonResultSet.setPageSize(pageSize);
        
        // Build result structure with columns
        buildResultStructure(jsonResultSet, config, callbacks, request.getLocale());
        
        List<JSONResultSetRow> allRows = new ArrayList<JSONResultSetRow>();
        JSONArray errors = new JSONArray();
        int totalCount = 0;
        
        if (settings.isEnableParallelSearch() && repos.size() > 1) {
            System.out.println("[executeSearch] Using PARALLEL execution mode");
            // Parallel execution - Get subjects and object stores in main thread first
            Map<String, Subject> subjects = new HashMap<String, Subject>();
            Map<String, ObjectStore> objectStores = new HashMap<String, ObjectStore>();
            
            // Pre-obtain all subjects and object stores in the main thread
            System.out.println("[executeSearch] Pre-obtaining connections for " + repos.size() + " repositories...");
            System.out.println("[executeSearch] NOTE: Repository IDs must match exactly the IDs configured in ICN Desktop");
            
            for (RepositoryConfig repo : repos) {
                System.out.println("[executeSearch] ========================================");
                System.out.println("[executeSearch] Attempting connection for repository:");
                System.out.println("[executeSearch]   - Config RepoId: '" + repo.getRepoId() + "'");
                System.out.println("[executeSearch]   - Config RepoName: '" + repo.getRepoName() + "'");
                System.out.println("[executeSearch]   - Config ClassName: '" + repo.getClassName() + "'");
                
                try {
                    // Check session and request context (like sample plugin does)
                    System.out.println("[executeSearch] Request context check:");
                    System.out.println("[executeSearch]   - Request URI: " + request.getRequestURI());
                    System.out.println("[executeSearch]   - Session ID: " + (request.getSession(false) != null ? request.getSession(false).getId() : "NO SESSION"));
                    System.out.println("[executeSearch]   - User Principal: " + (request.getUserPrincipal() != null ? request.getUserPrincipal().getName() : "NULL"));
                    
                    // Following sample plugin pattern: get synch object first (for thread safety)
                    System.out.println("[executeSearch] Getting synch object (like sample plugin)...");
                    Object synchObject = null;
                    try {
                        synchObject = callbacks.getSynchObject(repo.getRepoId(), "p8");
                        System.out.println("[executeSearch] SynchObject result: " + (synchObject != null ? "NOT NULL" : "NULL"));
                    } catch (Exception synchEx) {
                        System.out.println("[executeSearch] EXCEPTION in getSynchObject: " + synchEx.getClass().getName());
                        System.out.println("[executeSearch]   Message: " + synchEx.getMessage());
                        synchEx.printStackTrace();
                    }
                    
                    // Try to get subject - this should work if repository is in desktop
                    System.out.println("[executeSearch] Calling callbacks.getP8Subject('" + repo.getRepoId() + "')...");
                    System.out.println("[executeSearch]   - callbacks object: " + (callbacks != null ? "NOT NULL" : "NULL"));
                    
                    Subject subject = null;
                    try {
                        subject = callbacks.getP8Subject(repo.getRepoId());
                    } catch (Exception subjEx) {
                        System.out.println("[executeSearch] EXCEPTION in getP8Subject: " + subjEx.getClass().getName());
                        System.out.println("[executeSearch]   Message: " + subjEx.getMessage());
                        System.out.println("[executeSearch]   Full stack trace:");
                        subjEx.printStackTrace();
                    }
                    
                    System.out.println("[executeSearch] Subject result: " + (subject != null ? "NOT NULL (SUCCESS)" : "NULL (FAILED)"));
                    
                    if (subject == null) {
                        System.out.println("[executeSearch] ERROR: Subject is NULL - Repository ID '" + repo.getRepoId() + "' may not exist in ICN");
                        System.out.println("[executeSearch]   Possible causes:");
                        System.out.println("[executeSearch]   1. Repository ID doesn't match ICN Desktop configuration");
                        System.out.println("[executeSearch]   2. Repository not assigned to current desktop");
                        System.out.println("[executeSearch]   3. Repository not connected/available in session");
                        System.out.println("[executeSearch]   4. Repository type mismatch (not P8)");
                        System.out.println("[executeSearch] ACTION REQUIRED: Verify the repoId in search-config.json matches the repository ID in ICN Desktop configuration");
                        System.out.println("[executeSearch]   NOTE: Repository IDs are case-sensitive and must match exactly");
                    }
                    
                    // Try to get object store (only if subject is available)
                    if (subject != null) {
                        System.out.println("[executeSearch] Subject available, now getting ObjectStore...");
                        System.out.println("[executeSearch] Calling callbacks.getP8ObjectStore('" + repo.getRepoId() + "')...");
                        ObjectStore objectStore = null;
                        try {
                            objectStore = callbacks.getP8ObjectStore(repo.getRepoId());
                        } catch (Exception objEx) {
                            System.out.println("[executeSearch] EXCEPTION in getP8ObjectStore: " + objEx.getClass().getName());
                            System.out.println("[executeSearch]   Message: " + objEx.getMessage());
                            System.out.println("[executeSearch]   Full stack trace:");
                            objEx.printStackTrace();
                        }
                        
                        System.out.println("[executeSearch] ObjectStore result: " + (objectStore != null ? "NOT NULL (SUCCESS)" : "NULL (FAILED)"));
                        
                        if (objectStore == null) {
                            System.out.println("[executeSearch] ERROR: ObjectStore is NULL even though Subject was available");
                            System.out.println("[executeSearch]   This is unusual - Subject exists but ObjectStore doesn't");
                        }
                        
                        if (subject != null && objectStore != null) {
                            subjects.put(repo.getRepoId(), subject);
                            objectStores.put(repo.getRepoId(), objectStore);
                            System.out.println("[executeSearch] SUCCESS: Connection stored for " + repo.getRepoId());
                            try {
                                System.out.println("[executeSearch] ObjectStore Name: " + objectStore.get_Name());
                            } catch (Exception nameEx) {
                                System.out.println("[executeSearch] ObjectStore Name: (not available - " + nameEx.getMessage() + ")");
                            }
                            System.out.println("[executeSearch] ObjectStore Id: " + objectStore.get_Id());
                        } else {
                            System.out.println("[executeSearch] WARNING: Failed to get connection for " + repo.getRepoId());
                            System.out.println("[executeSearch]   Subject: " + (subject != null ? "OK" : "NULL"));
                            System.out.println("[executeSearch]   ObjectStore: " + (objectStore != null ? "OK" : "NULL"));
                        }
                    } else {
                        System.out.println("[executeSearch] Skipping ObjectStore retrieval - Subject is NULL");
                    }
                } catch (Exception e) {
                    System.out.println("[executeSearch] EXCEPTION getting connection for " + repo.getRepoId() + ":");
                    System.out.println("[executeSearch]   Exception Type: " + e.getClass().getName());
                    System.out.println("[executeSearch]   Exception Message: " + e.getMessage());
                    System.out.println("[executeSearch]   Full stack trace:");
                    e.printStackTrace();
                    callbacks.getLogger().logError(this, methodName, request, e);
                    JSONObject error = new JSONObject();
                    error.put("repository", repo.getRepoName());
                    error.put("message", "Failed to get connection: " + e.getMessage());
                    errors.add(error);
                }
                System.out.println("[executeSearch] ========================================");
            }
            System.out.println("[executeSearch] Successfully obtained " + subjects.size() + " connections out of " + repos.size() + " repositories");
            
            // Now execute searches in parallel with pre-obtained connections
            System.out.println("[executeSearch] Submitting parallel search tasks...");
            ExecutorService executor = Executors.newFixedThreadPool(repos.size());
            List<Future<RepositorySearchResult>> futures = new ArrayList<Future<RepositorySearchResult>>();
            
            for (RepositoryConfig repo : repos) {
                Subject subject = subjects.get(repo.getRepoId());
                ObjectStore objectStore = objectStores.get(repo.getRepoId());
                
                if (subject != null && objectStore != null) {
                    System.out.println("[executeSearch] Submitting search task for: " + repo.getRepoId());
                    // NOTE: We don't pass callbacks or request to worker threads
                    // to avoid SESN0008E session access errors
                    futures.add(executor.submit(new RepositorySearchTask(
                        repo, config, searchCriteria, pageNumber, pageSize,
                        subject, objectStore
                    )));
                } else {
                    System.out.println("[executeSearch] Skipping " + repo.getRepoId() + " - no connection available");
                }
            }
            
            System.out.println("[executeSearch] Submitted " + futures.size() + " search tasks. Waiting for completion...");
            executor.shutdown();
            boolean terminated = executor.awaitTermination(settings.getSearchTimeout(), TimeUnit.MILLISECONDS);
            System.out.println("[executeSearch] Executor terminated: " + terminated);
            
            System.out.println("[executeSearch] Processing " + futures.size() + " search results...");
            for (Future<RepositorySearchResult> future : futures) {
                try {
                    RepositorySearchResult result = future.get();
                    System.out.println("[executeSearch] Result from " + result.getRepoName() + 
                                      " - Success: " + result.isSuccess() + 
                                      ", Count: " + result.getTotalCount() + 
                                      ", Rows: " + result.getResults().size());
                    
                    if (result.isSuccess()) {
                        for (JSONResultSetRow row : result.getResults()) {
                            allRows.add(row);
                        }
                        totalCount += result.getTotalCount();
                        System.out.println("[executeSearch] Added " + result.getResults().size() + 
                                          " rows from " + result.getRepoName());
                    } else {
                        System.out.println("[executeSearch] Search failed for " + result.getRepoName() + 
                                          ": " + result.getErrorMessage());
                        JSONObject error = new JSONObject();
                        error.put("repository", result.getRepoName());
                        error.put("message", result.getErrorMessage());
                        errors.add(error);
                    }
                } catch (Exception e) {
                    System.out.println("[executeSearch] ERROR getting future result: " + e.getMessage());
                    e.printStackTrace();
                    callbacks.getLogger().logError(this, methodName, request, e);
                }
            }
        } else {
            System.out.println("[executeSearch] Using SEQUENTIAL execution mode");
            System.out.println("[executeSearch] NOTE: Repository IDs must match exactly the IDs configured in ICN Desktop");
            // Sequential execution
            for (RepositoryConfig repo : repos) {
                System.out.println("[executeSearch] ========================================");
                System.out.println("[executeSearch] Searching repository: " + repo.getRepoId() + 
                                  " (" + repo.getRepoName() + ")");
                System.out.println("[executeSearch] Config RepoId: '" + repo.getRepoId() + "'");
                System.out.println("[executeSearch] Config ClassName: '" + repo.getClassName() + "'");
                try {
                    RepositorySearchResult result = searchRepository(
                        callbacks, request, repo, config, searchCriteria, pageNumber, pageSize
                    );
                    System.out.println("[executeSearch] Result from " + repo.getRepoId() + 
                                      " - Success: " + result.isSuccess() + 
                                      ", Count: " + result.getTotalCount() + 
                                      ", Rows: " + result.getResults().size());
                    
                    if (result.isSuccess()) {
                        for (JSONResultSetRow row : result.getResults()) {
                            allRows.add(row);
                        }
                        totalCount += result.getTotalCount();
                        System.out.println("[executeSearch] Added " + result.getResults().size() + 
                                          " rows from " + repo.getRepoId());
                    } else {
                        System.out.println("[executeSearch] Search failed for " + repo.getRepoId() + 
                                          ": " + result.getErrorMessage());
                        JSONObject error = new JSONObject();
                        error.put("repository", result.getRepoName());
                        error.put("message", result.getErrorMessage());
                        errors.add(error);
                    }
                } catch (Exception e) {
                    System.out.println("[executeSearch] ERROR searching " + repo.getRepoId() + ": " + e.getMessage());
                    e.printStackTrace();
                    callbacks.getLogger().logError(this, methodName, request, e);
                    JSONObject error = new JSONObject();
                    error.put("repository", repo.getRepoName());
                    error.put("message", e.getMessage());
                    errors.add(error);
                }
            }
        }
        
        System.out.println("[executeSearch] Final results - TotalCount: " + totalCount + 
                          ", AllRows size: " + allRows.size() + 
                          ", Errors: " + errors.size());
        
        // Add all rows to result set
        for (JSONResultSetRow row : allRows) {
            jsonResultSet.addRow(row);
        }
        
        // Add error messages if any
        if (errors.size() > 0) {
            System.out.println("[executeSearch] Errors occurred: " + errors.toString());
            for (int i = 0; i < errors.size(); i++) {
                JSONObject error = (JSONObject) errors.get(i);
                com.ibm.ecm.json.JSONMessage jsonMessage = new com.ibm.ecm.json.JSONMessage(
                    0, 
                    (String) error.get("message"), 
                    "Search error for repository: " + error.get("repository"),
                    "Please check the repository configuration.",
                    "Check the IBM Content Navigator logs for more details.",
                    ""
                );
                jsonResultSet.addErrorMessage(jsonMessage);
            }
        }
        
        System.out.println("[executeSearch] Returning response with " + allRows.size() + " results");
        System.out.println("=========================================");
        System.out.println("[MultiRepoSearchService] executeSearch - END");
        System.out.println("=========================================");
        
        return jsonResultSet;
    }
    
    /**
     * Searches a single repository.
     */
    private RepositorySearchResult searchRepository(PluginServiceCallbacks callbacks, 
            HttpServletRequest request, RepositoryConfig repo, SearchConfiguration config,
            Map<String, Object> searchCriteria, int pageNumber, int pageSize) {
        
        String methodName = "searchRepository";
        System.out.println("[searchRepository] START - Repository: " + repo.getRepoId());
        System.out.println("[searchRepository] Attempting to get connection for repoId: '" + repo.getRepoId() + "'");
        RepositorySearchResult result = new RepositorySearchResult(repo.getRepoName());
        
        Subject subject = null;
        try {
            // Get P8 connection
            System.out.println("[searchRepository] Calling callbacks.getP8Subject('" + repo.getRepoId() + "')...");
            subject = callbacks.getP8Subject(repo.getRepoId());
            System.out.println("[searchRepository] Subject result: " + (subject != null ? "NOT NULL" : "NULL"));
            
            if (subject == null) {
                System.out.println("[searchRepository] ERROR: Subject is NULL for repository: " + repo.getRepoId());
                System.out.println("[searchRepository] This means the repository ID does not exist in ICN Desktop configuration");
                result.setSuccess(false);
                result.setErrorMessage("Repository ID '" + repo.getRepoId() + "' not found in ICN. Please verify the repoId in search-config.json matches the repository ID in ICN Desktop.");
                return result;
            }
            
            UserContext.get().pushSubject(subject);
            System.out.println("[searchRepository] Subject pushed to UserContext");
            
            System.out.println("[searchRepository] Calling callbacks.getP8ObjectStore('" + repo.getRepoId() + "')...");
            ObjectStore objectStore = callbacks.getP8ObjectStore(repo.getRepoId());
            System.out.println("[searchRepository] ObjectStore result: " + (objectStore != null ? "NOT NULL" : "NULL"));
            
            if (objectStore == null) {
                System.out.println("[searchRepository] ERROR: ObjectStore is NULL for repository: " + repo.getRepoId());
                result.setSuccess(false);
                result.setErrorMessage("ObjectStore not found for repository: " + repo.getRepoId());
                return result;
            }
            
            try {
                System.out.println("[searchRepository] ObjectStore Name: " + objectStore.get_Name());
            } catch (Exception nameEx) {
                System.out.println("[searchRepository] ObjectStore Name: (not available - " + nameEx.getMessage() + ")");
            }
            System.out.println("[searchRepository] ObjectStore Id: " + objectStore.get_Id());
            
            return searchRepositoryWithConnection(repo, config, 
                    searchCriteria, pageNumber, pageSize, subject, objectStore);
            
        } catch (Exception e) {
            System.out.println("[searchRepository] EXCEPTION: " + e.getClass().getName() + " - " + e.getMessage());
            e.printStackTrace();
            callbacks.getLogger().logError(this, methodName, request, e);
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
            return result;
        } finally {
            if (subject != null) {
                System.out.println("[searchRepository] Popping subject from UserContext");
                UserContext.get().popSubject();
            }
            System.out.println("[searchRepository] END - Repository: " + repo.getRepoId());
        }
    }
    
    /**
     * Searches a single repository using pre-obtained subject and object store.
     * This version is used for parallel execution where connections are obtained in the main thread.
     * 
     * IMPORTANT: This method does NOT use callbacks or request - it's safe for worker threads.
     * All session-bound resources (Subject, ObjectStore) must be pre-obtained in the main thread.
     * 
     * Supports multiple classes per repository - searches each class and combines results.
     */
    private RepositorySearchResult searchRepositoryWithConnection(RepositoryConfig repo, SearchConfiguration config,
            Map<String, Object> searchCriteria, int pageNumber, int pageSize,
            Subject subject, ObjectStore objectStore) {
        
        // Get all class mappings for this repository
        List<ClassMapping> classMappings = repo.getClassMappings();
        System.out.println("[searchRepositoryWithConnection] START - Repository: " + repo.getRepoId() + 
                          " (" + repo.getRepoName() + "), Classes: " + classMappings.size());
        
        for (ClassMapping cm : classMappings) {
            System.out.println("[searchRepositoryWithConnection]   - Class: " + cm.getClassName());
        }
        
        RepositorySearchResult result = new RepositorySearchResult(repo.getRepoName());
        
        try {
            if (objectStore == null) {
                System.out.println("[searchRepositoryWithConnection] ERROR: ObjectStore is NULL for " + repo.getRepoId());
                result.setSuccess(false);
                result.setErrorMessage("Repository not found: " + repo.getRepoId());
                return result;
            }
            
            if (subject == null) {
                System.out.println("[searchRepositoryWithConnection] ERROR: Subject is NULL for " + repo.getRepoId());
                result.setSuccess(false);
                result.setErrorMessage("Subject not available for: " + repo.getRepoId());
                return result;
            }
            
            try {
                System.out.println("[searchRepositoryWithConnection] ObjectStore name: " + objectStore.get_Name());
            } catch (Exception nameEx) {
                System.out.println("[searchRepositoryWithConnection] ObjectStore name: (not available - " + nameEx.getMessage() + ")");
            }
            System.out.println("[searchRepositoryWithConnection] Pushing subject to UserContext...");
            // Push subject for this thread
            UserContext.get().pushSubject(subject);
            System.out.println("[searchRepositoryWithConnection] Subject pushed successfully");
            
            // Create PropertyFilter to load required properties
            System.out.println("[searchRepositoryWithConnection] Building PropertyFilter...");
            PropertyFilter propFilter = new PropertyFilter();
            
            // Standard properties
            String[] standardProps = {"Id", "Name", "DocumentTitle", "DateCreated", "Creator", "MimeType", "ContentSize"};
            for (String stdProp : standardProps) {
                propFilter.addIncludeProperty(new FilterElement(null, null, null, stdProp, null));
            }
            System.out.println("[searchRepositoryWithConnection] Added standard properties: " + java.util.Arrays.toString(standardProps));
            
            // Add custom properties from result columns configuration
            System.out.println("[searchRepositoryWithConnection] Processing result columns for PropertyFilter...");
            for (ResultColumn col : config.getResultColumns()) {
                String propName = col.getPropertyName();
                if (propName != null && !propName.startsWith("_")) {
                    System.out.println("[searchRepositoryWithConnection]   Adding direct property: " + propName + " (from column: " + col.getColumnId() + ")");
                    propFilter.addIncludeProperty(new FilterElement(null, null, null, propName, null));
                }
            }
            
            // Add mapped properties for _searchField columns from ALL class mappings
            System.out.println("[searchRepositoryWithConnection] Processing _searchField columns for PropertyFilter...");
            for (ResultColumn col : config.getResultColumns()) {
                String propName = col.getPropertyName();
                if (propName != null && propName.startsWith("_searchField:")) {
                    String searchFieldId = propName.substring("_searchField:".length());
                    System.out.println("[searchRepositoryWithConnection]   Column '" + col.getColumnId() + "' -> _searchField:" + searchFieldId);
                    
                    // Add the mapped property for each class
                    for (ClassMapping cm : classMappings) {
                        String mappedProp = cm.getMappedProperty(searchFieldId);
                        if (mappedProp != null) {
                            System.out.println("[searchRepositoryWithConnection]     -> Class '" + cm.getClassName() + "' maps to property: " + mappedProp);
                            propFilter.addIncludeProperty(new FilterElement(null, null, null, mappedProp, null));
                        } else {
                            System.out.println("[searchRepositoryWithConnection]     -> Class '" + cm.getClassName() + "' has NO mapping for field: " + searchFieldId);
                        }
                    }
                }
            }
            System.out.println("[searchRepositoryWithConnection] PropertyFilter build complete.");
            
            int maxResults = config.getSearchSettings().getMaxResultsPerRepo();
            
            // Collect documents from ALL classes in this repository
            // Use a list of Object arrays to track [Document, ClassMapping] pairs
            List<Object[]> allDocumentsWithMappings = new ArrayList<Object[]>();
            int totalCount = 0;
            
            for (ClassMapping classMapping : classMappings) {
                System.out.println("[searchRepositoryWithConnection] ========================================");
                System.out.println("[searchRepositoryWithConnection] Searching class: " + classMapping.getClassName());
                System.out.println("[searchRepositoryWithConnection] ClassMapping field mappings: " + classMapping.getFieldMappings());
                
                // Build query for this class
                String query = buildSearchQueryForClass(classMapping, config, searchCriteria);
                System.out.println("[searchRepositoryWithConnection] Generated SQL Query: " + query);
                
                // Execute search
                SearchSQL searchSQL = new SearchSQL(query);
                SearchScope searchScope = new SearchScope(objectStore);
                
                System.out.println("[searchRepositoryWithConnection] Executing search with maxResults: " + maxResults);
                IndependentObjectSet resultSet = searchScope.fetchObjects(searchSQL, maxResults, propFilter, true);
                
                // Collect documents from this class - store with their ClassMapping
                PageIterator pageIterator = resultSet.pageIterator();
                int classDocCount = 0;
                while (pageIterator.nextPage()) {
                    for (Object obj : pageIterator.getCurrentPage()) {
                        Document doc = (Document) obj;
                        // Store document with its ClassMapping so we don't need to look it up later
                        allDocumentsWithMappings.add(new Object[] { doc, classMapping });
                        classDocCount++;
                        totalCount++;
                    }
                }
                System.out.println("[searchRepositoryWithConnection] Found " + classDocCount + " documents in class " + classMapping.getClassName());
            }
            
            System.out.println("[searchRepositoryWithConnection] ========================================");
            System.out.println("[searchRepositoryWithConnection] Total documents from all classes: " + totalCount);
            
            // Now process documents for pagination
            List<JSONResultSetRow> rows = new ArrayList<JSONResultSetRow>();
            int skip = (pageNumber - 1) * pageSize;
            int endIndex = Math.min(skip + pageSize, allDocumentsWithMappings.size());
            System.out.println("[searchRepositoryWithConnection] Pagination - skip: " + skip + ", pageSize: " + pageSize + 
                              ", endIndex: " + endIndex + ", totalDocs: " + allDocumentsWithMappings.size());
            
            for (int i = skip; i < endIndex; i++) {
                Object[] docWithMapping = allDocumentsWithMappings.get(i);
                Document doc = (Document) docWithMapping[0];
                ClassMapping docClassMapping = (ClassMapping) docWithMapping[1];
                
                try {
                    System.out.println("[searchRepositoryWithConnection] Processing document " + (i + 1) + " of " + allDocumentsWithMappings.size() + 
                                      " (ID: " + doc.get_Id() + ")");
                    System.out.println("[searchRepositoryWithConnection] Using ClassMapping: " + docClassMapping.getClassName() + 
                                      " with field mappings: " + docClassMapping.getFieldMappings());
                    
                    JSONResultSetRow row = documentToJSONResultSetRow(doc, repo, docClassMapping, config);
                    rows.add(row);
                    System.out.println("[searchRepositoryWithConnection] Successfully added document to results");
                } catch (Exception docEx) {
                    System.out.println("[searchRepositoryWithConnection] ERROR processing document: " + docEx.getMessage());
                    docEx.printStackTrace();
                    // Continue with next document
                }
            }
            
            System.out.println("[searchRepositoryWithConnection] Search complete - Total documents: " + totalCount + 
                              ", Documents in page: " + rows.size());
            
            result.setSuccess(true);
            result.setResults(rows);
            result.setTotalCount(totalCount);
            System.out.println("[searchRepositoryWithConnection] SUCCESS - Returning " + rows.size() + " results");
            
        } catch (Exception e) {
            System.out.println("[searchRepositoryWithConnection] ERROR: " + e.getMessage());
            e.printStackTrace();
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
        } finally {
            // Pop subject for this thread
            System.out.println("[searchRepositoryWithConnection] Popping subject from UserContext");
            UserContext.get().popSubject();
            System.out.println("[searchRepositoryWithConnection] END - Repository: " + repo.getRepoId());
        }
        
        return result;
    }
    
    /**
     * Builds a P8 SQL query for a specific class mapping based on search criteria.
     * This method uses the field mappings from the ClassMapping object.
     * 
     * IMPORTANT: All properties that need to be retrieved must be in the SELECT clause.
     * The PropertyFilter alone is not sufficient - properties must be explicitly selected.
     */
    private String buildSearchQueryForClass(ClassMapping classMapping, SearchConfiguration config, 
                                            Map<String, Object> searchCriteria) {
        System.out.println("[buildSearchQueryForClass] START - Class: " + classMapping.getClassName());
        System.out.println("[buildSearchQueryForClass] Search criteria size: " + searchCriteria.size());
        
        StringBuilder sql = new StringBuilder();
        
        // Build SELECT clause with standard properties
        StringBuilder selectClause = new StringBuilder();
        selectClause.append("SELECT This, DocumentTitle, DateCreated, Creator, MimeType, Id");
        
        // Add mapped properties from this class to the SELECT clause
        // This is required because P8 only loads properties that are in the SELECT clause
        java.util.Set<String> addedProperties = new java.util.HashSet<String>();
        addedProperties.add("This");
        addedProperties.add("DocumentTitle");
        addedProperties.add("DateCreated");
        addedProperties.add("Creator");
        addedProperties.add("MimeType");
        addedProperties.add("Id");
        
        Map<String, String> fieldMappings = classMapping.getFieldMappings();
        if (fieldMappings != null) {
            System.out.println("[buildSearchQueryForClass] Adding mapped properties to SELECT clause...");
            for (Map.Entry<String, String> mapping : fieldMappings.entrySet()) {
                String mappedProp = mapping.getValue();
                if (mappedProp != null && !addedProperties.contains(mappedProp)) {
                    selectClause.append(", ").append(mappedProp);
                    addedProperties.add(mappedProp);
                    System.out.println("[buildSearchQueryForClass]   Added to SELECT: " + mappedProp + " (from field: " + mapping.getKey() + ")");
                }
            }
        }
        
        sql.append(selectClause.toString());
        sql.append(" FROM ").append(classMapping.getClassName());
        System.out.println("[buildSearchQueryForClass] Base SQL: " + sql.toString());
        
        List<String> conditions = new ArrayList<String>();
        
        for (Map.Entry<String, Object> entry : searchCriteria.entrySet()) {
            String fieldId = entry.getKey();
            Object value = entry.getValue();
            
            System.out.println("[buildSearchQueryForClass] Processing field: " + fieldId + " = " + value);
            
            if (value == null || value.toString().isEmpty()) {
                System.out.println("[buildSearchQueryForClass] Skipping empty field: " + fieldId);
                continue;
            }
            
            // Use ClassMapping's field mappings
            String propertyName = classMapping.getMappedProperty(fieldId);
            if (propertyName == null) {
                System.out.println("[buildSearchQueryForClass] Field " + fieldId + " not mapped for class " + classMapping.getClassName());
                continue; // Field not mapped for this class
            }
            System.out.println("[buildSearchQueryForClass] Field " + fieldId + " maps to property: " + propertyName);
            
            SearchField field = config.getSearchFieldById(fieldId);
            if (field == null) {
                System.out.println("[buildSearchQueryForClass] Field " + fieldId + " not found in configuration");
                continue;
            }
            System.out.println("[buildSearchQueryForClass] Field type: " + field.getFieldType() + ", Operator: " + field.getOperator());
            
            String condition = buildCondition(propertyName, value, field);
            if (condition != null) {
                conditions.add(condition);
                System.out.println("[buildSearchQueryForClass] Added condition: " + condition);
            } else {
                System.out.println("[buildSearchQueryForClass] No condition generated for " + fieldId);
            }
        }
        
        if (!conditions.isEmpty()) {
            sql.append(" WHERE ");
            StringBuffer whereClause = new StringBuffer();
            for (int i = 0; i < conditions.size(); i++) {
                if (i > 0) whereClause.append(" AND ");
                whereClause.append(conditions.get(i));
            }
            sql.append(whereClause.toString());
            System.out.println("[buildSearchQueryForClass] WHERE clause: " + whereClause.toString());
        } else {
            System.out.println("[buildSearchQueryForClass] No WHERE conditions - will return all documents");
        }
        
        sql.append(" ORDER BY DateCreated DESC");
        
        String finalQuery = sql.toString();
        System.out.println("[buildSearchQueryForClass] Final SQL Query: " + finalQuery);
        System.out.println("[buildSearchQueryForClass] END");
        
        return finalQuery;
    }
    
    /**
     * Builds a P8 SQL query for a repository based on search criteria.
     * @deprecated Use buildSearchQueryForClass with ClassMapping instead
     */
    @Deprecated
    private String buildSearchQuery(RepositoryConfig repo, SearchConfiguration config, 
                                    Map<String, Object> searchCriteria) {
        // For backward compatibility - use first class mapping
        List<ClassMapping> classMappings = repo.getClassMappings();
        if (classMappings != null && !classMappings.isEmpty()) {
            return buildSearchQueryForClass(classMappings.get(0), config, searchCriteria);
        }
        
        // Legacy fallback
        System.out.println("[buildSearchQuery] START - Repository: " + repo.getRepoId() + 
                          ", Class: " + repo.getClassName());
        System.out.println("[buildSearchQuery] Search criteria size: " + searchCriteria.size());
        
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT This, DocumentTitle, DateCreated, Creator, MimeType, Id ");
        sql.append("FROM ").append(repo.getClassName());
        System.out.println("[buildSearchQuery] Base SQL: " + sql.toString());
        
        List<String> conditions = new ArrayList<String>();
        
        for (Map.Entry<String, Object> entry : searchCriteria.entrySet()) {
            String fieldId = entry.getKey();
            Object value = entry.getValue();
            
            System.out.println("[buildSearchQuery] Processing field: " + fieldId + " = " + value);
            
            if (value == null || value.toString().isEmpty()) {
                System.out.println("[buildSearchQuery] Skipping empty field: " + fieldId);
                continue;
            }
            
            String propertyName = repo.getMappedProperty(fieldId);
            if (propertyName == null) {
                System.out.println("[buildSearchQuery] Field " + fieldId + " not mapped for repository " + repo.getRepoId());
                continue; // Field not mapped for this repository
            }
            System.out.println("[buildSearchQuery] Field " + fieldId + " maps to property: " + propertyName);
            
            SearchField field = config.getSearchFieldById(fieldId);
            if (field == null) {
                System.out.println("[buildSearchQuery] Field " + fieldId + " not found in configuration");
                continue;
            }
            System.out.println("[buildSearchQuery] Field type: " + field.getFieldType() + ", Operator: " + field.getOperator());
            
            String condition = buildCondition(propertyName, value, field);
            if (condition != null) {
                conditions.add(condition);
                System.out.println("[buildSearchQuery] Added condition: " + condition);
            } else {
                System.out.println("[buildSearchQuery] No condition generated for " + fieldId);
            }
        }
        
        if (!conditions.isEmpty()) {
            sql.append(" WHERE ");
            StringBuffer whereClause = new StringBuffer();
            for (int i = 0; i < conditions.size(); i++) {
                if (i > 0) whereClause.append(" AND ");
                whereClause.append(conditions.get(i));
            }
            sql.append(whereClause.toString());
            System.out.println("[buildSearchQuery] WHERE clause: " + whereClause.toString());
        } else {
            System.out.println("[buildSearchQuery] No WHERE conditions - will return all documents");
        }
        
        sql.append(" ORDER BY DateCreated DESC");
        
        String finalQuery = sql.toString();
        System.out.println("[buildSearchQuery] Final SQL Query: " + finalQuery);
        System.out.println("[buildSearchQuery] END");
        
        return finalQuery;
    }
    
    /**
     * Builds a single WHERE condition based on field type and operator.
     */
    private String buildCondition(String propertyName, Object value, SearchField field) {
        System.out.println("[buildCondition] Property: " + propertyName + ", Value: " + value + 
                          ", Type: " + field.getFieldType() + ", Operator: " + field.getOperator());
        
        String operator = field.getOperator();
        String valueStr = value.toString().replace("'", "''"); // Escape single quotes
        
        /*switch (field.getFieldType().toLowerCase()) {
            case "string":
                switch (operator.toUpperCase()) {
                    case "LIKE":
                        return propertyName + " LIKE '%" + valueStr + "%'";
                    case "STARTSWITH":
                        return propertyName + " LIKE '" + valueStr + "%'";
                    case "EQUALS":
                    default:
                        return propertyName + " = '" + valueStr + "'";
                }
                
            case "date":
                // Assuming ISO format date string
                return propertyName + " = " + valueStr;
                
            case "integer":
            case "number":
                return propertyName + " = " + valueStr;
                
            case "boolean":
                boolean boolVal = Boolean.parseBoolean(valueStr);
                return propertyName + " = " + boolVal;
                
            default:
                return propertyName + " = '" + valueStr + "'";
        }*/
        
        String fieldType = field.getFieldType().toLowerCase();

        if ("string".equals(fieldType)) {

            String op = operator.toUpperCase();

            if ("LIKE".equals(op)) {
                String condition = propertyName + " LIKE '%" + valueStr + "%'";
                System.out.println("[buildCondition] Generated LIKE condition: " + condition);
                return condition;
            } 
            else if ("STARTSWITH".equals(op)) {
                String condition = propertyName + " LIKE '" + valueStr + "%'";
                System.out.println("[buildCondition] Generated STARTSWITH condition: " + condition);
                return condition;
            } 
            else { // EQUALS or default
                String condition = propertyName + " = '" + valueStr + "'";
                System.out.println("[buildCondition] Generated EQUALS condition: " + condition);
                return condition;
            }

        }
        else if ("date".equals(fieldType)) {
            // Assuming ISO format date string (YYYY-MM-DD)
            // For P8, dates need to be in specific format
            String condition = propertyName + " = DATE '" + valueStr + "'";
            System.out.println("[buildCondition] Generated date condition: " + condition);
            return condition;
        }
        else if ("integer".equals(fieldType) || "number".equals(fieldType)) {
            String condition = propertyName + " = " + valueStr;
            System.out.println("[buildCondition] Generated number condition: " + condition);
            return condition;
        }
        else if ("boolean".equals(fieldType)) {
            boolean boolVal = Boolean.parseBoolean(valueStr);
            String condition = propertyName + " = " + boolVal;
            System.out.println("[buildCondition] Generated boolean condition: " + condition);
            return condition;
        }
        else {
            String condition = propertyName + " = '" + valueStr + "'";
            System.out.println("[buildCondition] Generated default condition: " + condition);
            return condition;
        }

    }
    
    /**
     * Converts a P8 Document to JSONResultSetRow for the result grid.
     * 
     * NOTE: This method does NOT use callbacks or request parameters
     * to ensure it's safe to call from worker threads.
     * 
     * @param doc The P8 Document object
     * @param repo The repository configuration
     * @param classMapping The class mapping for this document (used to resolve _searchField columns)
     * @param config The search configuration
     */
    private JSONResultSetRow documentToJSONResultSetRow(Document doc, RepositoryConfig repo, 
                                      ClassMapping classMapping, SearchConfiguration config) {
        // Get basic info first - these should always work
        String docId = "";
        String docClassName = "";
        String osId = "";
        
        try {
            docId = doc.get_Id().toString();
        } catch (Exception e) {
            docId = "unknown";
        }
        try {
            docClassName = doc.getClassName();
        } catch (Exception e) {
            docClassName = "Document";
        }
        try {
            osId = doc.getObjectStore().get_Id().toString();
        } catch (Exception e) {
            osId = "unknown";
        }
        
        // Build item ID (like sample plugin: className,objectStoreId,objectId)
        String itemId = docClassName + "," + osId + "," + docId;
        
        // Get document name safely
        String docName = "";
        try {
            docName = doc.get_Name();
            if (docName == null) docName = "";
        } catch (Exception e) {
            // Name not available, try to get from properties later
        }
        
        // Get mime type safely
        String mimeType = "";
        try {
            mimeType = doc.get_MimeType();
            if (mimeType == null) mimeType = "";
        } catch (Exception e) {
            // MimeType not available
        }
        
        // Get privileges (default to view/export/email/print/edit)
        long privileges = JSONResultSetRow.PRIV_VIEWDOC | JSONResultSetRow.PRIV_EXPORT | 
                        JSONResultSetRow.PRIV_EMAILDOC | JSONResultSetRow.PRIV_PRINTDOC | 
                        JSONResultSetRow.PRIV_EDITPROPERTIES;
        
        // Create JSONResultSetRow
        JSONResultSetRow row = new JSONResultSetRow(itemId, docName, mimeType, privileges);
        
        // Add standard attributes
        row.addAttribute("ID", docId, JSONResultSetRow.TYPE_STRING, null, docId);
        row.addAttribute("className", docClassName, JSONResultSetRow.TYPE_STRING, null, docClassName);
        
        // Get properties collection for configured columns
        Properties allProperties = null;
        try {
            allProperties = doc.getProperties();
            System.out.println("[documentToJSONResultSetRow] Properties collection obtained, size: " + allProperties.size());
        } catch (Exception e) {
            System.out.println("[documentToJSONResultSetRow] Could not get properties collection: " + e.getMessage());
        }
        
        // Add configured result columns - extract ACTUAL property values
        for (ResultColumn col : config.getResultColumns()) {
            String propName = col.getPropertyName();
            String value = "";
            String displayValue = "";
            String attrType = JSONResultSetRow.TYPE_STRING;
            
            try {
                if ("_repositoryName".equals(propName)) {
                    // Special column for repository name
                    value = repo.getRepoName();
                    displayValue = repo.getRepoName();
                } else if ("_className".equals(propName)) {
                    // Special column for document class name
                    value = docClassName;
                    displayValue = docClassName;
                } else if (propName != null && propName.startsWith("_searchField:")) {
                    // Special column for search field value - resolve using class mapping
                    String searchFieldId = propName.substring("_searchField:".length());
                    System.out.println("[documentToJSONResultSetRow] *** Resolving _searchField: " + searchFieldId);
                    System.out.println("[documentToJSONResultSetRow]     Document class: " + docClassName);
                    System.out.println("[documentToJSONResultSetRow]     ClassMapping available: " + (classMapping != null));
                    
                    if (classMapping != null) {
                        System.out.println("[documentToJSONResultSetRow]     ClassMapping className: " + classMapping.getClassName());
                        System.out.println("[documentToJSONResultSetRow]     ClassMapping fieldMappings: " + classMapping.getFieldMappings());
                        
                        String actualPropName = classMapping.getMappedProperty(searchFieldId);
                        System.out.println("[documentToJSONResultSetRow]     Field '" + searchFieldId + "' maps to property: " + actualPropName);
                        
                        if (actualPropName != null && allProperties != null) {
                            System.out.println("[documentToJSONResultSetRow]     Looking for property '" + actualPropName + "' in properties collection (size: " + allProperties.size() + ")");
                            Property prop = allProperties.find(actualPropName);
                            
                            if (prop != null) {
                                Object propValue = prop.getObjectValue();
                                System.out.println("[documentToJSONResultSetRow]     Property found! Value: " + propValue + " (type: " + (propValue != null ? propValue.getClass().getName() : "null") + ")");
                                
                                if (propValue != null) {
                                    if (propValue instanceof java.util.Date) {
                                        java.util.Date dateVal = (java.util.Date) propValue;
                                        value = String.valueOf(dateVal.getTime());
                                        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                                        displayValue = sdf.format(dateVal);
                                        attrType = JSONResultSetRow.TYPE_TIMESTAMP;
                                    } else {
                                        value = propValue.toString();
                                        displayValue = value;
                                    }
                                    System.out.println("[documentToJSONResultSetRow]     Extracted value: '" + value + "', displayValue: '" + displayValue + "'");
                                } else {
                                    System.out.println("[documentToJSONResultSetRow]     Property value is null");
                                }
                            } else {
                                System.out.println("[documentToJSONResultSetRow]     *** WARNING: Property '" + actualPropName + "' NOT FOUND in properties collection!");
                                // Try to list available properties for debugging
                                try {
                                    System.out.println("[documentToJSONResultSetRow]     Available properties in collection:");
                                    java.util.Iterator<?> propIter = allProperties.iterator();
                                    int propCount = 0;
                                    while (propIter.hasNext() && propCount < 20) {
                                        Property p = (Property) propIter.next();
                                        System.out.println("[documentToJSONResultSetRow]       - " + p.getPropertyName());
                                        propCount++;
                                    }
                                    if (propCount >= 20) {
                                        System.out.println("[documentToJSONResultSetRow]       ... (truncated, more properties exist)");
                                    }
                                } catch (Exception listEx) {
                                    System.out.println("[documentToJSONResultSetRow]     Could not list properties: " + listEx.getMessage());
                                }
                            }
                        } else if (actualPropName == null) {
                            System.out.println("[documentToJSONResultSetRow]     *** WARNING: Field '" + searchFieldId + "' has no mapping in ClassMapping!");
                        } else {
                            System.out.println("[documentToJSONResultSetRow]     *** WARNING: Properties collection is null!");
                        }
                    } else {
                        System.out.println("[documentToJSONResultSetRow]     *** WARNING: ClassMapping is NULL - cannot resolve field mapping!");
                    }
                } else if (allProperties != null) {
                    // Regular property - try to get by name
                    Property prop = allProperties.find(propName);
                    if (prop != null) {
                        Object propValue = prop.getObjectValue();
                        if (propValue != null) {
                            // Handle different property types
                            if (propValue instanceof java.util.Date) {
                                java.util.Date dateVal = (java.util.Date) propValue;
                                value = String.valueOf(dateVal.getTime());
                                java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                                displayValue = sdf.format(dateVal);
                                attrType = JSONResultSetRow.TYPE_TIMESTAMP;
                            } else if (propValue instanceof Integer || propValue instanceof Long) {
                                value = propValue.toString();
                                displayValue = value;
                                attrType = JSONResultSetRow.TYPE_INTEGER;
                            } else if (propValue instanceof Double || propValue instanceof Float) {
                                value = propValue.toString();
                                displayValue = value;
                                attrType = JSONResultSetRow.TYPE_DOUBLE;
                            } else if (propValue instanceof Boolean) {
                                value = propValue.toString();
                                displayValue = value;
                                attrType = JSONResultSetRow.TYPE_BOOLEAN;
                            } else {
                                value = propValue.toString();
                                displayValue = value;
                            }
                        }
                    } else {
                        System.out.println("[documentToJSONResultSetRow] Property not in collection: " + propName);
                    }
                }
            } catch (Exception propEx) {
                System.out.println("[documentToJSONResultSetRow] Error getting property " + propName + ": " + propEx.getMessage());
            }
            
            // Add attribute to row (even if empty)
            row.addAttribute(col.getColumnId(), value, attrType, null, displayValue);
        }
        
        System.out.println("[documentToJSONResultSetRow] Successfully created row for doc: " + docId);
        return row;
    }
    
    /**
     * Builds the result structure with columns (like sample plugin buildP8ResultStructure).
     */
    private void buildResultStructure(JSONResultSetResponse jsonResultSet, SearchConfiguration config,
                                     PluginServiceCallbacks callbacks, Locale locale) {
        // Add standard columns
        String[] states = new String[1];
        states[0] = JSONResultSetColumn.STATE_LOCKED;
        jsonResultSet.addColumn(new JSONResultSetColumn("&nbsp;", "multiStateIcon", false, states));
        jsonResultSet.addColumn(new JSONResultSetColumn("&nbsp;", "17px", "mimeTypeIcon", null, false));
        
        // Add configured result columns
        for (com.cnb.search.model.ResultColumn col : config.getResultColumns()) {
            String width = col.getWidth() != null ? col.getWidth() : "150px";
            jsonResultSet.addColumn(new JSONResultSetColumn(col.getColumnLabel(), width, col.getColumnId(), null, col.isSortable()));
        }
    }
    
    
    /**
     * Helper to get integer parameter with default value.
     */
    private int getIntParameter(HttpServletRequest request, String name, int defaultValue) {
        String value = request.getParameter(name);
        if (value != null && !value.isEmpty()) {
            try {
                return Integer.parseInt(value);
            } catch (NumberFormatException e) {
                return defaultValue;
            }
        }
        return defaultValue;
    }
    
    /**
     * Callable task for parallel repository search.
     * Uses pre-obtained subject and object store to avoid session access issues.
     * 
     * IMPORTANT: This class does NOT hold callbacks or request references
     * to prevent SESN0008E errors when accessing HttpSession from worker threads.
     */
    private class RepositorySearchTask implements Callable<RepositorySearchResult> {
        private final RepositoryConfig repo;
        private final SearchConfiguration config;
        private final Map<String, Object> searchCriteria;
        private final int pageNumber;
        private final int pageSize;
        private final Subject subject;
        private final ObjectStore objectStore;
        
        public RepositorySearchTask(RepositoryConfig repo, SearchConfiguration config,
                                   Map<String, Object> searchCriteria, int pageNumber, int pageSize,
                                   Subject subject, ObjectStore objectStore) {
            this.repo = repo;
            this.config = config;
            this.searchCriteria = searchCriteria;
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.subject = subject;
            this.objectStore = objectStore;
        }
        
        public RepositorySearchResult call() throws Exception {
            // Call the thread-safe version that doesn't use callbacks or request
            return searchRepositoryWithConnection(repo, config, 
                    searchCriteria, pageNumber, pageSize, subject, objectStore);
        }
    }
    
    /**
     * Container for repository search results.
     */
    private static class RepositorySearchResult {
        private final String repoName;
        private boolean success;
        private List<JSONResultSetRow> results;
        private int totalCount;
        private String errorMessage;
        
        public RepositorySearchResult(String repoName) {
            this.repoName = repoName;
            this.results = new ArrayList<JSONResultSetRow>();
        }
        
        public String getRepoName() { return repoName; }
        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }
        public List<JSONResultSetRow> getResults() { return results; }
        public void setResults(List<JSONResultSetRow> results) { this.results = results; }
        public int getTotalCount() { return totalCount; }
        public void setTotalCount(int totalCount) { this.totalCount = totalCount; }
        public String getErrorMessage() { return errorMessage; }
        public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    }
}

{
  "searchFields": [
    {
      "fieldId": "customerName",
      "fieldLabel": "Customer Name",
      "fieldType": "string",
      "operator": "LIKE",
      "placeholder": "Enter customer name",
      "required": false
    },
    {
      "fieldId": "dob",
      "fieldLabel": "Date of Birth",
      "fieldType": "date",
      "operator": "EQUALS",
      "placeholder": "Select date",
      "required": false
    }
  ],
  "repositories": [
    {
      "repoId": "Banking",
      "repoName": "Banking Repository",
      "enabled": true,
      "classes": [
        {
          "className": "CustomerProfile",
          "fieldMappings": {
            "customerName": "FullName",
            "dob": "DateOfBirth"
          }
        },
        {
          "className": "KYCDocument",
          "fieldMappings": {
            "customerName": "FullName",
            "dob": "ExpiryDate"
          }
        }
      ]
    },
    {
      "repoId": "Education",
      "repoName": "Education Repository",
      "enabled": true,
      "classes": [
        {
          "className": "StudentProfile",
          "fieldMappings": {
            "customerName": "FullName",
            "dob": "DateOfBirth"
          }
        }
      ]
    },
    {
      "repoId": "GovRecords",
      "repoName": "Government Records Repository",
      "enabled": true,
      "classes": [
        {
          "className": "CitizenIDApplication",
          "fieldMappings": {
            "dob": "DateOfBirth"
          }
        }
      ]
    }
  ],
  "resultColumns": [
    {
      "columnId": "DocumentTitle",
      "columnLabel": "Document Title",
      "propertyName": "DocumentTitle",
      "type": "String",
      "width": "200px",
      "sortable": true
    },
    {
      "columnId": "customerNameValue",
      "columnLabel": "Customer Name",
      "propertyName": "_searchField:customerName",
      "type": "String",
      "width": "150px",
      "sortable": false
    },
    {
      "columnId": "dobValue",
      "columnLabel": "Date of Birth",
      "propertyName": "_searchField:dob",
      "type": "Date",
      "width": "120px",
      "sortable": false
    },
    {
      "columnId": "Creator",
      "columnLabel": "Created By",
      "propertyName": "Creator",
      "type": "String",
      "width": "120px",
      "sortable": true
    },
    {
      "columnId": "DateCreated",
      "columnLabel": "Date Created",
      "propertyName": "DateCreated",
      "type": "Date",
      "width": "150px",
      "sortable": true
    }
  ],
  "searchSettings": {
    "maxResultsPerRepo": 500,
    "pageSize": 50,
    "enableParallelSearch": true,
    "searchTimeout": 30000,
    "showPartialResults": true
  }
}
