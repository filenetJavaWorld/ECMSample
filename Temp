package com.wawa.ace.migration.util;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoField;
import java.util.Date;

/**
 * Utility class for date parsing and formatting.
 */
public class DateUtils {
    
    private static final Logger logger = LogManager.getLogger(DateUtils.class);
    
    // Format for timestamps in file names
    public static final String FILE_TIMESTAMP_FORMAT = "yyyyMMdd_HHmmss";
    public static final DateTimeFormatter FILE_TIMESTAMP_FORMATTER = 
            DateTimeFormatter.ofPattern(FILE_TIMESTAMP_FORMAT);
    
    // Format for display timestamps
    public static final String DISPLAY_TIMESTAMP_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final DateTimeFormatter DISPLAY_TIMESTAMP_FORMATTER = 
            DateTimeFormatter.ofPattern(DISPLAY_TIMESTAMP_FORMAT);
    
    // ISO format with offset
    public static final String ISO_OFFSET_FORMAT = "yyyy-MM-dd HH:mm:ss.SSSSSSXXX";
    
    // Flexible formatter for parsing the CSV date format
    // Handles: 2025-06-07 17:23:58.542084+00:00
    private static final DateTimeFormatter CSV_DATE_FORMATTER = new DateTimeFormatterBuilder()
            .appendPattern("yyyy-MM-dd HH:mm:ss")
            .optionalStart()
            .appendFraction(ChronoField.MICRO_OF_SECOND, 0, 6, true)
            .optionalEnd()
            .optionalStart()
            .appendOffset("+HH:MM", "+00:00")
            .optionalEnd()
            .optionalStart()
            .appendOffset("+HHmm", "+0000")
            .optionalEnd()
            .optionalStart()
            .appendLiteral('Z')
            .optionalEnd()
            .toFormatter();
    
    private DateUtils() {
        // Utility class
    }
    
    /**
     * Get current timestamp formatted for file names.
     */
    public static String getCurrentFileTimestamp() {
        return LocalDateTime.now().format(FILE_TIMESTAMP_FORMATTER);
    }
    
    /**
     * Get current timestamp formatted for display.
     */
    public static String getCurrentDisplayTimestamp() {
        return LocalDateTime.now().format(DISPLAY_TIMESTAMP_FORMATTER);
    }
    
    /**
     * Format a LocalDateTime for display.
     */
    public static String formatForDisplay(LocalDateTime dateTime) {
        if (dateTime == null) return "";
        return dateTime.format(DISPLAY_TIMESTAMP_FORMATTER);
    }
    
    /**
     * Format a LocalDateTime for file names.
     */
    public static String formatForFileName(LocalDateTime dateTime) {
        if (dateTime == null) return "";
        return dateTime.format(FILE_TIMESTAMP_FORMATTER);
    }
    
    /**
     * Parse a date string from CSV format to Date.
     * Handles format: 2025-06-07 17:23:58.542084+00:00
     */
    public static Date parseCsvDate(String dateString) {
        if (dateString == null || dateString.trim().isEmpty()) {
            return null;
        }
        
        try {
            // Try parsing with offset
            OffsetDateTime odt = OffsetDateTime.parse(dateString.trim(), CSV_DATE_FORMATTER);
            return Date.from(odt.toInstant());
        } catch (DateTimeParseException e) {
            logger.debug("Failed to parse with offset, trying without: {}", dateString);
        }
        
        try {
            // Try parsing without offset (assume UTC)
            LocalDateTime ldt = LocalDateTime.parse(dateString.trim(), CSV_DATE_FORMATTER);
            return Date.from(ldt.atZone(ZoneOffset.UTC).toInstant());
        } catch (DateTimeParseException e) {
            logger.warn("Failed to parse date: {}", dateString, e);
            return null;
        }
    }
    
    /**
     * Parse a date string with a custom format.
     * Handles both formats with and without microseconds:
     * - Type 1: 2022-12-22 18:46:57.038000+00:00 (with microseconds)
     * - Type 2: 2015-08-31 15:45:53+00:00 (without microseconds)
     */
    public static Date parseDate(String dateString, String format) {
        if (dateString == null || dateString.trim().isEmpty()) {
            return null;
        }
        
        try {
            DateTimeFormatter formatter;
            
            // Check if format contains microseconds pattern (.SSSSSS)
            // If so, create a flexible formatter with optional fractional seconds
            if (format != null && format.contains(".SSSSSS")) {
                formatter = buildFlexibleDateTimeFormatter(format);
            } else {
                formatter = DateTimeFormatter.ofPattern(format);
            }
            
            // Try parsing as OffsetDateTime first
            try {
                OffsetDateTime odt = OffsetDateTime.parse(dateString.trim(), formatter);
                return Date.from(odt.toInstant());
            } catch (DateTimeParseException e) {
                // Try as LocalDateTime
                LocalDateTime ldt = LocalDateTime.parse(dateString.trim(), formatter);
                return Date.from(ldt.atZone(ZoneOffset.UTC).toInstant());
            }
        } catch (DateTimeParseException e) {
            logger.warn("Failed to parse date '{}' with format '{}'", dateString, format, e);
            return null;
        }
    }
    
    /**
     * Build a flexible DateTimeFormatter that handles optional fractional seconds.
     * This allows parsing both:
     * - Dates with microseconds: 2022-12-22 18:46:57.038000+00:00
     * - Dates without microseconds: 2015-08-31 15:45:53+00:00
     * 
     * @param format The original format pattern (e.g., "yyyy-MM-dd HH:mm:ss.SSSSSSXXX")
     * @return A flexible DateTimeFormatter
     */
    private static DateTimeFormatter buildFlexibleDateTimeFormatter(String format) {
        // Extract the base pattern before the fractional seconds
        // Format is expected to be like: yyyy-MM-dd HH:mm:ss.SSSSSSXXX
        String basePattern = format.substring(0, format.indexOf(".SSSSSS"));
        String offsetPattern = format.substring(format.indexOf(".SSSSSS") + 7); // Get pattern after .SSSSSS
        
        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder()
                .appendPattern(basePattern)
                .optionalStart()
                .appendFraction(ChronoField.MICRO_OF_SECOND, 0, 6, true)
                .optionalEnd();
        
        // Handle offset patterns (XXX, XX, X, etc.)
        if (offsetPattern != null && !offsetPattern.isEmpty()) {
            if (offsetPattern.equals("XXX") || offsetPattern.equals("XXXXX")) {
                builder.appendOffset("+HH:MM", "+00:00");
            } else if (offsetPattern.equals("XX") || offsetPattern.equals("XXXX")) {
                builder.appendOffset("+HHmm", "+0000");
            } else if (offsetPattern.equals("X")) {
                builder.appendOffset("+HH", "+00");
            } else {
                // For other patterns, try to append directly
                builder.appendPattern(offsetPattern);
            }
        }
        
        return builder.toFormatter();
    }
    
    /**
     * Convert Date to LocalDateTime.
     */
    public static LocalDateTime toLocalDateTime(Date date) {
        if (date == null) return null;
        return LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
    }
    
    /**
     * Convert LocalDateTime to Date.
     */
    public static Date toDate(LocalDateTime localDateTime) {
        if (localDateTime == null) return null;
        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }
    
    /**
     * Get current date as java.util.Date.
     */
    public static Date getCurrentDate() {
        return new Date();
    }
    
    /**
     * Format duration in milliseconds to human-readable string.
     */
    public static String formatDuration(long durationMs) {
        if (durationMs < 1000) {
            return durationMs + "ms";
        }
        
        long seconds = durationMs / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        
        if (hours > 0) {
            return String.format("%dh %dm %ds", hours, minutes % 60, seconds % 60);
        } else if (minutes > 0) {
            return String.format("%dm %ds", minutes, seconds % 60);
        } else {
            return String.format("%ds %dms", seconds, durationMs % 1000);
        }
    }
    
    /**
     * Calculate elapsed time in milliseconds.
     */
    public static long getElapsedMs(LocalDateTime start, LocalDateTime end) {
        return Duration.between(start, end).toMillis();
    }
    
    /**
     * Calculate elapsed time from start to now in milliseconds.
     */
    public static long getElapsedMs(LocalDateTime start) {
        return Duration.between(start, LocalDateTime.now()).toMillis();
    }
}

