{
  "dataSources": {
    "RAMDB": {
      "type": "jndi",
      "jndiName": "jdbc/RAMDB"
    }
  },
  "documentClasses": {
    "VehicleRegistration": {
      "desktops": ["Automotive", "Admin"],
      "Vehicle Registration ET":{
      		"propertyDisplayOrder": ["RecordLookup", "VIN", "RegistrationNumber", "VehicleType"],
		      "showProperties": ["RecordLookup", "VIN", "RegistrationNumber", "VehicleType"],
		      "customLabelsAndDesc": {
		      				"labels":{"RegistrationNumber":"Registration Number of the vehicle"},
		      				"desc":{"RegistrationNumber":"Registration Number of the vehicle Desc"}
		      },
		      "requiredProperties": ["RegistrationNumber", "VehicleType"]
      },
      "Vehicle Regi ET":{
      		"propertyDisplayOrder": ["FuelType"],
		      "showProperties": ["FuelType", "RegistrationDate", "OwnerName"],
		      "customLabelsAndDesc": {
		      				"labels":{"FuelType":"FuelType of the vehicle"},
		      				"desc":{"FuelType":"FuelType of the vehicle Desc"}
		      },
		      "requiredProperties": ["FuelType", "OwnerName"]
      },
      "properties": {
        "RecordLookup": {
          "displayName": "Record Lookup",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "none",
          "allowClear": true,
          "allowEdit": true,
          "clearAfterSelection": true,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT TOP {limit} VIN, RegistrationNumber, RegistrationDate, OwnerName, VehicleType, FuelType FROM [RAMDB].[dbo].[VehicleInformation] WHERE VIN LIKE ? OR RegistrationNumber LIKE ? ORDER BY RegistrationNumber",
            "resultColumns": ["VIN", "RegistrationNumber", "RegistrationDate", "OwnerName", "VehicleType", "FuelType"],
            "filterColumns": ["VIN", "RegistrationNumber"],
            "searchPattern": "contains"
          },
          "displayColumns": {
            "VIN": "VIN",
            "RegistrationNumber": "Registration Number",
            "RegistrationDate": "Registration Date",
            "OwnerName": "Owner Name"
          },
          "fieldMappings": {
            "VIN": {
              "sourceAlias": "VIN",
              "targetProperty": "VIN",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "RegistrationNumber": {
              "sourceAlias": "RegistrationNumber",
              "targetProperty": "RegistrationNumber",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "RegistrationDate": {
              "sourceAlias": "RegistrationDate",
              "targetProperty": "RegistrationDate",
              "dataType": "xs:date",
              "cardinality": "SINGLE"
            },
            "OwnerName": {
              "sourceAlias": "OwnerName",
              "targetProperty": "OwnerName",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 2,
            "debounceDelay": 300,
            "placeholder": "Type VIN or Registration Number...",
            "limit": 1000
          }
        },
        "VehicleType": {
          "displayName": "Vehicle Type",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "top500",
          "allowClear": true,
          "allowEdit": false,
          "clearAfterSelection": false,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT DISTINCT TOP {limit} [VehicleType], [FuelType] FROM [RAMDB].[dbo].[VehicleInformation] ORDER BY VehicleType",
            "resultColumns": ["VehicleType", "FuelType"],
            "filterColumns": ["VehicleType"],
            "searchPattern": "startsWith"
          },
          "displayColumns": {
            "VehicleType": "Vehicle Type",
            "FuelType": "Fuel Type"
          },
          "fieldMappings": {
            "VehicleType": {
              "sourceAlias": "VehicleType",
              "targetProperty": "VehicleType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "FuelType": {
              "sourceAlias": "FuelType",
              "targetProperty": "FuelType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 0,
            "debounceDelay": 300,
            "placeholder": "Select Vehicle Type...",
            "limit": 500
          }
        }
      }
    },
    "CarModel": {
      "desktops": ["Automotive", "Admin"],
      "propertyDisplayOrder": ["RecordLookup", "ModelYear", "Manufacturer", "Model", "Variant", "EngineType", "Transmission"],
      "showProperties": ["RecordLookup", "ModelYear", "Manufacturer", "Model", "Variant", "EngineType", "Transmission"],
      "customLabelsAndDesc": {	
      					"labels":{"ModelYear":"Model Year of the vehicle"},
      					"desc":{"RegistrationNumber":"Registration Number of the vehicle Desc"}
      },
      "requiredProperties": ["Manufacturer", "Model", "Variant"],
      "properties": {
        "RecordLookup": {
          "displayName": "Record Lookup",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "none",
          "allowClear": true,
          "allowEdit": true,
          "clearAfterSelection": true,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT TOP {limit} [Model_Code], [Make], [Model_Name], [Year] FROM [RAMDB].[dbo].[VehicleModels] WHERE [Model_Name] LIKE ? ORDER BY [Model_Name]",
            "resultColumns": ["Model_Code", "Make", "Model_Name"],
            "filterColumns": ["Model_Name"],
            "searchPattern": "contains"
          },
          "displayColumns": {
            "Model_Code": "Model Code",
            "Make": "Make",
            "Model_Name": "Model Name"
          },
          "fieldMappings": {
            "Model_Code": {
              "sourceAlias": "Model_Code",
              "targetProperty": "ModelCode",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Make": {
              "sourceAlias": "Make",
              "targetProperty": "Make",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Model_Name": {
              "sourceAlias": "Model_Name",
              "targetProperty": "ModelName",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Year": {
              "sourceAlias": "Year",
              "targetProperty": "Year",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 2,
            "debounceDelay": 300,
            "placeholder": "Type Model Name...",
            "limit": 1000
          }
        },
        "EngineType": {
          "displayName": "Engine Type",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "top500",
          "allowClear": true,
          "allowEdit": false,
          "clearAfterSelection": false,
          "tooltipMessage": "Select from available engine types",
          "hasDependentProperties": false,
          "queryConfig": {
            "sql": "SELECT DISTINCT [Engine_Type] FROM [RAMDB].[dbo].[VehicleModels] ORDER BY [Engine_Type]",
            "resultColumns": ["Engine_Type"],
            "filterColumns": ["Engine_Type"],
            "searchPattern": "startsWith"
          },
          "displayColumns": {
            "Engine_Type": "Engine Type"
          },
          "fieldMappings": {
            "Engine_Type": {
              "sourceAlias": "Engine_Type",
              "targetProperty": "EngineType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 0,
            "debounceDelay": 0,
            "placeholder": "Select Engine Type...",
            "limit": 500
          }
        }
      }
    }
  }
}




require([
    "dojo/_base/declare",
         "dojo/_base/lang",
    "dojo/aspect",
    "ecm/model/Request",
    "cNBPropertyEditorEDSPluginDojo/InlineAutocompleteEditor"
], 
function(declare, lang, aspect, Request, InlineAutocompleteEditor) {
    
    console.log("[CNBPropertyEditorEDSPlugin] ====================================");
    console.log("[CNBPropertyEditorEDSPlugin] Initializing plugin...");
    
    var editorConfig = null;
    var configLoaded = false;
    var configLoading = false;
    
    /**
     * Load configuration from backend using ICN Request API
     */
    function loadConfiguration() {
        if (configLoaded || configLoading) {
            return;
        }
        
        configLoading = true;
        console.log("[CNBPropertyEditorEDSPlugin] Loading configuration from backend...");
        
        // Use ICN's Request.invokePluginService() - the correct way!
        Request.invokePluginService("CNBPropertyEditorEDSPlugin", "GetLookupConfigService", {
            requestParams: {},
            requestCompleteCallback: function(response) {
                console.log("[CNBPropertyEditorEDSPlugin] Service response:", response);
                
                editorConfig = response.documentClasses || {};
                configLoaded = true;
                configLoading = false;
                
                var classCount = Object.keys(editorConfig).length;
                console.log("[CNBPropertyEditorEDSPlugin] ✓ Configuration loaded successfully");
                console.log("[CNBPropertyEditorEDSPlugin] ✓ Loaded " + classCount + " document class(es):");
                
                for (var className in editorConfig) {
                    var propsCount = editorConfig[className].properties ? 
                                    Object.keys(editorConfig[className].properties).length : 0;
                    console.log("[CNBPropertyEditorEDSPlugin]   - " + className + " (" + propsCount + " properties)");
                }
            },
            requestFailedCallback: function(error) {
                console.error("[CNBPropertyEditorEDSPlugin] ✗ Failed to load configuration:", error);
                editorConfig = {};
                configLoaded = true;
                configLoading = false;
            }
        });
    }
    
    // Load configuration on plugin startup
    loadConfiguration();
    
    // ========================================================================
    // PROPERTY DISPLAY ORDER: Intercept CommonPropertiesPane.renderAttributes
    // to reorder properties according to configuration
    // ========================================================================
    require(["ecm/widget/CommonPropertiesPane"], function(CommonPropertiesPane) {
        try {
            console.log("[CNBPropertyEditorEDSPlugin] Setting up property display order interception...");
            
            aspect.around(CommonPropertiesPane.prototype, "renderAttributes", function(original) {
                return function(attributeDefinitions, item, reason, isReadOnly, params) {
                    console.log("[CNBPropertyEditorEDSPlugin] ========================================");
                    console.log("[CNBPropertyEditorEDSPlugin] >>> Intercepting renderAttributes");
                    console.log("[CNBPropertyEditorEDSPlugin] Reason:", reason);
                    console.log("[CNBPropertyEditorEDSPlugin] Number of properties:", attributeDefinitions ? attributeDefinitions.length : 0);
                    
                    // If item is not null (editing existing document), remove propertyEditor and Record_Lookup
                    if (item != null && attributeDefinitions && attributeDefinitions.length > 0) {
                        console.log("[CNBPropertyEditorEDSPlugin] Item is not null - removing propertyEditor from all attributes");
                        var removedCount = 0;
                        
                        for (var i = 0; i < attributeDefinitions.length; i++) {
                            var attr = attributeDefinitions[i];
                            if (attr && attr.propertyEditor) {
                                console.log("[CNBPropertyEditorEDSPlugin]   ✗ Removing propertyEditor from: " + (attr.id || attr.name));
                                delete attr.propertyEditor;
                                removedCount++;
                            }
                        }
                        
                        console.log("[CNBPropertyEditorEDSPlugin] ✓ Removed propertyEditor from " + removedCount + " attribute(s)");
                        
                        // Remove Record_Lookup attribute definition
                        var recordLookupIndex = -1;
                        for (var j = 0; j < attributeDefinitions.length; j++) {
                            var attrDef = attributeDefinitions[j];
                            var attrName = attrDef ? (attrDef.id || attrDef.name) : null;
                            if (attrName === "Record_Lookup") {
                                recordLookupIndex = j;
                                break;
                            }
                        }
                        
                        if (recordLookupIndex !== -1) {
                            console.log("[CNBPropertyEditorEDSPlugin]   ✗ Removing Record_Lookup attribute definition from array");
                            attributeDefinitions.splice(recordLookupIndex, 1);
                            console.log("[CNBPropertyEditorEDSPlugin] ✓ Removed Record_Lookup attribute definition");
                            console.log("[CNBPropertyEditorEDSPlugin]   Remaining properties: " + attributeDefinitions.length);
                        } else {
                            console.log("[CNBPropertyEditorEDSPlugin]   Record_Lookup attribute definition not found");
                        }
                    }
                    
                    // Only apply entry template-specific configurations for document creation
                    if (configLoaded && editorConfig && attributeDefinitions && attributeDefinitions.length > 0 && item == null) {
                        try {
                            // Get document class name
                            var documentClass = null;
                            
                            if (attributeDefinitions[0] && attributeDefinitions[0].contentClass) {
                                documentClass = attributeDefinitions[0].contentClass.id;
                            } else if (item && item.contentClass) {
                                documentClass = item.contentClass.name;
                            }
                            
                            console.log("[CNBPropertyEditorEDSPlugin] Document class:", documentClass);
                            
                            // Get entry template name from params
                            var entryTemplateName = null;
                            if (params && params.entryTemplate && params.entryTemplate.name) {
                                entryTemplateName = params.entryTemplate.name;
                                console.log("[CNBPropertyEditorEDSPlugin] Entry template name:", entryTemplateName);
                            }
                            
                            // Get configuration - check for entry template-specific config first
                            var entryTemplateConfig = null;
                            if (documentClass && editorConfig[documentClass]) {
                                var classConfig = editorConfig[documentClass];
                                
                                // If entry template name is available, try to get entry template-specific config
                                if (entryTemplateName && classConfig[entryTemplateName]) {
                                    entryTemplateConfig = classConfig[entryTemplateName];
                                    console.log("[CNBPropertyEditorEDSPlugin] ✓ Found entry template-specific configuration for: " + entryTemplateName);
                                } else {
                                    // Fallback: check if classConfig has direct properties (backward compatibility)
                                    if (classConfig.propertyDisplayOrder || classConfig.showProperties || 
                                        classConfig.customLabelsAndDesc || classConfig.requiredProperties) {
                                        entryTemplateConfig = classConfig;
                                        console.log("[CNBPropertyEditorEDSPlugin] ✓ Using document class-level configuration (backward compatibility)");
                                    }
                                }
                            }
                            
                            if (entryTemplateConfig) {
                                // STEP 1: Filter properties based on showProperties
                                if (entryTemplateConfig.showProperties && entryTemplateConfig.showProperties.length > 0) {
                                    console.log("[CNBPropertyEditorEDSPlugin] ✓ showProperties configured:", entryTemplateConfig.showProperties);
                                    
                                    var visibleAttributes = [];
                                    
                                    attributeDefinitions.forEach(function(attr) {
                                        var propertyName = attr.id || attr.name;
                                        
                                        // Check if this property should be visible
                                        var shouldVisible = entryTemplateConfig.showProperties.indexOf(propertyName) !== -1;
                                        
                                        if (shouldVisible) {
                                            visibleAttributes.push(attr);
                                        } else {
                                            console.log("[CNBPropertyEditorEDSPlugin]   ✗ Hiding property:", propertyName);
                                        }
                                    });
                                    
                                    console.log("[CNBPropertyEditorEDSPlugin] ✓ Properties filtered successfully");
                                    console.log("[CNBPropertyEditorEDSPlugin]   Before filtering: " + attributeDefinitions.length + " properties");
                                    console.log("[CNBPropertyEditorEDSPlugin]   After filtering: " + visibleAttributes.length + " properties");
                                    
                                    // Replace attributeDefinitions with filtered version
                                    attributeDefinitions = visibleAttributes;
                                }
                                
                                // STEP 2: Apply custom labels and descriptions
                                if (entryTemplateConfig.customLabelsAndDesc) {
                                    var labels = entryTemplateConfig.customLabelsAndDesc.labels;
                                    var desc = entryTemplateConfig.customLabelsAndDesc.desc;
                                    
                                    if (labels || desc) {
                                        console.log("[CNBPropertyEditorEDSPlugin] ✓ Custom labels/descriptions configured");
                                        
                                        attributeDefinitions.forEach(function(attr) {
                                            var propertyName = attr.id || attr.name;
                                            
                                            if (labels && labels[propertyName]) {
                                                attr.label = labels[propertyName];
                                                console.log("[CNBPropertyEditorEDSPlugin]   ✓ Updated label for '" + propertyName + "': " + labels[propertyName]);
                                            }
                                            
                                            if (desc && desc[propertyName]) {
                                                attr.description = desc[propertyName];
                                                console.log("[CNBPropertyEditorEDSPlugin]   ✓ Updated description for '" + propertyName + "': " + desc[propertyName]);
                                            }
                                        });
                                    }
                                }
                                
                                // STEP 3: Reorder properties based on propertyDisplayOrder
                                if (entryTemplateConfig.propertyDisplayOrder && entryTemplateConfig.propertyDisplayOrder.length > 0) {
                                    console.log("[CNBPropertyEditorEDSPlugin] ✓ Property display order configured:", entryTemplateConfig.propertyDisplayOrder);
                                    
                                    // Reorder attributeDefinitions based on propertyDisplayOrder
                                    var orderedAttributes = [];
                                    var remainingAttributes = [].concat(attributeDefinitions); // Clone array
                                    
                                    // First, add properties in the specified order
                                    entryTemplateConfig.propertyDisplayOrder.forEach(function(propertyName) {
                                        for (var i = 0; i < remainingAttributes.length; i++) {
                                            var attr = remainingAttributes[i];
                                            if (attr.id === propertyName || attr.name === propertyName) {
                                                orderedAttributes.push(attr);
                                                remainingAttributes.splice(i, 1);
                                                console.log("[CNBPropertyEditorEDSPlugin]   ✓ Ordered property:", propertyName);
                                                break;
                                            }
                                        }
                                    });
                                    
                                    // Then, add any remaining properties not in the display order (at the end)
                                    remainingAttributes.forEach(function(attr) {
                                        orderedAttributes.push(attr);
                                        console.log("[CNBPropertyEditorEDSPlugin]   + Added remaining property:", attr.id || attr.name);
                                    });
                                    
                                    console.log("[CNBPropertyEditorEDSPlugin] ✓ Properties reordered successfully");
                                    console.log("[CNBPropertyEditorEDSPlugin]   Original order: " + 
                                               attributeDefinitions.map(function(a) { return a.id || a.name; }).join(", "));
                                    console.log("[CNBPropertyEditorEDSPlugin]   New order: " + 
                                               orderedAttributes.map(function(a) { return a.id || a.name; }).join(", "));
                                    
                                    // Replace attributeDefinitions with ordered version
                                    attributeDefinitions = orderedAttributes;
                                }
                                
                                // STEP 4: Apply required properties
                                if (entryTemplateConfig.requiredProperties && entryTemplateConfig.requiredProperties.length > 0) {
                                    console.log("[CNBPropertyEditorEDSPlugin] ✓ requiredProperties configured:", entryTemplateConfig.requiredProperties);
                                    
                                    attributeDefinitions.forEach(function(attr) {
                                        var propertyName = attr.id || attr.name;
                                        var isRequired = entryTemplateConfig.requiredProperties.indexOf(propertyName) !== -1;
                                        
                                        // Set required attribute based on configuration
                                        attr.required = isRequired;
                                        
                                        if (isRequired) {
                                            console.log("[CNBPropertyEditorEDSPlugin]   ✓ Set required=true for: " + propertyName);
                                        } else {
                                            // Only log if it was previously required (to show we're clearing it)
                                            if (attr.required === true) {
                                                console.log("[CNBPropertyEditorEDSPlugin]   ✓ Set required=false for: " + propertyName + " (was previously required)");
                                            }
                                        }
                                    });
                                }
                            } else {
                                if (documentClass && !editorConfig[documentClass]) {
                                    console.log("[CNBPropertyEditorEDSPlugin]   No configuration found for document class: " + documentClass);
                                } else if (entryTemplateName && documentClass && editorConfig[documentClass] && !editorConfig[documentClass][entryTemplateName]) {
                                    console.log("[CNBPropertyEditorEDSPlugin]   No entry template-specific configuration found for: " + entryTemplateName);
                                }
                            }
                        } catch (e) {
                            console.error("[CNBPropertyEditorEDSPlugin] Error applying entry template configurations:", e);
                        }
                    }
                    
                    // Call original renderAttributes with (possibly modified) attributeDefinitions
                    return original.call(this, attributeDefinitions, item, reason, isReadOnly, params);
                };
            });
            
            console.log("[CNBPropertyEditorEDSPlugin] ✓ Property display order interception set up successfully");
            
        } catch (e) {
            console.error("[CNBPropertyEditorEDSPlugin] Failed to set up property display order:", e);
        }
    });
    
    console.log("[CNBPropertyEditorEDSPlugin] Plugin initialized successfully");
    console.log("[CNBPropertyEditorEDSPlugin] ====================================");
});





package com.cnb.eds.editor.filters;

import javax.servlet.http.HttpServletRequest;

import com.cnb.eds.editor.config.LookupConfigManager;
import com.ibm.ecm.extension.PluginResponseFilter;
import com.ibm.ecm.extension.PluginServiceCallbacks;
import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;
import java.util.Map;

/**
 * Response filter that injects custom property editors for lookup properties
 * based on document class and property configuration
 */
public class CNBCustomEditorResponseFilter extends PluginResponseFilter {

    public String[] getFilteredServices() {
        return new String[] { 
            "/p8/openContentClass",   // Default property definitions
            "/p8/openItem",            // Edit existing documents
            "/p8/getEntryTemplate",    // Entry templates with custom layouts
            "/p8/getContentClass"      // Alternative class retrieval
        };
    }

    public void filter(String serverType, PluginServiceCallbacks callbacks, 
                      HttpServletRequest request, JSONObject jsonResponse) throws Exception {
        
        String requestURI = request.getRequestURI();
        String desktopId = request.getParameter("desktop");
        String templateName = request.getParameter("template_name");
        
        System.out.println("[EDSResponseFilter] ========================================");
        System.out.println("[EDSResponseFilter] Service URI: " + requestURI);
        System.out.println("[EDSResponseFilter] Desktop: " + desktopId);
        System.out.println("[EDSResponseFilter] Document Class (template_name): " + templateName);
        
        // Get configuration manager
        LookupConfigManager configManager = LookupConfigManager.getInstance();
        
        // Check if this document class has custom editors configured
        if (!configManager.hasDocumentClass(templateName)) {
            System.out.println("[EDSResponseFilter] No configuration found for class: " + templateName);
            System.out.println("[EDSResponseFilter] Available classes: " + configManager.getAvailableDocumentClasses());
            return;
        }
        
        // Check if this desktop is allowed for this document class
        if (!configManager.isDesktopAllowed(templateName, desktopId)) {
            System.out.println("[EDSResponseFilter] Desktop '" + desktopId + "' is not configured for class: " + templateName);
            System.out.println("[EDSResponseFilter] Allowed desktops: " + configManager.getAllowedDesktops(templateName));
            return;
        }
        
        System.out.println("[EDSResponseFilter] âœ“ Desktop '" + desktopId + "' is allowed for class: " + templateName);
        
        JSONArray properties = (JSONArray) jsonResponse.get("criterias");
        
        if (properties == null) {
            System.out.println("[EDSResponseFilter] No properties (criterias) found in response");
            return;
        }
        
        System.out.println("[EDSResponseFilter] Total properties in response: " + properties.size());
        
        // Get all configured properties for this document class
        System.out.println("[EDSResponseFilter] Looking for configuration for document class: '" + templateName + "'");
        Map<String, JSONObject> classProperties = configManager.getDocumentClassProperties(templateName);
        
        if (classProperties.isEmpty()) {
            System.out.println("[EDSResponseFilter] No custom editors configured for class: " + templateName);
            System.out.println("[EDSResponseFilter] Available classes in config: " + configManager.getAvailableDocumentClasses());
            return;
        }
            
        System.out.println("[EDSResponseFilter] Found " + classProperties.size() + " custom editor(s) configured for class: " + templateName);
        
        // NOTE: Property manipulation (filtering, ordering, labels, descriptions, required) 
        // is now handled in JavaScript (CNBPropertyEditorEDSPlugin.js) to support 
        // entry template-specific configurations. This filter only handles custom editor assignment.
        
        // Process each property in the response to assign custom editors
        int assignedCount = 0;
        for (int i = 0; i < properties.size(); i++) {
            JSONObject jsonPropDef = (JSONObject) properties.get(i);
            String propertyName = (String) jsonPropDef.get("name");
            
            // Check if this property has a custom editor configured
            if (classProperties.containsKey(propertyName)) {
                JSONObject propertyConfig = classProperties.get(propertyName);
                String editorType = (String) propertyConfig.get("editorType");
                
                System.out.println("[EDSResponseFilter] Assigning custom editor to property: " + propertyName);
                System.out.println("[EDSResponseFilter] Editor type: " + editorType);
                
                // Always use InlineAutocompleteEditor (unified editor for all cases)
                jsonPropDef.put("propertyEditor", "cNBPropertyEditorEDSPluginDojo/InlineAutocompleteEditor");
                
                // Inline autocomplete is editable - users type to search
                jsonPropDef.remove("readOnly");
                
                // Embed the configuration for the editor to use
                jsonPropDef.put("lookupConfig", propertyConfig);
                
                System.out.println("[EDSResponseFilter] Successfully assigned InlineAutocompleteEditor to: " + propertyName);
                System.out.println("[EDSResponseFilter] Dependent fields for " + propertyName + " will remain editable");
                
                assignedCount++;
            }
        }
        
        System.out.println("[EDSResponseFilter] Successfully assigned " + assignedCount + " custom editor(s)");
        
        System.out.println("[EDSResponseFilter] ========================================");
    }
}




package com.cnb.eds.editor.config;

import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Manages lookup configuration for custom property editors
 * Loads and caches configuration from lookupConfig.json
 */
public class LookupConfigManager {
    
    private static LookupConfigManager instance;
    private JSONObject config;
    private Map<String, Map<String, JSONObject>> cache;
    
    private LookupConfigManager() {
        cache = new HashMap<String, Map<String, JSONObject>>();
        loadConfiguration();
    }
    
    /**
     * Get singleton instance
     */
    public static synchronized LookupConfigManager getInstance() {
        if (instance == null) {
            instance = new LookupConfigManager();
        }
        return instance;
    }
    
    /**
     * Load configuration from JSON file
     */
    private void loadConfiguration() {
        try {
            InputStream is = getClass().getResourceAsStream("/com/cnb/eds/editor/config/lookupConfig.json");
            if (is == null) {
                System.err.println("[LookupConfigManager] Configuration file not found!");
                config = new JSONObject();
                return;
            }
            config = JSONObject.parse(is);
            System.out.println("[LookupConfigManager] Configuration loaded successfully");
            
            // Log what was loaded for debugging
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses != null) {
                System.out.println("[LookupConfigManager] Loaded " + docClasses.size() + " document class(es):");
                for (Object key : docClasses.keySet()) {
                    System.out.println("[LookupConfigManager]   - " + key);
                }
            } else {
                System.err.println("[LookupConfigManager] WARNING: No documentClasses found in config!");
            }
            
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources != null) {
                System.out.println("[LookupConfigManager] Loaded " + dataSources.size() + " datasource(s):");
                for (Object key : dataSources.keySet()) {
                    System.out.println("[LookupConfigManager]   - " + key);
                }
            }
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error loading configuration: " + e.getMessage());
            e.printStackTrace();
            config = new JSONObject();
        }
    }
    
    /**
     * Get property configuration for a specific document class and property
     * 
     * @param documentClass The document class name (e.g., "Book")
     * @param propertyName The property name (e.g., "AccountNumber")
     * @return Property configuration JSON object, or null if not found
     */
    public JSONObject getPropertyConfig(String documentClass, String propertyName) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                System.out.println("[LookupConfigManager] No documentClasses found in config");
                return null;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                System.out.println("[LookupConfigManager] Document class not found: " + documentClass);
                return null;
            }
            
            JSONObject properties = (JSONObject) classConfig.get("properties");
            if (properties == null) {
                System.out.println("[LookupConfigManager] No properties found for class: " + documentClass);
                return null;
            }
            
            JSONObject propertyConfig = (JSONObject) properties.get(propertyName);
            if (propertyConfig == null) {
                System.out.println("[LookupConfigManager] Property not found: " + propertyName + " in class: " + documentClass);
                return null;
            }
            
            return propertyConfig;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting property config: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Check if a property has custom editor configured
     * 
     * @param documentClass The document class name
     * @param propertyName The property name
     * @return true if custom editor is configured, false otherwise
     */
    public boolean hasCustomEditor(String documentClass, String propertyName) {
        return getPropertyConfig(documentClass, propertyName) != null;
    }
    
    /**
     * Get all properties for a document class that have custom editors
     * 
     * @param documentClass The document class name
     * @return Map of property name to configuration
     */
    public Map<String, JSONObject> getDocumentClassProperties(String documentClass) {
        // Check cache first
        if (cache.containsKey(documentClass)) {
            return cache.get(documentClass);
        }
        
        Map<String, JSONObject> properties = new HashMap<String, JSONObject>();
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) return properties;
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) return properties;
            
            JSONObject propsConfig = (JSONObject) classConfig.get("properties");
            if (propsConfig == null) return properties;
            
            for (Object key : propsConfig.keySet()) {
                String propName = (String) key;
                properties.put(propName, (JSONObject) propsConfig.get(propName));
            }
            
            // Cache the result
            cache.put(documentClass, properties);
            
            System.out.println("[LookupConfigManager] Loaded " + properties.size() + " properties for class: " + documentClass);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting document class properties: " + e.getMessage());
            e.printStackTrace();
        }
        
        return properties;
    }
    
    /**
     * Reload configuration (useful for hot-reloading without restart)
     */
    public void reloadConfiguration() {
        cache.clear();
        loadConfiguration();
        System.out.println("[LookupConfigManager] Configuration reloaded");
    }
    
    /**
     * Get datasource configuration by name
     * 
     * @param dataSourceName Name of the datasource
     * @return Datasource configuration JSON object, or null if not found
     */
    public JSONObject getDataSourceConfig(String dataSourceName) {
        try {
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources == null) {
                System.err.println("[LookupConfigManager] No dataSources found in configuration");
                return null;
            }
            
            JSONObject dataSourceConfig = (JSONObject) dataSources.get(dataSourceName);
            if (dataSourceConfig == null) {
                System.err.println("[LookupConfigManager] Datasource not found: " + dataSourceName);
                return null;
            }
            
            return dataSourceConfig;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting datasource config: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Get all configured datasource names
     * 
     * @return Array of datasource names
     */
    public String[] getDataSourceNames() {
        try {
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources == null) {
                return new String[0];
            }
            
            return (String[]) dataSources.keySet().toArray(new String[0]);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting datasource names: " + e.getMessage());
            return new String[0];
        }
    }
    
    /**
     * Get all configured document class names (for debugging)
     * 
     * @return String representation of available document classes
     */
    public String getAvailableDocumentClasses() {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null || docClasses.isEmpty()) {
                return "[none]";
            }
            
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            int count = 0;
            for (Object key : docClasses.keySet()) {
                if (count > 0) sb.append(", ");
                sb.append("'").append(key).append("'");
                count++;
            }
            sb.append("]");
            return sb.toString();
        } catch (Exception e) {
            return "[error: " + e.getMessage() + "]";
        }
    }
    
    /**
     * Check if a document class exists in configuration
     * 
     * @param documentClass The document class name
     * @return true if document class is configured, false otherwise
     */
    public boolean hasDocumentClass(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return false;
            }
            return docClasses.containsKey(documentClass);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error checking document class: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Check if a desktop is allowed for a document class
     * 
     * @param documentClass The document class name
     * @param desktopId The desktop ID
     * @return true if desktop is allowed (or no desktop restriction configured), false otherwise
     */
    public boolean isDesktopAllowed(String documentClass, String desktopId) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return false;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return false;
            }
            
            // Check if desktops array is configured
            JSONArray desktops = (JSONArray) classConfig.get("desktops");
            
            // If no desktops configured, allow all desktops
            if (desktops == null || desktops.isEmpty()) {
                System.out.println("[LookupConfigManager] No desktop restrictions for class: " + documentClass);
                return true;
            }
            
            // Check if current desktop is in the allowed list
            for (int i = 0; i < desktops.size(); i++) {
                String allowedDesktop = (String) desktops.get(i);
                if (allowedDesktop != null && allowedDesktop.equals(desktopId)) {
                    return true;
                }
            }
            
            return false;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error checking desktop access: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Get list of allowed desktops for a document class
     * 
     * @param documentClass The document class name
     * @return String representation of allowed desktops
     */
    public String getAllowedDesktops(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return "[none]";
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return "[class not found]";
            }
            
            JSONArray desktops = (JSONArray) classConfig.get("desktops");
            if (desktops == null || desktops.isEmpty()) {
                return "[all desktops allowed]";
            }
            
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            for (int i = 0; i < desktops.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("'").append(desktops.get(i)).append("'");
            }
            sb.append("]");
            return sb.toString();
        } catch (Exception e) {
            return "[error: " + e.getMessage() + "]";
        }
    }
    
    /**
     * Get full configuration for client-side use
     * @return JSONObject containing documentClasses configuration (without datasource credentials)
     */
    public JSONObject getFullConfiguration() {
        try {
            JSONObject clientConfig = new JSONObject();
            
            // Only expose documentClasses to client (not datasource credentials for security)
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses != null) {
                clientConfig.put("documentClasses", docClasses);
            } else {
                clientConfig.put("documentClasses", new JSONObject());
            }
            
            System.out.println("[LookupConfigManager] Returning configuration with " + 
                             (docClasses != null ? docClasses.size() : 0) + " document classes");
            
            return clientConfig;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting full configuration: " + e.getMessage());
            e.printStackTrace();
            
            JSONObject errorConfig = new JSONObject();
            try {
                errorConfig.put("documentClasses", new JSONObject());
            } catch (Exception ex) {
                // Ignore
            }
            return errorConfig;
        }
    }
}

