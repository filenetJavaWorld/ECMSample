{
  "dataSources": {
    "RAMDB": {
      "type": "jndi",
      "jndiName": "jdbc/RAMDB"
    }
  },
  "documentClasses": {
    "VehicleRegistration": {
      "desktops": ["Automotive", "Admin"],
      "propertyDisplayOrder": ["RecordLookup", "VIN", "RegistrationNumber", "VehicleType", "FuelType", "RegistrationDate", "OwnerName"],
      "showProperties": ["RecordLookup", "VIN", "RegistrationNumber", "VehicleType", "FuelType", "RegistrationDate", "OwnerName"],
      "customLabelsAndDesc": {
      				"labels":{"RegistrationNumber":"Registration Number of the vehicle"},
      				"desc":{"RegistrationNumber":"Registration Number of the vehicle Desc"}
      },
      "requiredProperties": ["RegistrationNumber", "VehicleType", "FuelType"],
      "properties": {
        "RecordLookup": {
          "displayName": "Record Lookup",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "none",
          "allowClear": true,
          "allowEdit": true,
          "clearAfterSelection": true,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT TOP {limit} VIN, RegistrationNumber, RegistrationDate, OwnerName, VehicleType, FuelType FROM [RAMDB].[dbo].[VehicleInformation] WHERE VIN LIKE ? OR RegistrationNumber LIKE ? ORDER BY RegistrationNumber",
            "resultColumns": ["VIN", "RegistrationNumber", "RegistrationDate", "OwnerName", "VehicleType", "FuelType"],
            "filterColumns": ["VIN", "RegistrationNumber"],
            "searchPattern": "contains"
          },
          "displayColumns": {
            "VIN": "VIN",
            "RegistrationNumber": "Registration Number",
            "RegistrationDate": "Registration Date",
            "OwnerName": "Owner Name"
          },
          "fieldMappings": {
            "VIN": {
              "sourceAlias": "VIN",
              "targetProperty": "VIN",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "RegistrationNumber": {
              "sourceAlias": "RegistrationNumber",
              "targetProperty": "RegistrationNumber",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "RegistrationDate": {
              "sourceAlias": "RegistrationDate",
              "targetProperty": "RegistrationDate",
              "dataType": "xs:date",
              "cardinality": "SINGLE"
            },
            "OwnerName": {
              "sourceAlias": "OwnerName",
              "targetProperty": "OwnerName",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 2,
            "debounceDelay": 300,
            "placeholder": "Type VIN or Registration Number...",
            "limit": 1000
          }
        },
        "VehicleType": {
          "displayName": "Vehicle Type",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "top500",
          "allowClear": true,
          "allowEdit": false,
          "clearAfterSelection": false,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT DISTINCT TOP {limit} [VehicleType], [FuelType] FROM [RAMDB].[dbo].[VehicleInformation] ORDER BY VehicleType",
            "resultColumns": ["VehicleType", "FuelType"],
            "filterColumns": ["VehicleType"],
            "searchPattern": "startsWith"
          },
          "displayColumns": {
            "VehicleType": "Vehicle Type",
            "FuelType": "Fuel Type"
          },
          "fieldMappings": {
            "VehicleType": {
              "sourceAlias": "VehicleType",
              "targetProperty": "VehicleType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "FuelType": {
              "sourceAlias": "FuelType",
              "targetProperty": "FuelType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 0,
            "debounceDelay": 300,
            "placeholder": "Select Vehicle Type...",
            "limit": 500
          }
        }
      }
    },
    "CarModel": {
      "desktops": ["Automotive", "Admin"],
      "propertyDisplayOrder": ["RecordLookup", "ModelYear", "Manufacturer", "Model", "Variant", "EngineType", "Transmission"],
      "showProperties": ["RecordLookup", "ModelYear", "Manufacturer", "Model", "Variant", "EngineType", "Transmission"],
      "customLabelsAndDesc": {	
      					"labels":{"ModelYear":"Model Year of the vehicle"},
      					"desc":{"RegistrationNumber":"Registration Number of the vehicle Desc"}
      },
      "requiredProperties": ["Manufacturer", "Model", "Variant"],
      "properties": {
        "RecordLookup": {
          "displayName": "Record Lookup",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "none",
          "allowClear": true,
          "allowEdit": true,
          "clearAfterSelection": true,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT TOP {limit} [Model_Code], [Make], [Model_Name], [Year] FROM [RAMDB].[dbo].[VehicleModels] WHERE [Model_Name] LIKE ? ORDER BY [Model_Name]",
            "resultColumns": ["Model_Code", "Make", "Model_Name"],
            "filterColumns": ["Model_Name"],
            "searchPattern": "contains"
          },
          "displayColumns": {
            "Model_Code": "Model Code",
            "Make": "Make",
            "Model_Name": "Model Name"
          },
          "fieldMappings": {
            "Model_Code": {
              "sourceAlias": "Model_Code",
              "targetProperty": "ModelCode",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Make": {
              "sourceAlias": "Make",
              "targetProperty": "Make",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Model_Name": {
              "sourceAlias": "Model_Name",
              "targetProperty": "ModelName",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Year": {
              "sourceAlias": "Year",
              "targetProperty": "Year",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 2,
            "debounceDelay": 300,
            "placeholder": "Type Model Name...",
            "limit": 1000
          }
        },
        "EngineType": {
          "displayName": "Engine Type",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "top500",
          "allowClear": true,
          "allowEdit": false,
          "clearAfterSelection": false,
          "tooltipMessage": "Select from available engine types",
          "hasDependentProperties": false,
          "queryConfig": {
            "sql": "SELECT DISTINCT [Engine_Type] FROM [RAMDB].[dbo].[VehicleModels] ORDER BY [Engine_Type]",
            "resultColumns": ["Engine_Type"],
            "filterColumns": ["Engine_Type"],
            "searchPattern": "startsWith"
          },
          "displayColumns": {
            "Engine_Type": "Engine Type"
          },
          "fieldMappings": {
            "Engine_Type": {
              "sourceAlias": "Engine_Type",
              "targetProperty": "EngineType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 0,
            "debounceDelay": 0,
            "placeholder": "Select Engine Type...",
            "limit": 500
          }
        }
      }
    }
  }
}



require([
    "dojo/_base/declare",
         "dojo/_base/lang",
    "dojo/aspect",
    "ecm/model/Request",
    "cNBPropertyEditorEDSPluginDojo/InlineAutocompleteEditor"
], 
function(declare, lang, aspect, Request, InlineAutocompleteEditor) {
    
    console.log("[CNBPropertyEditorEDSPlugin] ====================================");
    console.log("[CNBPropertyEditorEDSPlugin] Initializing plugin...");
    
    var editorConfig = null;
    var configLoaded = false;
    var configLoading = false;
    
    /**
     * Load configuration from backend using ICN Request API
     */
    function loadConfiguration() {
        if (configLoaded || configLoading) {
            return;
        }
        
        configLoading = true;
        console.log("[CNBPropertyEditorEDSPlugin] Loading configuration from backend...");
        
        // Use ICN's Request.invokePluginService() - the correct way!
        Request.invokePluginService("CNBPropertyEditorEDSPlugin", "GetLookupConfigService", {
            requestParams: {},
            requestCompleteCallback: function(response) {
                console.log("[CNBPropertyEditorEDSPlugin] Service response:", response);
                
                editorConfig = response.documentClasses || {};
                configLoaded = true;
                configLoading = false;
                
                var classCount = Object.keys(editorConfig).length;
                console.log("[CNBPropertyEditorEDSPlugin] ✓ Configuration loaded successfully");
                console.log("[CNBPropertyEditorEDSPlugin] ✓ Loaded " + classCount + " document class(es):");
                
                for (var className in editorConfig) {
                    var propsCount = editorConfig[className].properties ? 
                                    Object.keys(editorConfig[className].properties).length : 0;
                    console.log("[CNBPropertyEditorEDSPlugin]   - " + className + " (" + propsCount + " properties)");
                }
            },
            requestFailedCallback: function(error) {
                console.error("[CNBPropertyEditorEDSPlugin] ✗ Failed to load configuration:", error);
                editorConfig = {};
                configLoaded = true;
                configLoading = false;
            }
        });
    }
    
    // Load configuration on plugin startup
    loadConfiguration();
    
    // ========================================================================
    // PROPERTY DISPLAY ORDER: Intercept CommonPropertiesPane.renderAttributes
    // to reorder properties according to configuration
    // ========================================================================
    require(["ecm/widget/CommonPropertiesPane"], function(CommonPropertiesPane) {
        try {
            console.log("[CNBPropertyEditorEDSPlugin] Setting up property display order interception...");
            
            aspect.around(CommonPropertiesPane.prototype, "renderAttributes", function(original) {
                return function(attributeDefinitions, item, reason, isReadOnly, params) {
                    console.log("[CNBPropertyEditorEDSPlugin] ========================================");
                    console.log("[CNBPropertyEditorEDSPlugin] >>> Intercepting renderAttributes");
                    console.log("[CNBPropertyEditorEDSPlugin] Reason:", reason);
                    console.log("[CNBPropertyEditorEDSPlugin] Number of properties:", attributeDefinitions ? attributeDefinitions.length : 0);
                    if (item != null && attributeDefinitions && attributeDefinitions.length > 0) {
                        console.log("[CNBPropertyEditorEDSPlugin] Item is not null - removing propertyEditor from all attributes");
                        var removedCount = 0;
                        
                        for (var i = 0; i < attributeDefinitions.length; i++) {
                            var attr = attributeDefinitions[i];
                            if (attr && attr.propertyEditor) {
                                console.log("[CNBPropertyEditorEDSPlugin]   ✗ Removing propertyEditor from: " + (attr.id || attr.name));
                                delete attr.propertyEditor;
                                removedCount++;
                            }
                        }
                        
                        console.log("[CNBPropertyEditorEDSPlugin] ✓ Removed propertyEditor from " + removedCount + " attribute(s)");
                        
                        var recordLookupIndex = -1;
                        for (var j = 0; j < attributeDefinitions.length; j++) {
                            var attrDef = attributeDefinitions[j];
                            var attrName = attrDef ? (attrDef.id || attrDef.name) : null;
                            if (attrName === "Record_Lookup") {
                                recordLookupIndex = j;
                                break;
                            }
                        }
                        
                        if (recordLookupIndex !== -1) {
                            console.log("[CNBPropertyEditorEDSPlugin]   ✗ Removing Record_lookup attribute definition from array");
                            attributeDefinitions.splice(recordLookupIndex, 1);
                            console.log("[CNBPropertyEditorEDSPlugin] ✓ Removed Record_lookup attribute definition");
                            console.log("[CNBPropertyEditorEDSPlugin]   Remaining properties: " + attributeDefinitions.length);
                        } else {
                            console.log("[CNBPropertyEditorEDSPlugin]   Record_lookup attribute definition not found");
                        }
                    }
                    
                    return original.call(this, attributeDefinitions, item, reason, isReadOnly, params);
                };
            });
            
            console.log("[CNBPropertyEditorEDSPlugin] ✓ Property display order interception set up successfully");
            
        } catch (e) {
            console.error("[CNBPropertyEditorEDSPlugin] Failed to set up property display order:", e);
        }
    });
    
    console.log("[CNBPropertyEditorEDSPlugin] Plugin initialized successfully");
    console.log("[CNBPropertyEditorEDSPlugin] ====================================");
});





package com.cnb.eds.editor.filters;

import javax.servlet.http.HttpServletRequest;

import com.cnb.eds.editor.config.LookupConfigManager;
import com.ibm.ecm.extension.PluginResponseFilter;
import com.ibm.ecm.extension.PluginServiceCallbacks;
import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;

/**
 * Response filter that injects custom property editors for lookup properties
 * based on document class and property configuration
 */
public class CNBCustomEditorResponseFilter extends PluginResponseFilter {

    public String[] getFilteredServices() {
        return new String[] { 
            "/p8/openContentClass",   // Default property definitions
            "/p8/openItem",            // Edit existing documents
            "/p8/getEntryTemplate",    // Entry templates with custom layouts
            "/p8/getContentClass"      // Alternative class retrieval
        };
    }

    public void filter(String serverType, PluginServiceCallbacks callbacks, 
                      HttpServletRequest request, JSONObject jsonResponse) throws Exception {
        
        String requestURI = request.getRequestURI();
        String desktopId = request.getParameter("desktop");
        String templateName = request.getParameter("template_name");
        
        System.out.println("[EDSResponseFilter] ========================================");
        System.out.println("[EDSResponseFilter] Service URI: " + requestURI);
        System.out.println("[EDSResponseFilter] Desktop: " + desktopId);
        System.out.println("[EDSResponseFilter] Document Class (template_name): " + templateName);
        
        // Get configuration manager
        LookupConfigManager configManager = LookupConfigManager.getInstance();
        
        // Check if this document class has custom editors configured
        if (!configManager.hasDocumentClass(templateName)) {
            System.out.println("[EDSResponseFilter] No configuration found for class: " + templateName);
            System.out.println("[EDSResponseFilter] Available classes: " + configManager.getAvailableDocumentClasses());
            return;
        }
        
        // Check if this desktop is allowed for this document class
        if (!configManager.isDesktopAllowed(templateName, desktopId)) {
            System.out.println("[EDSResponseFilter] Desktop '" + desktopId + "' is not configured for class: " + templateName);
            System.out.println("[EDSResponseFilter] Allowed desktops: " + configManager.getAllowedDesktops(templateName));
            return;
        }
        
        System.out.println("[EDSResponseFilter] âœ“ Desktop '" + desktopId + "' is allowed for class: " + templateName);
        
        JSONArray properties = (JSONArray) jsonResponse.get("criterias");
        
        if (properties == null) {
            System.out.println("[EDSResponseFilter] No properties (criterias) found in response");
            return;
        }
        
        System.out.println("[EDSResponseFilter] Total properties in response: " + properties.size());
        
        // Get all configured properties for this document class
        System.out.println("[EDSResponseFilter] Looking for configuration for document class: '" + templateName + "'");
        Map<String, JSONObject> classProperties = configManager.getDocumentClassProperties(templateName);
        
        if (classProperties.isEmpty()) {
            System.out.println("[EDSResponseFilter] No custom editors configured for class: " + templateName);
            System.out.println("[EDSResponseFilter] Available classes in config: " + configManager.getAvailableDocumentClasses());
            return;
        }
            
        System.out.println("[EDSResponseFilter] Found " + classProperties.size() + " custom editor(s) configured for class: " + templateName);
        
        // Get configuration for property filtering, ordering, labels, and required properties
        JSONArray showProperties = configManager.getShowProperties(templateName);
        JSONArray propertyDisplayOrder = configManager.getPropertyDisplayOrder(templateName);
        JSONArray requiredProperties = configManager.getRequiredProperties(templateName);
        JSONObject customLabelsConfig = configManager.getCustomLabels(templateName);
        JSONObject labelMappings = null;
        JSONObject descMappings = null;
        
        if (customLabelsConfig != null) {
            labelMappings = (JSONObject) customLabelsConfig.get("labels");
            descMappings = (JSONObject) customLabelsConfig.get("desc");
            
            if (labelMappings != null || descMappings != null) {
                System.out.println("[EDSResponseFilter] âœ“ Custom labels/descriptions configured for class: " + templateName);
                if (labelMappings != null) {
                    System.out.println("[EDSResponseFilter]   - " + labelMappings.size() + " label mapping(s)");
                }
                if (descMappings != null) {
                    System.out.println("[EDSResponseFilter]   - " + descMappings.size() + " description mapping(s)");
                }
            }
        }
        
        if (showProperties != null) {
            System.out.println("[EDSResponseFilter] âœ“ showProperties configured: " + showProperties.size() + " property(ies)");
        }
        
        if (propertyDisplayOrder != null) {
            System.out.println("[EDSResponseFilter] âœ“ propertyDisplayOrder configured: " + propertyDisplayOrder.size() + " property(ies)");
        }
        
        if (requiredProperties != null) {
            System.out.println("[EDSResponseFilter] âœ“ requiredProperties configured: " + requiredProperties.size() + " property(ies)");
        }
        
        // STEP 1: Filter properties based on showProperties (if configured)
        List<JSONObject> filteredProperties = new ArrayList<JSONObject>();
        if (showProperties != null && showProperties.size() > 0) {
            System.out.println("[EDSResponseFilter] Filtering properties based on showProperties...");
            System.out.println("[EDSResponseFilter]   Before filtering: " + properties.size() + " properties");
            
            // Create a set of allowed property names for quick lookup
            List<String> allowedProperties = new ArrayList<String>();
            for (int i = 0; i < showProperties.size(); i++) {
                allowedProperties.add((String) showProperties.get(i));
            }
            
            // Filter properties - only keep those in showProperties list
            for (int i = 0; i < properties.size(); i++) {
                JSONObject jsonPropDef = (JSONObject) properties.get(i);
                String propertyName = (String) jsonPropDef.get("name");
                
                if (allowedProperties.contains(propertyName)) {
                    filteredProperties.add(jsonPropDef);
                } else {
                    System.out.println("[EDSResponseFilter]   âœ— Hiding property: " + propertyName);
                }
            }
            
            System.out.println("[EDSResponseFilter]   After filtering: " + filteredProperties.size() + " properties");
        } else {
            // No filtering - keep all properties
            for (int i = 0; i < properties.size(); i++) {
                filteredProperties.add((JSONObject) properties.get(i));
            }
        }
        
        // STEP 2: Reorder properties based on propertyDisplayOrder (if configured)
        List<JSONObject> orderedProperties = new ArrayList<JSONObject>();
        if (propertyDisplayOrder != null && propertyDisplayOrder.size() > 0) {
            System.out.println("[EDSResponseFilter] Reordering properties based on propertyDisplayOrder...");
            
            // Create a map of property name to property object for quick lookup
            Map<String, JSONObject> propertyMap = new HashMap<String, JSONObject>();
            for (JSONObject prop : filteredProperties) {
                String propertyName = (String) prop.get("name");
                if (propertyName != null) {
                    propertyMap.put(propertyName, prop);
                }
            }
            
            // First, add properties in the specified order
            for (int i = 0; i < propertyDisplayOrder.size(); i++) {
                String propertyName = (String) propertyDisplayOrder.get(i);
                JSONObject prop = propertyMap.get(propertyName);
                if (prop != null) {
                    orderedProperties.add(prop);
                    propertyMap.remove(propertyName); // Remove from map so we don't add it twice
                    System.out.println("[EDSResponseFilter]   âœ“ Ordered property: " + propertyName);
                }
            }
            
            // Then, add any remaining properties not in the display order (at the end)
            for (JSONObject prop : filteredProperties) {
                String propertyName = (String) prop.get("name");
                if (propertyMap.containsKey(propertyName)) {
                    orderedProperties.add(prop);
                    System.out.println("[EDSResponseFilter]   + Added remaining property: " + propertyName);
                }
            }
            
            System.out.println("[EDSResponseFilter] âœ“ Properties reordered successfully");
            System.out.println("[EDSResponseFilter]   Final order: " + orderedProperties.size() + " properties");
        } else {
            // No reordering - keep filtered order
            orderedProperties = filteredProperties;
        }
        
        // STEP 3: Apply custom labels, descriptions, required properties, and custom editors
        int assignedCount = 0;
        int labelUpdateCount = 0;
        int requiredUpdateCount = 0;
        
        // Create a list of required property names for quick lookup
        List<String> requiredPropertyNames = new ArrayList<String>();
        if (requiredProperties != null && requiredProperties.size() > 0) {
            for (int k = 0; k < requiredProperties.size(); k++) {
                requiredPropertyNames.add((String) requiredProperties.get(k));
            }
        }
        
        for (int i = 0; i < orderedProperties.size(); i++) {
            JSONObject jsonPropDef = orderedProperties.get(i);
            String propertyName = (String) jsonPropDef.get("name");
            
            // Apply custom labels and descriptions (for ALL properties, not just custom editors)
            if (labelMappings != null || descMappings != null) {
                boolean updated = false;
                
                if (labelMappings != null && labelMappings.containsKey(propertyName)) {
                    String customLabel = (String) labelMappings.get(propertyName);
                    if (customLabel != null && !customLabel.isEmpty()) {
                        jsonPropDef.put("label", customLabel);
                        System.out.println("[EDSResponseFilter]   âœ“ Updated label for '" + propertyName + "': " + customLabel);
                        updated = true;
                    }
                }
                
                if (descMappings != null && descMappings.containsKey(propertyName)) {
                    String customDesc = (String) descMappings.get(propertyName);
                    if (customDesc != null && !customDesc.isEmpty()) {
                        jsonPropDef.put("description", customDesc);
                        System.out.println("[EDSResponseFilter]   âœ“ Updated description for '" + propertyName + "': " + customDesc);
                        updated = true;
                    }
                }
                
                if (updated) {
                    labelUpdateCount++;
                }
            }
            
            // Apply required property settings (for ALL properties)
            if (requiredProperties != null && requiredProperties.size() > 0) {
                boolean isRequired = requiredPropertyNames.contains(propertyName);
                
                // Set required attribute based on configuration
                // If property is in requiredProperties list, set to true; otherwise set to false
                jsonPropDef.put("required", isRequired);
                
                if (isRequired) {
                    System.out.println("[EDSResponseFilter]   âœ“ Set required=true for: " + propertyName);
                    requiredUpdateCount++;
                } else {
                    // Only log if it was previously required (to show we're clearing it)
                    Object existingRequired = jsonPropDef.get("required");
                    if (existingRequired != null && (existingRequired instanceof Boolean && ((Boolean) existingRequired).booleanValue())) {
                        System.out.println("[EDSResponseFilter]   âœ“ Set required=false for: " + propertyName + " (was previously required)");
                    }
                }
            }
            
            // Check if this property has a custom editor configured
            if (classProperties.containsKey(propertyName)) {
                JSONObject propertyConfig = classProperties.get(propertyName);
                String editorType = (String) propertyConfig.get("editorType");
                
                System.out.println("[EDSResponseFilter] Assigning custom editor to property: " + propertyName);
                System.out.println("[EDSResponseFilter] Editor type: " + editorType);
                
                // Always use InlineAutocompleteEditor (unified editor for all cases)
                jsonPropDef.put("propertyEditor", "cNBPropertyEditorEDSPluginDojo/InlineAutocompleteEditor");
                
                // Inline autocomplete is editable - users type to search
                jsonPropDef.remove("readOnly");
                
                // Embed the configuration for the editor to use
                jsonPropDef.put("lookupConfig", propertyConfig);
                
                System.out.println("[EDSResponseFilter] Successfully assigned InlineAutocompleteEditor to: " + propertyName);
                System.out.println("[EDSResponseFilter] Dependent fields for " + propertyName + " will remain editable");
                
                assignedCount++;
            }
        }
        
        // Replace the original properties array with the filtered and reordered one
        JSONArray finalProperties = new JSONArray();
        for (JSONObject prop : orderedProperties) {
            finalProperties.add(prop);
        }
        jsonResponse.put("criterias", finalProperties);
        
        System.out.println("[EDSResponseFilter] Successfully assigned " + assignedCount + " custom editor(s)");
        if (labelUpdateCount > 0) {
            System.out.println("[EDSResponseFilter] Successfully updated " + labelUpdateCount + " property label(s)/description(s)");
        }
        if (requiredUpdateCount > 0) {
            System.out.println("[EDSResponseFilter] Successfully set " + requiredUpdateCount + " property(ies) as required");
        }
        System.out.println("[EDSResponseFilter] Final property count: " + finalProperties.size());
        
        System.out.println("[EDSResponseFilter] ========================================");
    }
}




package com.cnb.eds.editor.config;

import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Manages lookup configuration for custom property editors
 * Loads and caches configuration from lookupConfig.json
 */
public class LookupConfigManager {
    
    private static LookupConfigManager instance;
    private JSONObject config;
    private Map<String, Map<String, JSONObject>> cache;
    
    private LookupConfigManager() {
        cache = new HashMap<String, Map<String, JSONObject>>();
        loadConfiguration();
    }
    
    /**
     * Get singleton instance
     */
    public static synchronized LookupConfigManager getInstance() {
        if (instance == null) {
            instance = new LookupConfigManager();
        }
        return instance;
    }
    
    /**
     * Load configuration from JSON file
     */
    private void loadConfiguration() {
        try {
            InputStream is = getClass().getResourceAsStream("/com/cnb/eds/editor/config/lookupConfig.json");
            if (is == null) {
                System.err.println("[LookupConfigManager] Configuration file not found!");
                config = new JSONObject();
                return;
            }
            config = JSONObject.parse(is);
            System.out.println("[LookupConfigManager] Configuration loaded successfully");
            
            // Log what was loaded for debugging
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses != null) {
                System.out.println("[LookupConfigManager] Loaded " + docClasses.size() + " document class(es):");
                for (Object key : docClasses.keySet()) {
                    System.out.println("[LookupConfigManager]   - " + key);
                }
            } else {
                System.err.println("[LookupConfigManager] WARNING: No documentClasses found in config!");
            }
            
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources != null) {
                System.out.println("[LookupConfigManager] Loaded " + dataSources.size() + " datasource(s):");
                for (Object key : dataSources.keySet()) {
                    System.out.println("[LookupConfigManager]   - " + key);
                }
            }
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error loading configuration: " + e.getMessage());
            e.printStackTrace();
            config = new JSONObject();
        }
    }
    
    /**
     * Get property configuration for a specific document class and property
     * 
     * @param documentClass The document class name (e.g., "Book")
     * @param propertyName The property name (e.g., "AccountNumber")
     * @return Property configuration JSON object, or null if not found
     */
    public JSONObject getPropertyConfig(String documentClass, String propertyName) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                System.out.println("[LookupConfigManager] No documentClasses found in config");
                return null;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                System.out.println("[LookupConfigManager] Document class not found: " + documentClass);
                return null;
            }
            
            JSONObject properties = (JSONObject) classConfig.get("properties");
            if (properties == null) {
                System.out.println("[LookupConfigManager] No properties found for class: " + documentClass);
                return null;
            }
            
            JSONObject propertyConfig = (JSONObject) properties.get(propertyName);
            if (propertyConfig == null) {
                System.out.println("[LookupConfigManager] Property not found: " + propertyName + " in class: " + documentClass);
                return null;
            }
            
            return propertyConfig;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting property config: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Check if a property has custom editor configured
     * 
     * @param documentClass The document class name
     * @param propertyName The property name
     * @return true if custom editor is configured, false otherwise
     */
    public boolean hasCustomEditor(String documentClass, String propertyName) {
        return getPropertyConfig(documentClass, propertyName) != null;
    }
    
    /**
     * Get all properties for a document class that have custom editors
     * 
     * @param documentClass The document class name
     * @return Map of property name to configuration
     */
    public Map<String, JSONObject> getDocumentClassProperties(String documentClass) {
        // Check cache first
        if (cache.containsKey(documentClass)) {
            return cache.get(documentClass);
        }
        
        Map<String, JSONObject> properties = new HashMap<String, JSONObject>();
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) return properties;
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) return properties;
            
            JSONObject propsConfig = (JSONObject) classConfig.get("properties");
            if (propsConfig == null) return properties;
            
            for (Object key : propsConfig.keySet()) {
                String propName = (String) key;
                properties.put(propName, (JSONObject) propsConfig.get(propName));
            }
            
            // Cache the result
            cache.put(documentClass, properties);
            
            System.out.println("[LookupConfigManager] Loaded " + properties.size() + " properties for class: " + documentClass);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting document class properties: " + e.getMessage());
            e.printStackTrace();
        }
        
        return properties;
    }
    
    /**
     * Reload configuration (useful for hot-reloading without restart)
     */
    public void reloadConfiguration() {
        cache.clear();
        loadConfiguration();
        System.out.println("[LookupConfigManager] Configuration reloaded");
    }
    
    /**
     * Get datasource configuration by name
     * 
     * @param dataSourceName Name of the datasource
     * @return Datasource configuration JSON object, or null if not found
     */
    public JSONObject getDataSourceConfig(String dataSourceName) {
        try {
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources == null) {
                System.err.println("[LookupConfigManager] No dataSources found in configuration");
                return null;
            }
            
            JSONObject dataSourceConfig = (JSONObject) dataSources.get(dataSourceName);
            if (dataSourceConfig == null) {
                System.err.println("[LookupConfigManager] Datasource not found: " + dataSourceName);
                return null;
            }
            
            return dataSourceConfig;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting datasource config: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Get all configured datasource names
     * 
     * @return Array of datasource names
     */
    public String[] getDataSourceNames() {
        try {
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources == null) {
                return new String[0];
            }
            
            return (String[]) dataSources.keySet().toArray(new String[0]);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting datasource names: " + e.getMessage());
            return new String[0];
        }
    }
    
    /**
     * Get all configured document class names (for debugging)
     * 
     * @return String representation of available document classes
     */
    public String getAvailableDocumentClasses() {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null || docClasses.isEmpty()) {
                return "[none]";
            }
            
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            int count = 0;
            for (Object key : docClasses.keySet()) {
                if (count > 0) sb.append(", ");
                sb.append("'").append(key).append("'");
                count++;
            }
            sb.append("]");
            return sb.toString();
        } catch (Exception e) {
            return "[error: " + e.getMessage() + "]";
        }
    }
    
    /**
     * Check if a document class exists in configuration
     * 
     * @param documentClass The document class name
     * @return true if document class is configured, false otherwise
     */
    public boolean hasDocumentClass(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return false;
            }
            return docClasses.containsKey(documentClass);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error checking document class: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Check if a desktop is allowed for a document class
     * 
     * @param documentClass The document class name
     * @param desktopId The desktop ID
     * @return true if desktop is allowed (or no desktop restriction configured), false otherwise
     */
    public boolean isDesktopAllowed(String documentClass, String desktopId) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return false;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return false;
            }
            
            // Check if desktops array is configured
            JSONArray desktops = (JSONArray) classConfig.get("desktops");
            
            // If no desktops configured, allow all desktops
            if (desktops == null || desktops.isEmpty()) {
                System.out.println("[LookupConfigManager] No desktop restrictions for class: " + documentClass);
                return true;
            }
            
            // Check if current desktop is in the allowed list
            for (int i = 0; i < desktops.size(); i++) {
                String allowedDesktop = (String) desktops.get(i);
                if (allowedDesktop != null && allowedDesktop.equals(desktopId)) {
                    return true;
                }
            }
            
            return false;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error checking desktop access: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Get list of allowed desktops for a document class
     * 
     * @param documentClass The document class name
     * @return String representation of allowed desktops
     */
    public String getAllowedDesktops(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return "[none]";
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return "[class not found]";
            }
            
            JSONArray desktops = (JSONArray) classConfig.get("desktops");
            if (desktops == null || desktops.isEmpty()) {
                return "[all desktops allowed]";
            }
            
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            for (int i = 0; i < desktops.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("'").append(desktops.get(i)).append("'");
            }
            sb.append("]");
            return sb.toString();
        } catch (Exception e) {
            return "[error: " + e.getMessage() + "]";
        }
    }
    
    /**
     * Get custom labels configuration for a document class
     * Supports "customLabelsAndDesc", "customLabels", and "customLabelAndDescMapping" keys for backward compatibility
     * 
     * @param documentClass The document class name
     * @return JSONObject with "labels" and "desc" mappings, or null if not configured
     */
    public JSONObject getCustomLabels(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return null;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return null;
            }
            
            // Try "customLabelsAndDesc" first (current config format)
            JSONObject customLabelsAndDesc = (JSONObject) classConfig.get("customLabelsAndDesc");
            if (customLabelsAndDesc != null) {
                System.out.println("[LookupConfigManager] Found customLabelsAndDesc for class: " + documentClass);
                return customLabelsAndDesc;
            }
            
            // Try "customLabels" for backward compatibility
            JSONObject customLabels = (JSONObject) classConfig.get("customLabels");
            if (customLabels != null) {
                System.out.println("[LookupConfigManager] Found customLabels for class: " + documentClass);
                return customLabels;
            }
            
            // Try "customLabelAndDescMapping" for backward compatibility (old JavaScript format)
            JSONObject customLabelAndDescMapping = (JSONObject) classConfig.get("customLabelAndDescMapping");
            if (customLabelAndDescMapping != null) {
                System.out.println("[LookupConfigManager] Found customLabelAndDescMapping for class: " + documentClass);
                return customLabelAndDescMapping;
            }
            
            return null;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting custom labels: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Get requiredProperties array for a document class
     * Defines which properties should be marked as required
     * 
     * @param documentClass The document class name
     * @return JSONArray of property names that should be required, or null if not configured
     */
    public JSONArray getRequiredProperties(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return null;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return null;
            }
            
            JSONArray requiredProperties = (JSONArray) classConfig.get("requiredProperties");
            if (requiredProperties != null && requiredProperties.size() > 0) {
                System.out.println("[LookupConfigManager] Found requiredProperties for class: " + documentClass + " (" + requiredProperties.size() + " properties)");
                return requiredProperties;
            }
            
            return null;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting requiredProperties: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Get showProperties array for a document class
     * Defines which properties should be visible (all others will be hidden)
     * 
     * @param documentClass The document class name
     * @return JSONArray of property names to show, or null if not configured
     */
    public JSONArray getShowProperties(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return null;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return null;
            }
            
            JSONArray showProperties = (JSONArray) classConfig.get("showProperties");
            if (showProperties != null && showProperties.size() > 0) {
                System.out.println("[LookupConfigManager] Found showProperties for class: " + documentClass + " (" + showProperties.size() + " properties)");
                return showProperties;
            }
            
            return null;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting showProperties: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Get propertyDisplayOrder array for a document class
     * Defines the order in which properties should be displayed
     * 
     * @param documentClass The document class name
     * @return JSONArray of property names in display order, or null if not configured
     */
    public JSONArray getPropertyDisplayOrder(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return null;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return null;
            }
            
            JSONArray propertyDisplayOrder = (JSONArray) classConfig.get("propertyDisplayOrder");
            if (propertyDisplayOrder != null && propertyDisplayOrder.size() > 0) {
                System.out.println("[LookupConfigManager] Found propertyDisplayOrder for class: " + documentClass + " (" + propertyDisplayOrder.size() + " properties)");
                return propertyDisplayOrder;
            }
            
            return null;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting propertyDisplayOrder: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Get full configuration for client-side use
     * @return JSONObject containing documentClasses configuration (without datasource credentials)
     */
    public JSONObject getFullConfiguration() {
        try {
            JSONObject clientConfig = new JSONObject();
            
            // Only expose documentClasses to client (not datasource credentials for security)
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses != null) {
                clientConfig.put("documentClasses", docClasses);
            } else {
                clientConfig.put("documentClasses", new JSONObject());
            }
            
            System.out.println("[LookupConfigManager] Returning configuration with " + 
                             (docClasses != null ? docClasses.size() : 0) + " document classes");
            
            return clientConfig;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting full configuration: " + e.getMessage());
            e.printStackTrace();
            
            JSONObject errorConfig = new JSONObject();
            try {
                errorConfig.put("documentClasses", new JSONObject());
            } catch (Exception ex) {
                // Ignore
            }
            return errorConfig;
        }
    }
}





