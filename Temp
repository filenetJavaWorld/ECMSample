
package com.cnb.eds.editor;

import java.util.Locale;

import javax.servlet.http.HttpServletRequest;

import com.ibm.ecm.extension.Plugin;
import com.ibm.ecm.extension.PluginAction;
import com.ibm.ecm.extension.PluginFeature;
import com.ibm.ecm.extension.PluginLayout;
import com.ibm.ecm.extension.PluginMenu;
import com.ibm.ecm.extension.PluginMenuType;
import com.ibm.ecm.extension.PluginODAuthenticationService;
import com.ibm.ecm.extension.PluginOpenAction;
import com.ibm.ecm.extension.PluginRequestFilter;
import com.ibm.ecm.extension.PluginResponseFilter;
import com.ibm.ecm.extension.PluginService;
import com.ibm.ecm.extension.PluginServiceCallbacks;
import com.ibm.ecm.extension.PluginViewerDef;
import com.ibm.ecm.extension.PluginRepositoryType;
import com.ibm.ecm.extension.PluginAPI;

public class SAMPLEPropertyEditorEDSPlugin extends Plugin {

	private PluginAction[] pluginActions = new PluginAction[0];
	private PluginOpenAction[]  pluginOpenActions = new PluginOpenAction[0];
	private PluginRequestFilter[] pluginRequestFilters = new PluginRequestFilter[0];
	private PluginResponseFilter[] pluginResponseFilters = new PluginResponseFilter[0];
	private PluginService[] pluginServices = new PluginService[0];
	private PluginODAuthenticationService odAuthenticationService = null;
	private PluginViewerDef[] pluginViewerDefs = new PluginViewerDef[0];
	private PluginLayout[] pluginLayouts = new PluginLayout[0];
	private PluginFeature[] pluginFeatures = new PluginFeature[0];
	private PluginMenuType[] pluginMenuTypes = new PluginMenuType[0];
	private PluginMenu[] pluginMenus = new PluginMenu[0];
	private PluginRepositoryType[] pluginRepositoryTypes = new PluginRepositoryType[0];
	private PluginAPI[] pluginAPIs = new PluginAPI[0];

	public void applicationInit(HttpServletRequest request, PluginServiceCallbacks callbacks) throws Exception {
	}

	public String getId() {
		return "SAMPLEPropertyEditorEDSPlugin";
	}

	public String getName(Locale locale) {
		return "SAMPLE Custom Property Editor EDS Plugin";
	}

	public String getVersion() {
		return "1.0.0";
	}

	public String getCopyright() {
		return "Optionally add a Copyright statement here";
	}

	public String getScript() {
		return "SAMPLEPropertyEditorEDSPlugin.js";
	}

	public String getDebugScript() {
		return getScript();
	}

	public String getDojoModule() {
		return "cNBPropertyEditorEDSPluginDojo";
	}

	public String getCSSFileName() {
		return "SAMPLEPropertyEditorEDSPlugin.css";
	}

	public String getDebugCSSFileName() {
		return getCSSFileName();
	}
		
	public String getConfigurationDijitClass() {
		return "cNBPropertyEditorEDSPluginDojo.ConfigurationPane";
	}

	public PluginAction[] getActions() {
		return pluginActions;
	}

	public PluginOpenAction[] getOpenActions() {
		return pluginOpenActions;
	}

	public PluginRequestFilter[] getRequestFilters() {
		return pluginRequestFilters;
	}

	public PluginResponseFilter[] getResponseFilters() {
		if (pluginResponseFilters.length == 0) {
			pluginResponseFilters = new PluginResponseFilter[] {
				new com.cnb.eds.editor.filters.SAMPLECustomEditorResponseFilter()
			};
		}
		return pluginResponseFilters;
	}

	public PluginService[] getServices() {
		if (pluginServices.length == 0) {
			pluginServices = new PluginService[] {
				new com.cnb.eds.editor.service.CustomEditorGenericLookupService()
			};
		}
		return pluginServices;
	}

	public PluginODAuthenticationService getODAuthenticationService() {
		return odAuthenticationService;
	}

	public PluginViewerDef[] getViewers() {
		return pluginViewerDefs;
	}

	public PluginLayout[] getLayouts() {
		return pluginLayouts;
	}

	public PluginFeature[] getFeatures() {
		return pluginFeatures;
	}

	public PluginMenuType[] getMenuTypes() {
		return pluginMenuTypes;
	}

	public PluginMenu[] getMenus() {
		return pluginMenus;
	}
	
	 public PluginRepositoryType[] getRepositoryTypes() {
	 	 return pluginRepositoryTypes;
	 }
	 
	 public PluginAPI[] getPluginAPIs() {
	 	 return pluginAPIs;
	 }
}


==========

package com.cnb.eds.editor.config;

import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Manages lookup configuration for custom property editors
 * Loads and caches configuration from lookupConfig.json
 */
public class LookupConfigManager {
    
    private static LookupConfigManager instance;
    private JSONObject config;
    private Map<String, Map<String, JSONObject>> cache;
    
    private LookupConfigManager() {
        cache = new HashMap<String, Map<String, JSONObject>>();
        loadConfiguration();
    }
    
    /**
     * Get singleton instance
     */
    public static synchronized LookupConfigManager getInstance() {
        if (instance == null) {
            instance = new LookupConfigManager();
        }
        return instance;
    }
    
    /**
     * Load configuration from JSON file
     */
    private void loadConfiguration() {
        try {
            InputStream is = getClass().getResourceAsStream("/com/cnb/eds/editor/config/lookupConfig.json");
            if (is == null) {
                System.err.println("[LookupConfigManager] Configuration file not found!");
                config = new JSONObject();
                return;
            }
            config = JSONObject.parse(is);
            System.out.println("[LookupConfigManager] Configuration loaded successfully");
            
            // Log what was loaded for debugging
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses != null) {
                System.out.println("[LookupConfigManager] Loaded " + docClasses.size() + " document class(es):");
                for (Object key : docClasses.keySet()) {
                    System.out.println("[LookupConfigManager]   - " + key);
                }
            } else {
                System.err.println("[LookupConfigManager] WARNING: No documentClasses found in config!");
            }
            
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources != null) {
                System.out.println("[LookupConfigManager] Loaded " + dataSources.size() + " datasource(s):");
                for (Object key : dataSources.keySet()) {
                    System.out.println("[LookupConfigManager]   - " + key);
                }
            }
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error loading configuration: " + e.getMessage());
            e.printStackTrace();
            config = new JSONObject();
        }
    }
    
    /**
     * Get property configuration for a specific document class and property
     * 
     * @param documentClass The document class name (e.g., "Book")
     * @param propertyName The property name (e.g., "AccountNumber")
     * @return Property configuration JSON object, or null if not found
     */
    public JSONObject getPropertyConfig(String documentClass, String propertyName) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                System.out.println("[LookupConfigManager] No documentClasses found in config");
                return null;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                System.out.println("[LookupConfigManager] Document class not found: " + documentClass);
                return null;
            }
            
            JSONObject properties = (JSONObject) classConfig.get("properties");
            if (properties == null) {
                System.out.println("[LookupConfigManager] No properties found for class: " + documentClass);
                return null;
            }
            
            JSONObject propertyConfig = (JSONObject) properties.get(propertyName);
            if (propertyConfig == null) {
                System.out.println("[LookupConfigManager] Property not found: " + propertyName + " in class: " + documentClass);
                return null;
            }
            
            return propertyConfig;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting property config: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Check if a property has custom editor configured
     * 
     * @param documentClass The document class name
     * @param propertyName The property name
     * @return true if custom editor is configured, false otherwise
     */
    public boolean hasCustomEditor(String documentClass, String propertyName) {
        return getPropertyConfig(documentClass, propertyName) != null;
    }
    
    /**
     * Get all properties for a document class that have custom editors
     * 
     * @param documentClass The document class name
     * @return Map of property name to configuration
     */
    public Map<String, JSONObject> getDocumentClassProperties(String documentClass) {
        // Check cache first
        if (cache.containsKey(documentClass)) {
            return cache.get(documentClass);
        }
        
        Map<String, JSONObject> properties = new HashMap<String, JSONObject>();
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) return properties;
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) return properties;
            
            JSONObject propsConfig = (JSONObject) classConfig.get("properties");
            if (propsConfig == null) return properties;
            
            for (Object key : propsConfig.keySet()) {
                String propName = (String) key;
                properties.put(propName, (JSONObject) propsConfig.get(propName));
            }
            
            // Cache the result
            cache.put(documentClass, properties);
            
            System.out.println("[LookupConfigManager] Loaded " + properties.size() + " properties for class: " + documentClass);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting document class properties: " + e.getMessage());
            e.printStackTrace();
        }
        
        return properties;
    }
    
    /**
     * Reload configuration (useful for hot-reloading without restart)
     */
    public void reloadConfiguration() {
        cache.clear();
        loadConfiguration();
        System.out.println("[LookupConfigManager] Configuration reloaded");
    }
    
    /**
     * Get datasource configuration by name
     * 
     * @param dataSourceName Name of the datasource
     * @return Datasource configuration JSON object, or null if not found
     */
    public JSONObject getDataSourceConfig(String dataSourceName) {
        try {
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources == null) {
                System.err.println("[LookupConfigManager] No dataSources found in configuration");
                return null;
            }
            
            JSONObject dataSourceConfig = (JSONObject) dataSources.get(dataSourceName);
            if (dataSourceConfig == null) {
                System.err.println("[LookupConfigManager] Datasource not found: " + dataSourceName);
                return null;
            }
            
            return dataSourceConfig;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting datasource config: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
    
    /**
     * Get all configured datasource names
     * 
     * @return Array of datasource names
     */
    public String[] getDataSourceNames() {
        try {
            JSONObject dataSources = (JSONObject) config.get("dataSources");
            if (dataSources == null) {
                return new String[0];
            }
            
            return (String[]) dataSources.keySet().toArray(new String[0]);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error getting datasource names: " + e.getMessage());
            return new String[0];
        }
    }
    
    /**
     * Get all configured document class names (for debugging)
     * 
     * @return String representation of available document classes
     */
    public String getAvailableDocumentClasses() {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null || docClasses.isEmpty()) {
                return "[none]";
            }
            
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            int count = 0;
            for (Object key : docClasses.keySet()) {
                if (count > 0) sb.append(", ");
                sb.append("'").append(key).append("'");
                count++;
            }
            sb.append("]");
            return sb.toString();
        } catch (Exception e) {
            return "[error: " + e.getMessage() + "]";
        }
    }
    
    /**
     * Check if a document class exists in configuration
     * 
     * @param documentClass The document class name
     * @return true if document class is configured, false otherwise
     */
    public boolean hasDocumentClass(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return false;
            }
            return docClasses.containsKey(documentClass);
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error checking document class: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Check if a desktop is allowed for a document class
     * 
     * @param documentClass The document class name
     * @param desktopId The desktop ID
     * @return true if desktop is allowed (or no desktop restriction configured), false otherwise
     */
    public boolean isDesktopAllowed(String documentClass, String desktopId) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return false;
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return false;
            }
            
            // Check if desktops array is configured
            JSONArray desktops = (JSONArray) classConfig.get("desktops");
            
            // If no desktops configured, allow all desktops
            if (desktops == null || desktops.isEmpty()) {
                System.out.println("[LookupConfigManager] No desktop restrictions for class: " + documentClass);
                return true;
            }
            
            // Check if current desktop is in the allowed list
            for (int i = 0; i < desktops.size(); i++) {
                String allowedDesktop = (String) desktops.get(i);
                if (allowedDesktop != null && allowedDesktop.equals(desktopId)) {
                    return true;
                }
            }
            
            return false;
        } catch (Exception e) {
            System.err.println("[LookupConfigManager] Error checking desktop access: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Get list of allowed desktops for a document class
     * 
     * @param documentClass The document class name
     * @return String representation of allowed desktops
     */
    public String getAllowedDesktops(String documentClass) {
        try {
            JSONObject docClasses = (JSONObject) config.get("documentClasses");
            if (docClasses == null) {
                return "[none]";
            }
            
            JSONObject classConfig = (JSONObject) docClasses.get(documentClass);
            if (classConfig == null) {
                return "[class not found]";
            }
            
            JSONArray desktops = (JSONArray) classConfig.get("desktops");
            if (desktops == null || desktops.isEmpty()) {
                return "[all desktops allowed]";
            }
            
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            for (int i = 0; i < desktops.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("'").append(desktops.get(i)).append("'");
            }
            sb.append("]");
            return sb.toString();
        } catch (Exception e) {
            return "[error: " + e.getMessage() + "]";
        }
    }
}

=======
{
  "dataSources": {
    "RAMDB": {
      "type": "jndi",
      "jndiName": "jdbc/RAMDB"
    }
  },
  "documentClasses": {
    "VehicleRegistration": {
      "desktops": ["Automotive", "Admin"],
      "properties": {
        "RecordLookup": {
          "displayName": "Record Lookup",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "none",
          "allowClear": true,
          "allowEdit": true,
          "clearAfterSelection": true,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT TOP {limit} VIN, RegistrationNumber, RegistrationDate, OwnerName, VehicleType, FuelType FROM [RAMDB].[dbo].[VehicleInformation] WHERE VIN LIKE ? OR RegistrationNumber LIKE ? ORDER BY RegistrationNumber",
            "resultColumns": ["VIN", "RegistrationNumber", "RegistrationDate", "OwnerName", "VehicleType", "FuelType"],
            "filterColumns": ["VIN", "RegistrationNumber"],
            "searchPattern": "contains"
          },
          "displayColumns": {
            "VIN": "VIN",
            "RegistrationNumber": "Registration Number",
            "RegistrationDate": "Registration Date",
            "OwnerName": "Owner Name"
          },
          "fieldMappings": {
            "VIN": {
              "sourceAlias": "VIN",
              "targetProperty": "VIN",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "RegistrationNumber": {
              "sourceAlias": "RegistrationNumber",
              "targetProperty": "RegistrationNumber",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "RegistrationDate": {
              "sourceAlias": "RegistrationDate",
              "targetProperty": "RegistrationDate",
              "dataType": "xs:date",
              "cardinality": "SINGLE"
            },
            "OwnerName": {
              "sourceAlias": "OwnerName",
              "targetProperty": "OwnerName",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 2,
            "debounceDelay": 300,
            "placeholder": "Type VIN or Registration Number...",
            "limit": 1000
          }
        },
        "VehicleType": {
          "displayName": "Vehicle Type",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "top500",
          "allowClear": true,
          "allowEdit": false,
          "clearAfterSelection": false,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT DISTINCT TOP {limit} [VehicleType], [FuelType] FROM [RAMDB].[dbo].[VehicleInformation] ORDER BY VehicleType",
            "resultColumns": ["VehicleType", "FuelType"],
            "filterColumns": ["VehicleType"],
            "searchPattern": "startsWith"
          },
          "displayColumns": {
            "VehicleType": "Vehicle Type",
            "FuelType": "Fuel Type"
          },
          "fieldMappings": {
            "VehicleType": {
              "sourceAlias": "VehicleType",
              "targetProperty": "VehicleType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "FuelType": {
              "sourceAlias": "FuelType",
              "targetProperty": "FuelType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 0,
            "debounceDelay": 300,
            "placeholder": "Select Vehicle Type...",
            "limit": 500
          }
        }
      }
    },
    "CarModel": {
      "desktops": ["Automotive", "Admin"],
      "properties": {
        "RecordLookup": {
          "displayName": "Record Lookup",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "none",
          "allowClear": true,
          "allowEdit": true,
          "clearAfterSelection": true,
          "tooltipMessage": "auto",
          "hasDependentProperties": true,
          "queryConfig": {
            "sql": "SELECT TOP {limit} [Model_Code], [Make], [Model_Name], [Year] FROM [RAMDB].[dbo].[VehicleModels] WHERE [Model_Name] LIKE ? ORDER BY [Model_Name]",
            "resultColumns": ["Model_Code", "Make", "Model_Name"],
            "filterColumns": ["Model_Name"],
            "searchPattern": "contains"
          },
          "displayColumns": {
            "Model_Code": "Model Code",
            "Make": "Make",
            "Model_Name": "Model Name"
          },
          "fieldMappings": {
            "Model_Code": {
              "sourceAlias": "Model_Code",
              "targetProperty": "ModelCode",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Make": {
              "sourceAlias": "Make",
              "targetProperty": "Make",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Model_Name": {
              "sourceAlias": "Model_Name",
              "targetProperty": "ModelName",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            },
            "Year": {
              "sourceAlias": "Year",
              "targetProperty": "Year",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 2,
            "debounceDelay": 300,
            "placeholder": "Type Model Name...",
            "limit": 1000
          }
        },
        "EngineType": {
          "displayName": "Engine Type",
          "editorType": "inlineAutocomplete",
          "serviceName": "CustomEditorGenericLookupService",
          "dataSource": "RAMDB",
          "preloadMode": "top500",
          "allowClear": true,
          "allowEdit": false,
          "clearAfterSelection": false,
          "tooltipMessage": "Select from available engine types",
          "hasDependentProperties": false,
          "queryConfig": {
            "sql": "SELECT DISTINCT [Engine_Type] FROM [RAMDB].[dbo].[VehicleModels] ORDER BY [Engine_Type]",
            "resultColumns": ["Engine_Type"],
            "filterColumns": ["Engine_Type"],
            "searchPattern": "startsWith"
          },
          "displayColumns": {
            "Engine_Type": "Engine Type"
          },
          "fieldMappings": {
            "Engine_Type": {
              "sourceAlias": "Engine_Type",
              "targetProperty": "EngineType",
              "dataType": "xs:string",
              "cardinality": "SINGLE"
            }
          },
          "searchConfig": {
            "minLength": 0,
            "debounceDelay": 0,
            "placeholder": "Select Engine Type...",
            "limit": 500
          }
        }
      }
    }
  }
}

============
package com.cnb.eds.editor.connection;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import com.ibm.json.java.JSONObject;
import com.cnb.eds.editor.config.LookupConfigManager;

/**
 * Manages database connections for lookup queries
 * Supports multiple datasources configured in lookupConfig.json
 */
public class ConnectionManager {
	
	// Legacy connections for backward compatibility
	static Connection sql_server_dbConnection = null;
	static Connection oracle_dbConnection = null;
	
	// Connection pool for multiple datasources
	private static Map<String, Connection> connectionPool = new HashMap<String, Connection>();
	
	
	
	/**
	 * Get database connection by datasource name from configuration
	 * 
	 * @param dataSourceName Name of datasource from lookupConfig.json
	 * @return Connection object
	 * @throws Exception if connection fails
	 */
	public static Connection getConnectionByDataSource(String dataSourceName) throws Exception {
		System.out.println("[ConnectionManager] Requesting connection for datasource: " + dataSourceName);
		
		// Check if we already have a connection for this datasource
		if (connectionPool.containsKey(dataSourceName)) {
			Connection conn = connectionPool.get(dataSourceName);
			try {
				if (conn != null && !conn.isClosed()) {
					System.out.println("[ConnectionManager] Reusing existing connection for: " + dataSourceName);
					return conn;
				} else {
					// Connection is closed, remove from pool
					connectionPool.remove(dataSourceName);
				}
			} catch (SQLException e) {
				System.err.println("[ConnectionManager] Error checking connection state: " + e.getMessage());
				connectionPool.remove(dataSourceName);
			}
		}
		
		// Load datasource configuration
		LookupConfigManager configManager = LookupConfigManager.getInstance();
		JSONObject dataSourceConfig = configManager.getDataSourceConfig(dataSourceName);
		
		if (dataSourceConfig == null) {
			throw new Exception("Datasource not found in configuration: " + dataSourceName);
		}
		
		String type = (String) dataSourceConfig.get("type");
		
		if (type == null) {
			throw new Exception("Datasource type not specified for: " + dataSourceName);
		}
		
		Connection conn = null;
		
		if ("direct".equalsIgnoreCase(type)) {
			// Direct connection
			conn = getDirectConnection(dataSourceName, dataSourceConfig);
		} else if ("jndi".equalsIgnoreCase(type)) {
			// JNDI datasource
			conn = getJNDIConnection(dataSourceName, dataSourceConfig);
		} else {
			throw new Exception("Unknown datasource type: " + type);
		}
		
		// Cache the connection
		if (conn != null) {
			connectionPool.put(dataSourceName, conn);
			System.out.println("[ConnectionManager] Connection established and cached for: " + dataSourceName);
		}
		
		return conn;
	}
	
	/**
	 * Get direct database connection
	 * 
	 * @param dataSourceName Name of datasource
	 * @param config Datasource configuration
	 * @return Connection object
	 * @throws Exception if connection fails
	 */
	private static Connection getDirectConnection(String dataSourceName, JSONObject config) throws Exception {
		String driver = (String) config.get("driver");
		String url = (String) config.get("url");
		String username = (String) config.get("username");
		String password = (String) config.get("password");
		
		System.out.println("[ConnectionManager] Creating direct connection for: " + dataSourceName);
		System.out.println("[ConnectionManager] Driver: " + driver);
		System.out.println("[ConnectionManager] URL: " + url);
		
		try {
			// Load the appropriate JDBC driver
			if ("sqlserver".equalsIgnoreCase(driver)) {
				Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
			} else if ("oracle".equalsIgnoreCase(driver)) {
				Class.forName("oracle.jdbc.driver.OracleDriver");
			} else if ("mysql".equalsIgnoreCase(driver)) {
				Class.forName("com.mysql.jdbc.Driver");
			} else if ("postgresql".equalsIgnoreCase(driver)) {
				Class.forName("org.postgresql.Driver");
			} else if ("db2".equalsIgnoreCase(driver)) {
				Class.forName("com.ibm.db2.jcc.DB2Driver");
			} else {
				// Try to use the driver string as class name
				Class.forName(driver);
			}
		} catch (ClassNotFoundException e) {
			throw new Exception("JDBC Driver not found: " + driver, e);
		}
		
		Connection conn = DriverManager.getConnection(url, username, password);
		System.out.println("[ConnectionManager] Direct connection established successfully");
		return conn;
	}
	
	/**
	 * Get JNDI datasource connection
	 * 
	 * @param dataSourceName Name of datasource
	 * @param config Datasource configuration
	 * @return Connection object
	 * @throws Exception if connection fails
	 */
	private static Connection getJNDIConnection(String dataSourceName, JSONObject config) throws Exception {
		String jndiName = (String) config.get("jndiName");
		
		System.out.println("[ConnectionManager] Getting JNDI connection for: " + dataSourceName);
		System.out.println("[ConnectionManager] JNDI Name: " + jndiName);
		
		try {
			InitialContext ctx = new InitialContext();
			DataSource ds = (DataSource) ctx.lookup(jndiName);
			Connection conn = ds.getConnection();
			System.out.println("[ConnectionManager] JNDI connection established successfully");
			return conn;
		} catch (NamingException e) {
			throw new Exception("Failed to lookup JNDI datasource: " + jndiName, e);
		} catch (SQLException e) {
			throw new Exception("Failed to get connection from datasource: " + jndiName, e);
		}
	}
	
	/**
	 * Close connection for specific datasource
	 * 
	 * @param dataSourceName Name of datasource
	 */
	public static void closeConnection(String dataSourceName) {
		try {
			if (connectionPool.containsKey(dataSourceName)) {
				Connection conn = connectionPool.get(dataSourceName);
				if (conn != null && !conn.isClosed()) {
					conn.close();
					System.out.println("[ConnectionManager] Connection closed for: " + dataSourceName);
				}
				connectionPool.remove(dataSourceName);
			}
		} catch (Exception e) {
			System.err.println("[ConnectionManager] Error closing connection for " + dataSourceName + ": " + e.getMessage());
			e.printStackTrace();
		}
	}
	
	/**
	 * Close all connections in pool
	 */
	public static void closeAllConnections() {
		System.out.println("[ConnectionManager] Closing all connections...");
		for (String dataSourceName : connectionPool.keySet()) {
			closeConnection(dataSourceName);
		}
		connectionPool.clear();
		System.out.println("[ConnectionManager] All connections closed");
	}
}

========

package com.cnb.eds.editor.filters;

import javax.servlet.http.HttpServletRequest;

import com.cnb.eds.editor.config.LookupConfigManager;
import com.ibm.ecm.extension.PluginResponseFilter;
import com.ibm.ecm.extension.PluginServiceCallbacks;
import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;
import java.util.Map;

/**
 * Response filter that injects custom property editors for lookup properties
 * based on document class and property configuration
 */
public class SAMPLECustomEditorResponseFilter extends PluginResponseFilter {

    public String[] getFilteredServices() {
        return new String[] { "/p8/openContentClass","/p8/openItem" };
    }

    public void filter(String serverType, PluginServiceCallbacks callbacks, 
                      HttpServletRequest request, JSONObject jsonResponse) throws Exception {
        
        String desktopId = request.getParameter("desktop");
        String templateName = request.getParameter("template_name");
        
        System.out.println("[EDSResponseFilter] ========================================");
        System.out.println("[EDSResponseFilter] Desktop: " + desktopId);
        System.out.println("[EDSResponseFilter] Document Class (template_name): " + templateName);
        
        // Get configuration manager
        LookupConfigManager configManager = LookupConfigManager.getInstance();
        
        // Check if this document class has custom editors configured
        if (!configManager.hasDocumentClass(templateName)) {
            System.out.println("[EDSResponseFilter] No configuration found for class: " + templateName);
            System.out.println("[EDSResponseFilter] Available classes: " + configManager.getAvailableDocumentClasses());
            return;
        }
        
        // Check if this desktop is allowed for this document class
        if (!configManager.isDesktopAllowed(templateName, desktopId)) {
            System.out.println("[EDSResponseFilter] Desktop '" + desktopId + "' is not configured for class: " + templateName);
            System.out.println("[EDSResponseFilter] Allowed desktops: " + configManager.getAllowedDesktops(templateName));
            return;
        }
        
        System.out.println("[EDSResponseFilter] âœ“ Desktop '" + desktopId + "' is allowed for class: " + templateName);
        
        JSONArray properties = (JSONArray) jsonResponse.get("criterias");
        
        if (properties == null) {
            System.out.println("[EDSResponseFilter] No properties (criterias) found in response");
            return;
        }
        
        System.out.println("[EDSResponseFilter] Total properties in response: " + properties.size());
        
        // Get all configured properties for this document class
        System.out.println("[EDSResponseFilter] Looking for configuration for document class: '" + templateName + "'");
        Map<String, JSONObject> classProperties = configManager.getDocumentClassProperties(templateName);
        
        if (classProperties.isEmpty()) {
            System.out.println("[EDSResponseFilter] No custom editors configured for class: " + templateName);
            System.out.println("[EDSResponseFilter] Available classes in config: " + configManager.getAvailableDocumentClasses());
            return;
        }
            
        System.out.println("[EDSResponseFilter] Found " + classProperties.size() + " custom editor(s) configured for class: " + templateName);
        
        // Process each property in the response
        int assignedCount = 0;
        for (int i = 0; i < properties.size(); i++) {
            JSONObject jsonPropDef = (JSONObject) properties.get(i);
            String propertyName = (String) jsonPropDef.get("name");
            
            // Check if this property has a custom editor configured
            if (classProperties.containsKey(propertyName)) {
                JSONObject propertyConfig = classProperties.get(propertyName);
                String editorType = (String) propertyConfig.get("editorType");
                
                System.out.println("[EDSResponseFilter] Assigning custom editor to property: " + propertyName);
                System.out.println("[EDSResponseFilter] Editor type: " + editorType);
                
                // Always use InlineAutocompleteEditor (unified editor for all cases)
                jsonPropDef.put("propertyEditor", "cNBPropertyEditorEDSPluginDojo/InlineAutocompleteEditor");
                
                // Inline autocomplete is editable - users type to search
                jsonPropDef.remove("readOnly");
                
                // Embed the configuration for the editor to use
                jsonPropDef.put("lookupConfig", propertyConfig);
                
                System.out.println("[EDSResponseFilter] Successfully assigned InlineAutocompleteEditor to: " + propertyName);
                System.out.println("[EDSResponseFilter] Dependent fields for " + propertyName + " will remain editable");
                
                assignedCount++;
            }
        }
        
        System.out.println("[EDSResponseFilter] Successfully assigned " + assignedCount + " custom editor(s)");
        
        System.out.println("[EDSResponseFilter] ========================================");
    }
}

============


package com.cnb.eds.editor.service;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.cnb.eds.editor.connection.ConnectionManager;
import com.ibm.ecm.extension.PluginService;
import com.ibm.ecm.extension.PluginServiceCallbacks;
import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Generic lookup service that executes dynamic SQL queries based on configuration
 */
public class CustomEditorGenericLookupService extends PluginService {

    public String getId() {
        return "CustomEditorGenericLookupService";
    }

    public String getOverriddenService() {
        return null;
    }

    public void execute(PluginServiceCallbacks callbacks,
            HttpServletRequest request, HttpServletResponse response)
            throws Exception {
        
        String search = request.getParameter("search");
        String limitParam = request.getParameter("limit");
        String lookupConfigJson = request.getParameter("lookupConfig");
        String loadAll = request.getParameter("loadAll");
        
        System.out.println("[CustomEditorGenericLookupService] ========================================");
        System.out.println("[CustomEditorGenericLookupService] Search term: " + search);
        System.out.println("[CustomEditorGenericLookupService] Limit: " + limitParam);
        System.out.println("[CustomEditorGenericLookupService] Load all: " + loadAll);
        
        int limit = 50;
        if (limitParam != null && !limitParam.isEmpty()) {
            try {
                limit = Integer.parseInt(limitParam);
                if (limit < 1) limit = 50;
                if (limit > 200) limit = 200;
            } catch (NumberFormatException e) {
                limit = 50;
            }
        }
        
        JSONArray results = new JSONArray();
        
        try {
            // Parse the lookup configuration
            JSONObject lookupConfig = JSONObject.parse(lookupConfigJson);
            JSONObject queryConfig = (JSONObject) lookupConfig.get("queryConfig");
            String dataSourceName = (String) lookupConfig.get("dataSource");
            
            String sql = (String) queryConfig.get("sql");
            JSONArray resultColumns = (JSONArray) queryConfig.get("resultColumns");
            String searchPattern = (String) queryConfig.get("searchPattern");
            
            // Default to "startsWith" if not specified
            if (searchPattern == null || searchPattern.isEmpty()) {
                searchPattern = "startsWith";
            }
            
            System.out.println("[CustomEditorGenericLookupService] Original SQL: " + sql);
            System.out.println("[CustomEditorGenericLookupService] DataSource: " + dataSourceName);
            System.out.println("[CustomEditorGenericLookupService] Search Pattern: " + searchPattern);
            
            // Replace {limit} placeholder in SQL
            String modifiedSql = sql.replace("{limit}", String.valueOf(limit));
            
            System.out.println("[CustomEditorGenericLookupService] Modified SQL: " + modifiedSql);
            
            // Get database connection
            Connection dbConnection = null;
            
            if (dataSourceName != null && !dataSourceName.isEmpty()) {
                // Use configured datasource
                try {
                    dbConnection = ConnectionManager.getConnectionByDataSource(dataSourceName);
                } catch (Exception e) {
                    System.err.println("[CustomEditorGenericLookupService] Failed to get connection for datasource: " + dataSourceName);
                    throw e;
                }
            } else {
                // Fallback to default connection for backward compatibility
                System.out.println("[CustomEditorGenericLookupService] No datasource specified, using default connection");
            }
            
            if (dbConnection == null) {
                throw new Exception("Database connection is null");
            }
            
            PreparedStatement stmt;
            
            // Check if this is a "load all" request (for choice lists)
            // Choice lists don't have search parameters in their SQL
            boolean isLoadAll = "true".equals(loadAll) || (search == null || search.isEmpty());
            
            if (isLoadAll && !modifiedSql.contains("?")) {
                // No search parameter - execute as-is (for choice lists)
                System.out.println("[CustomEditorGenericLookupService] Executing query without parameters (load all mode)");
                stmt = dbConnection.prepareStatement(modifiedSql);
            } else if (modifiedSql.contains("?")) {
                // Has search parameter(s) - count and bind all of them
                int paramCount = 0;
                for (int i = 0; i < modifiedSql.length(); i++) {
                    if (modifiedSql.charAt(i) == '?') {
                        paramCount++;
                    }
                }
                
                System.out.println("[CustomEditorGenericLookupService] Found " + paramCount + " parameter(s) in query");
                
                // Apply search pattern based on configuration
                String searchValue = applySearchPattern(search, searchPattern);
                System.out.println("[CustomEditorGenericLookupService] Applying pattern '" + searchPattern + "': " + searchValue);
                
                stmt = dbConnection.prepareStatement(modifiedSql);
                
                // Set all parameters with the same search value
                for (int i = 1; i <= paramCount; i++) {
                    stmt.setString(i, searchValue);
                    System.out.println("[CustomEditorGenericLookupService] Set parameter " + i + " = " + searchValue);
                }
            } else {
                // No parameter placeholder but search was provided - execute as-is
                System.out.println("[CustomEditorGenericLookupService] Executing query without parameters");
                stmt = dbConnection.prepareStatement(modifiedSql);
            }
            
            System.out.println("[CustomEditorGenericLookupService] Executing query...");
            
            ResultSet rs = stmt.executeQuery();
            ResultSetMetaData meta = rs.getMetaData();
            
            int rowCount = 0;
            while (rs.next()) {
                JSONObject obj = new JSONObject();
                
                // Use column aliases from result set
                for (int i = 1; i <= meta.getColumnCount(); i++) {
                    String columnName = meta.getColumnLabel(i); // Gets alias if present
                    Object value = rs.getObject(i);
                    obj.put(columnName, value != null ? value.toString() : "");
                }
                
                results.add(obj);
                rowCount++;
            }
            
            rs.close();
            stmt.close();
            
            System.out.println("[CustomEditorGenericLookupService] Found " + rowCount + " results");
            
        } catch (Exception ex) {
            System.err.println("[CustomEditorGenericLookupService] Error executing query: " + ex.getMessage());
            ex.printStackTrace();
            throw ex;
        }
        
        JSONObject json = new JSONObject();
        json.put("results", results);
        json.put("count", results.size() + "");
        json.put("searchTerm", search);
        
        System.out.println("[CustomEditorGenericLookupService] Returning " + results.size() + " results");
        System.out.println("[CustomEditorGenericLookupService] ========================================");
        
        response.setContentType("application/json");
        json.serialize(response.getWriter());
    }
    
    /**
     * Apply search pattern to the search value for SQL LIKE queries
     * 
     * @param searchValue The raw search value from user input
     * @param pattern The pattern type: "startsWith", "endsWith", "contains", "exact"
     * @return The formatted search value with wildcards applied
     */
    private String applySearchPattern(String searchValue, String pattern) {
        if (searchValue == null) {
            searchValue = "";
        }
        
        // Normalize pattern to lowercase for comparison
        String normalizedPattern = pattern.toLowerCase().trim();
        
       /* switch (normalizedPattern) {
            case "startswith":
            case "starts":
            case "value%":
                // Search for values starting with the input
                return searchValue + "%";
                
            case "endswith":
            case "ends":
            case "%value":
                // Search for values ending with the input
                return "%" + searchValue;
                
            case "contains":
            case "anywhere":
            case "%value%":
                // Search for values containing the input anywhere
                return "%" + searchValue + "%";
                
            case "exact":
            case "equals":
            case "value":
                // Exact match (no wildcards)
                return searchValue;
                
            default:
                // Default to startsWith for unknown patterns
                System.out.println("[CustomEditorGenericLookupService] Unknown search pattern '" + pattern + "', defaulting to 'startsWith'");
                return searchValue + "%";
        }*/
        
        if (normalizedPattern.equals("startswith") ||
        	    normalizedPattern.equals("starts") ||
        	    normalizedPattern.equals("value%")) {

        	    // Search for values starting with the input
        	    return searchValue + "%";

        	} else if (normalizedPattern.equals("endswith") ||
        	           normalizedPattern.equals("ends") ||
        	           normalizedPattern.equals("%value")) {

        	    // Search for values ending with the input
        	    return "%" + searchValue;

        	} else if (normalizedPattern.equals("contains") ||
        	           normalizedPattern.equals("anywhere") ||
        	           normalizedPattern.equals("%value%")) {

        	    // Search for values containing the input anywhere
        	    return "%" + searchValue + "%";

        	} else if (normalizedPattern.equals("exact") ||
        	           normalizedPattern.equals("equals") ||
        	           normalizedPattern.equals("value")) {

        	    // Exact match (no wildcards)
        	    return searchValue;

        	} else {
        	    // Default to startsWith for unknown patterns
        	    System.out.println("[CustomEditorGenericLookupService] Unknown search pattern '" + pattern + "', defaulting to 'startsWith'");
        	    return searchValue + "%";
        	}

    }
}

==================
/* SAMPLE Property Editor EDS Plugin Styles */

.messagesDialog .dijitDialogPaneContent {
	background-color: #efe;
}

.edsPropertyEditor {
	display: table;
	position: relative;
}

/* ============================================================
   COMBO BUTTON CONTAINER (Used by InlineAutocompleteEditor)
   ============================================================ */

.comboButtonContainer {
	display: flex !important;
	align-items: stretch;
	border: 1px solid #b5bcc7;
	border-radius: 3px;
	background-color: #ffffff;
}

.comboButtonContainer:hover {
	border-color: #759dc0;
}

.comboButtonArrow {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 22px;
	background-color: #f2f2f2;
	border-left: 1px solid #b5bcc7;
	cursor: pointer;
	transition: background-color 0.2s;
}

.comboButtonArrow:hover {
	background-color: #e0e0e0;
}

.comboButtonArrow .dijitArrowButtonInner {
	font-size: 10px;
	color: #333;
}

.edsPropertyEditor .dijitTextBox {
	display: table-cell;
}

.edsPropertyEditor .dijitTextBox .dijitInputField {
	width: 100%;
}

/* ============================================================
   INLINE AUTOCOMPLETE EDITOR STYLES
   ============================================================ */

/* Inline Autocomplete Editor Container */
.inlineAutocompleteEditor {
    position: relative;
}

.inlineAutocompleteCombo {
	display: inline-block !important;
	position: relative;
}

/* Inline Dropdown Styles */
.inlineDropdown {
    position: fixed;
    background-color: #ffffff;
    border: 2px solid #4a90e2;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    z-index: 9999;
    margin-top: 0;
    max-width: 95vw;
}

.inlineDropdown.position-below {
    border-top: none;
    border-radius: 0 0 4px 4px;
}

.inlineDropdown.position-above {
    border-bottom: none;
    border-radius: 4px 4px 0 0;
}

.dropdownTableContainer {
    max-height: 100px;
    overflow-y: auto;
    overflow-x: auto;
}

.dropdownTable {
    width: auto;
    min-width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 11px;
    table-layout: auto;
}

.dropdownTable thead {
    position: sticky;
    top: 0;
    background-color: #4a90e2;
    z-index: 10;
}

.dropdownTable thead th {
    padding: 6px 8px;
    text-align: left;
    font-weight: bold;
    color: #ffffff;
    border-right: 1px solid #3a7bc8;
    background-color: #4a90e2;
    font-size: 11px;
    white-space: nowrap;
    min-width: 120px;
}

.dropdownTable thead th:last-child {
    border-right: none;
}

.dropdownTable tbody tr {
    cursor: pointer;
    transition: background-color 0.15s ease;
    border-bottom: 1px solid #eee;
}

.dropdownTable tbody tr:hover {
    background-color: #e3f2fd !important;
}

.dropdownTable tbody tr.selected {
    background-color: #bbdefb !important;
}

.dropdownTable tbody td {
    padding: 6px 8px;
    border-right: 1px solid #eee;
    color: #333;
    white-space: nowrap;
    font-size: 11px;
    min-width: 100px;
}

.dropdownTable tbody td:last-child {
    border-right: none;
}

.dropdownTable tbody tr:last-child td {
    border-bottom: none;
}

/* Loading, No Results, and Error states */
.dropdownTable .loadingCell,
.dropdownTable .noResultsCell,
.dropdownTable .errorCell {
    text-align: center;
    padding: 16px 8px !important;
    color: #666;
    font-style: italic;
    font-size: 11px;
}

.dropdownTable .loadingCell {
    background-color: #f9f9f9;
}

.dropdownTable .noResultsCell {
    color: #999;
}

.dropdownTable .errorCell {
    color: #d32f2f;
    background-color: #ffebee;
}

/* Scrollbar styling for dropdown */
.dropdownTableContainer::-webkit-scrollbar {
    width: 8px;
}

.dropdownTableContainer::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.dropdownTableContainer::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

.dropdownTableContainer::-webkit-scrollbar-thumb:hover {
    background: #555;
}

/* Placeholder styling */
.edsPropertyEditor input::placeholder,
.inlineAutocompleteEditor input::placeholder {
    color: #999;
    font-style: italic;
}

=======
require(["dojo/_base/declare",
         "dojo/_base/lang",
         "cNBPropertyEditorEDSPluginDojo/InlineAutocompleteEditor"], 
function(declare, lang, InlineAutocompleteEditor) {		
	
});
======
define([
    "dojo/_base/declare", 
    "dojo/_base/lang",
    "dojo/_base/array",
    "dojo/dom-class",
    "dojo/dom-construct",
    "dojo/dom-geometry",
    "dojo/dom-style",
    "dojo/on",
    "dojo/keys",
    "dijit/_WidgetsInTemplateMixin",
    "ecm/widget/ValidationTextBox",
    "ecm/model/Request",
    "dojo/text!./templates/InlineAutocompleteEditor.html"
],
function(declare, lang, array, domClass, domConstruct, domGeometry, domStyle, on, keys, 
         _WidgetsInTemplateMixin, ValidationTextBox, Request, template) {
    
    /**
     * @name cNBPropertyEditorEDSPluginDojo.InlineAutocompleteEditor
     * @class Unified inline autocomplete editor supporting 3 use cases:
     *        Case 1: Typeahead + populate-on-selection
     *        Case 2: Full-load on open + choose to populate dependents
     *        Case 3: Preload + single preselected value (editable)
     * @augments ValidationTextBox
     */
    return declare("cNBPropertyEditorEDSPluginDojo.InlineAutocompleteEditor", [
        ValidationTextBox,
        _WidgetsInTemplateMixin
    ], {
        /** @lends cNBPropertyEditorEDSPluginDojo.InlineAutocompleteEditor.prototype */

        templateString: template,
        widgetsInTemplate: true,
        
        // Configuration (injected by response filter)
        lookupConfig: null,
        
        // Configuration options
        preloadMode: "none",           // "none", "top500", "preselected"
        preselectedValue: null,        // Value to preselect (Case 3)
        allowClear: true,              // Allow user to clear selection
        allowEdit: true,               // Allow user to edit/type
        clearAfterSelection: false,    // Clear field after populating dependencies
        tooltipMessage: null,          // Tooltip message to show on hover
        
        // Internal state
        _debounceTimer: null,
        _lastSearchValue: "",
        _selectedRecord: null,
        _dropdownVisible: false,
        _documentClickHandler: null,
        _scrollHandler: null,
        _resizeHandler: null,
        _parentScrollHandlers: [],
        _preloadedData: null,
        _dataInitialized: false,
        
        constructor: function(params) {
            console.log("=== InlineAutocompleteEditor constructor ===");
            console.log("Constructor params:", params);
            
            // ICN passes lookupConfig via params.attributeDefinition.lookupConfig
            if (params && params.attributeDefinition && params.attributeDefinition.lookupConfig) {
                this.lookupConfig = params.attributeDefinition.lookupConfig;
                console.log("✓ Extracted lookupConfig from params.attributeDefinition:", this.lookupConfig);
            } else if (params && params.propertyDef && params.propertyDef.lookupConfig) {
                this.lookupConfig = params.propertyDef.lookupConfig;
                console.log("✓ Extracted lookupConfig from params.propertyDef:", this.lookupConfig);
            } else if (params && params.lookupConfig) {
                this.lookupConfig = params.lookupConfig;
                console.log("✓ Found lookupConfig directly in params:", this.lookupConfig);
            } else {
                console.error("✗ No lookupConfig found in constructor params!");
                if (params) {
                    console.log("Available params keys:", Object.keys(params));
                } else {
                    console.log("params is null or undefined");
                }
            }
        },
        
        postCreate: function() {
            this.inherited(arguments);
            
            console.log("=== InlineAutocompleteEditor postCreate ===");
            console.log("Property name:", this.name);
            
            // Try to extract lookupConfig from attributeDefinition if not already set
            if (!this.lookupConfig && this.attributeDefinition && this.attributeDefinition.lookupConfig) {
                this.lookupConfig = this.attributeDefinition.lookupConfig;
                console.log("✓ Extracted lookupConfig from this.attributeDefinition in postCreate:", this.lookupConfig);
            } else if (!this.lookupConfig && this.propertyDef && this.propertyDef.lookupConfig) {
                this.lookupConfig = this.propertyDef.lookupConfig;
                console.log("✓ Extracted lookupConfig from this.propertyDef in postCreate:", this.lookupConfig);
            }
            
            if (this.lookupConfig) {
                console.log("✓ Lookup config available:", this.lookupConfig);
            } else {
                console.error("✗ CRITICAL: No lookupConfig available!");
                console.log("this.attributeDefinition:", this.attributeDefinition);
                console.log("this.propertyDef:", this.propertyDef);
            }
            
            // Load configuration from lookupConfig
            this._loadConfiguration();
            
            // Make field editable (user can type)
            this.set("readOnly", false);
            
            // Styling
            domClass.remove(this.domNode, this.baseClass);
            domClass.add(this.domNode, "inlineAutocompleteEditor");
            
            // Position dropdown container
            domClass.add(this.dropdownNode, "inlineDropdown");
            
            // Add keyup handler to textbox for autocomplete
            this.own(on(this.textbox, "keyup", lang.hitch(this, "_handleTextboxKeyup")));
            
            // Add focus handler to show dropdown if there's content
            this.own(on(this.textbox, "focus", lang.hitch(this, "_handleTextboxFocus")));
            
            // Prevent dropdown from closing when clicking inside it
            this.own(on(this.dropdownNode, "mousedown", function(evt) {
                evt.stopPropagation();
            }));
            
            // Document click handler to close dropdown when clicking outside
            this._documentClickHandler = on(document, "click", lang.hitch(this, function(evt) {
                if (this._dropdownVisible && !this.domNode.contains(evt.target)) {
                    this._hideDropdown();
                }
            }));
            this.own(this._documentClickHandler);
            
            // Window scroll handler to reposition dropdown
            this._scrollHandler = on(window, "scroll", lang.hitch(this, function() {
                if (this._dropdownVisible) {
                    this._repositionDropdown();
                }
            }));
            this.own(this._scrollHandler);
            
            // Window resize handler to reposition dropdown
            this._resizeHandler = on(window, "resize", lang.hitch(this, function() {
                if (this._dropdownVisible) {
                    this._repositionDropdown();
                }
            }));
            this.own(this._resizeHandler);
            
            // Add scroll listeners to all parent scrollable containers
            this._attachParentScrollHandlers();
            
            // Populate table headers from displayColumns config
            this._populateTableHeaders();
            
            // Initialize based on preload mode
            this._initializeEditor();
        },
        
        startup: function() {
            this.inherited(arguments);
            
            console.log("=== InlineAutocompleteEditor startup ===");
            
            // Apply tooltip AFTER ICN finishes its initialization
            // Use setTimeout to ensure it runs after all framework code
            var self = this;
            setTimeout(function() {
                if (self.tooltipMessage === "auto") {
                    self._generateAutoTooltip();
                } else if (self.tooltipMessage) {
                    self._setTooltip(self.tooltipMessage);
                }
                console.log("Tooltip applied in startup()");
            }, 100);
        },
        
        _generateAutoTooltip: function() {
            console.log("Generating auto tooltip");
            
            if (!this.lookupConfig || !this.lookupConfig.queryConfig) {
                return;
            }
            
            var filterColumns = this.lookupConfig.queryConfig.filterColumns;
            var displayColumns = this.lookupConfig.displayColumns;
            
            if (!filterColumns || filterColumns.length === 0) {
                return;
            }
            
            // Build user-friendly tooltip message from filter columns
            var columnNames = [];
            
            for (var i = 0; i < filterColumns.length; i++) {
                var colKey = filterColumns[i];
                // Use display name if available, otherwise use column key
                var displayName = (displayColumns && displayColumns[colKey]) || colKey;
                columnNames.push(displayName);
            }
            
            // Create message: "Enter Model Name / Make / Year"
            var message = "Enter " + columnNames.join(" / ");
            console.log("Auto-generated tooltip:", message);
            this._setTooltip(message);
        },
        
        _setTooltip: function(message) {
            if (!message || !this.textbox) {
                return;
            }
            
            // Set title attribute for native browser tooltip
            this.textbox.setAttribute("title", message);
            
            // Also set on the container for better UX
            if (this.comboContainer) {
                this.comboContainer.setAttribute("title", message);
            }
            
            console.log("Tooltip set:", message);
        },
        
        _populateTableHeaders: function() {
            console.log("Populating table headers");
            
            if (!this.lookupConfig || !this.lookupConfig.queryConfig) {
                console.warn("No queryConfig in lookupConfig");
                return;
            }
            
            domConstruct.empty(this.dropdownHeader);
            
            // Use resultColumns array to maintain column order (arrays preserve order, objects don't)
            var resultColumns = this.lookupConfig.queryConfig.resultColumns || [];
            var displayColumns = this.lookupConfig.displayColumns || {};
            
            console.log("Creating headers for columns:", resultColumns);
            
            // Iterate through resultColumns to preserve order
            for (var i = 0; i < resultColumns.length; i++) {
                var columnKey = resultColumns[i];
                // Look up display name from displayColumns, fallback to column key
                var displayName = displayColumns[columnKey] || columnKey;
                
                domConstruct.create("th", { 
                    innerHTML: displayName 
                }, this.dropdownHeader);
                
                console.log("Header created:", columnKey, "→", displayName);
            }
            
            console.log("Table headers populated in correct order");
        },
        
        _loadConfiguration: function() {
            console.log("Loading configuration");
            
            if (!this.lookupConfig) {
                console.warn("No lookup config provided");
                return;
            }
            
            // Load preload mode (Case 1, 2, or 3)
            this.preloadMode = this.lookupConfig.preloadMode || "none";
            this.preselectedValue = this.lookupConfig.preselectedValue || null;
            this.allowClear = this.lookupConfig.allowClear !== false;
            this.allowEdit = this.lookupConfig.allowEdit !== false;
            this.clearAfterSelection = this.lookupConfig.clearAfterSelection || false;
            this.tooltipMessage = this.lookupConfig.tooltipMessage || null;
            
            console.log("Preload mode:", this.preloadMode);
            console.log("Preselected value:", this.preselectedValue);
            console.log("Allow clear:", this.allowClear);
            console.log("Allow edit:", this.allowEdit);
            console.log("Clear after selection:", this.clearAfterSelection);
            console.log("Tooltip message config:", this.tooltipMessage);
            
            // Apply placeholder from searchConfig
            if (this.lookupConfig.searchConfig && this.lookupConfig.searchConfig.placeholder) {
                var placeholder = this.lookupConfig.searchConfig.placeholder;
                if (this.textbox) {
                    this.textbox.setAttribute("placeholder", placeholder);
                    console.log("Placeholder set to:", placeholder);
                }
            }
            
            // NOTE: Tooltip will be applied in startup() to ensure ICN doesn't override it
        },
        
        _initializeEditor: function() {
            console.log("=== Initializing editor ===");
            console.log("Preload mode:", this.preloadMode);
            
            if (this.preloadMode === "top500") {
                // Case 2: Load top 500 on init
                console.log("Case 2: Loading top 500 results");
                this._preloadTopResults();
                
            } else if (this.preloadMode === "preselected" && this.preselectedValue) {
                // Case 3: Set preselected value
                console.log("Case 3: Setting preselected value:", this.preselectedValue);
                this.set("value", this.preselectedValue);
                this._preloadTopResults(); // Also load top results for search
                
            } else {
                // Case 1: No preload, pure typeahead
                console.log("Case 1: Pure typeahead mode");
                this._dataInitialized = true;
            }
        },
        
        _preloadTopResults: function() {
            console.log("Preloading top results");
            
            var serviceName = (this.lookupConfig && this.lookupConfig.serviceName) || "CustomEditorGenericLookupService";
            var searchConfig = (this.lookupConfig && this.lookupConfig.searchConfig) || {};
            
            Request.invokePluginService("SAMPLEPropertyEditorEDSPlugin", serviceName, {
                requestParams: {
                    search: "",  // Empty search for top results
                    propertyName: this.name,
                    lookupConfig: JSON.stringify(this.lookupConfig),
                    limit: searchConfig.limit || 500,
                    loadAll: "true"
                },
                requestCompleteCallback: lang.hitch(this, function(response) {
                    this._handlePreloadComplete(response);
                }),
                requestFailedCallback: lang.hitch(this, function(error) {
                    console.error("Preload failed:", error);
                    this._dataInitialized = true; // Continue anyway
                })
            });
        },
        
        _handlePreloadComplete: function(response) {
            console.log("Preload complete:", response);
            
            var results = response.results || [];
            this._preloadedData = results;
            this._dataInitialized = true;
            
            console.log("Preloaded", results.length, "results");
            
            // If in top500 mode and field is empty, show results immediately
            if (this.preloadMode === "top500" && !this.get("value")) {
                this._populateDropdown(results);
                // Don't show dropdown automatically, wait for focus/click
            }
        },
        
        _attachParentScrollHandlers: function() {
            // Find all scrollable parent elements
            var node = this.domNode.parentNode;
            while (node && node !== document.body) {
                var overflow = domStyle.get(node, "overflow");
                var overflowY = domStyle.get(node, "overflowY");
                
                if (overflow === "auto" || overflow === "scroll" || overflowY === "auto" || overflowY === "scroll") {
                    var handler = on(node, "scroll", lang.hitch(this, function() {
                        if (this._dropdownVisible) {
                            this._repositionDropdown();
                        }
                    }));
                    this._parentScrollHandlers.push(handler);
                    this.own(handler);
                }
                
                node = node.parentNode;
            }
        },
        
        _toggleDropdown: function(evt) {
            if (evt) {
                evt.stopPropagation();
            }
            
            console.log("Toggling dropdown");
            
            if (this._dropdownVisible) {
                this._hideDropdown();
            } else {
                this._showDropdown();
                // Show preloaded data or trigger search
                this._handleDropdownOpen();
            }
        },
        
        _handleDropdownOpen: function() {
            // If we have preloaded data, show it
            if (this._preloadedData && this._preloadedData.length > 0) {
                console.log("Showing preloaded data");
                this._populateDropdown(this._preloadedData);
            } else {
                // Trigger search with current value if any
                var currentValue = this.get("value") || "";
                var searchConfig = (this.lookupConfig && this.lookupConfig.searchConfig) || {};
                var minLength = searchConfig.minLength || 2;
                
                if (currentValue.length >= minLength) {
                    this._performSearch(currentValue);
                } else {
                    this._showNoResults();
                }
            }
        },
        
        _showDropdown: function() {
            console.log("Showing dropdown");
            domStyle.set(this.dropdownNode, "display", "block");
            this._dropdownVisible = true;
            this._repositionDropdown();
        },
        
        _repositionDropdown: function() {
            if (!this._dropdownVisible) {
                return;
            }
            
            // Calculate position relative to the textbox
            var textboxPos = domGeometry.position(this.comboContainer, true);
            
            // Get viewport height
            var viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            
            // Estimate dropdown height (max-height is 100px + borders/padding ~= 110px)
            var dropdownHeight = 110;
            
            // Calculate space below and above the textbox
            var spaceBelow = viewportHeight - (textboxPos.y + textboxPos.h);
            var spaceAbove = textboxPos.y;
            
            // Determine if dropdown should appear above or below
            var positionAbove = false;
            if (spaceBelow < dropdownHeight && spaceAbove > spaceBelow) {
                positionAbove = true;
            }
            
            // Remove previous position classes
            domClass.remove(this.dropdownNode, "position-below");
            domClass.remove(this.dropdownNode, "position-above");
            
            // Set position and styling
            if (positionAbove) {
                // Position above the textbox
                domStyle.set(this.dropdownNode, {
                    "top": (textboxPos.y - dropdownHeight) + "px",
                    "left": textboxPos.x + "px",
                    "min-width": textboxPos.w + "px"
                });
                domClass.add(this.dropdownNode, "position-above");
            } else {
                // Position below the textbox
                domStyle.set(this.dropdownNode, {
                    "top": (textboxPos.y + textboxPos.h) + "px",
                    "left": textboxPos.x + "px",
                    "min-width": textboxPos.w + "px"
                });
                domClass.add(this.dropdownNode, "position-below");
            }
        },
        
        _hideDropdown: function() {
            console.log("Hiding dropdown");
            domStyle.set(this.dropdownNode, "display", "none");
            this._dropdownVisible = false;
        },
        
        _handleTextboxFocus: function(evt) {
            console.log("Textbox focused");
            
            // Show dropdown with preloaded data or current search
            if (this._dataInitialized) {
                if (this._preloadedData && this._preloadedData.length > 0) {
                    this._showDropdown();
                    this._populateDropdown(this._preloadedData);
                } else {
                    var value = this.get("value") || "";
                    var searchConfig = (this.lookupConfig && this.lookupConfig.searchConfig) || {};
                    var minLength = searchConfig.minLength || 2;
                    
                    if (value.length >= minLength) {
                        this._showDropdown();
                        this._performSearch(value);
                    }
                }
            }
        },
        
        _handleTextboxKeyup: function(evt) {
            // Handle special keys
            if (evt.keyCode === keys.ESCAPE) {
                this._hideDropdown();
                return;
            }
            
            if (evt.keyCode === keys.ENTER) {
                // If dropdown is visible and there's a selection, select it
                if (this._dropdownVisible && this._selectedRecord) {
                    this._selectRecord(this._selectedRecord);
                }
                return;
            }
            
            // Clear any existing timer
            if (this._debounceTimer) {
                clearTimeout(this._debounceTimer);
            }
            
            var searchValue = this.get("value") || "";
            var searchConfig = (this.lookupConfig && this.lookupConfig.searchConfig) || {};
            var minLength = searchConfig.minLength || 2;
            
            // Check minimum length
            if (searchValue.length < minLength) {
                // If we have preloaded data, filter it even below minLength
                if (this._preloadedData && (this.preloadMode === "top500" || this.preloadMode === "preselected")) {
                    this._showDropdown();
                    if (searchValue.length > 0) {
                        console.log("Filtering preloaded data (below minLength)");
                        this._filterPreloadedData(searchValue);
                    } else {
                        // Show all preloaded data if search is empty
                        this._populateDropdown(this._preloadedData);
                    }
                } else {
                    this._hideDropdown();
                }
                return;
            }
            
            // Show dropdown
            this._showDropdown();
            
            // Check preload mode to decide filtering strategy
            if (this.preloadMode === "top500" || this.preloadMode === "preselected") {
                // Client-side filtering: Filter preloaded data locally
                if (this._preloadedData && this._preloadedData.length > 0) {
                    console.log("Client-side filtering (preloadMode: " + this.preloadMode + ")");
                    this._filterPreloadedData(searchValue);
                } else if (searchValue.length > 0) {
                    // Preload data not loaded yet, show "loading"
                    this._showLoading();
                }
            } else {
                // Server-side filtering: Search on server
                console.log("Server-side filtering (preloadMode: " + this.preloadMode + ")");
                this._debounceSearch(searchValue);
            }
        },
        
        _debounceSearch: function(searchValue) {
            // Debounce the search
            this._debounceTimer = setTimeout(lang.hitch(this, function() {
                if (searchValue !== this._lastSearchValue) {
                    this._lastSearchValue = searchValue;
                    this._performSearch(searchValue);
                }
            }), (this.lookupConfig && this.lookupConfig.searchConfig && this.lookupConfig.searchConfig.debounceDelay) || 300);
        },
        
        _filterPreloadedData: function(searchTerm) {
            console.log("Filtering preloaded data for:", searchTerm);
            
            if (!this._preloadedData) {
                return [];
            }
            
            var searchLower = searchTerm.toLowerCase();
            
            // Get filter columns from config (or fallback to all result columns)
            var filterColumns = (this.lookupConfig && this.lookupConfig.queryConfig && this.lookupConfig.queryConfig.filterColumns);
            if (!filterColumns || filterColumns.length === 0) {
                // If no filterColumns specified, use all resultColumns
                filterColumns = (this.lookupConfig && this.lookupConfig.queryConfig && this.lookupConfig.queryConfig.resultColumns) || [];
                console.log("No filterColumns specified, using all resultColumns:", filterColumns);
            } else {
                console.log("Filtering on configured columns:", filterColumns);
            }
            
            // Filter based on specified columns containing the search term
            var filtered = array.filter(this._preloadedData, function(record) {
                for (var i = 0; i < filterColumns.length; i++) {
                    var colValue = String(record[filterColumns[i]] || "").toLowerCase();
                    if (colValue.indexOf(searchLower) !== -1) {
                        return true;
                    }
                }
                return false;
            });
            
            console.log("Filtered to", filtered.length, "results");
            this._populateDropdown(filtered);
            
            return filtered;
        },
        
        _performSearch: function(searchTerm) {
            console.log("Searching for: " + searchTerm);
            
            // Show loading indicator
            this._showLoading();
            
            var serviceName = (this.lookupConfig && this.lookupConfig.serviceName) || "CustomEditorGenericLookupService";
            var searchConfig = (this.lookupConfig && this.lookupConfig.searchConfig) || {};
            
            // Call plugin service
            Request.invokePluginService("SAMPLEPropertyEditorEDSPlugin", serviceName, {
                requestParams: {
                    search: searchTerm,
                    propertyName: this.name,
                    lookupConfig: JSON.stringify(this.lookupConfig),
                    limit: searchConfig.limit || 500
                },
                requestCompleteCallback: lang.hitch(this, function(response) {
                    this._handleSearchResults(response);
                }),
                requestFailedCallback: lang.hitch(this, function(error) {
                    console.error("Search failed:", error);
                    this._showError("Search failed. Please try again.");
                })
            });
        },
        
        _handleSearchResults: function(response) {
            console.log("Handling search results:", response);
            
            var results = response.results || [];
            console.log("Results extracted:", results);
            console.log("Results length:", results.length);
            
            if (results.length === 0) {
                this._showNoResults();
            } else {
                this._populateDropdown(results);
            }
        },
        
        _showLoading: function() {
            domConstruct.empty(this.dropdownBody);
            var row = domConstruct.create("tr", {}, this.dropdownBody);
            domConstruct.create("td", {
                colspan: 3,
                "class": "loadingCell",
                innerHTML: "Searching..."
            }, row);
        },
        
        _showNoResults: function() {
            domConstruct.empty(this.dropdownBody);
            var row = domConstruct.create("tr", {}, this.dropdownBody);
            domConstruct.create("td", {
                colspan: 3,
                "class": "noResultsCell",
                innerHTML: "No results found"
            }, row);
        },
        
        _showError: function(message) {
            domConstruct.empty(this.dropdownBody);
            var row = domConstruct.create("tr", {}, this.dropdownBody);
            domConstruct.create("td", {
                colspan: 3,
                "class": "errorCell",
                innerHTML: message
            }, row);
        },
        
        _populateDropdown: function(results) {
            domConstruct.empty(this.dropdownBody);
            
            console.log("Populating dropdown with results:", results);
            console.log("Results length:", results.length);
            
            // Convert to array if needed
            var resultArray = results;
            if (typeof results.length === 'undefined') {
                console.error("Results is not an array!");
                return;
            }
            
            var resultColumns = (this.lookupConfig && this.lookupConfig.queryConfig && this.lookupConfig.queryConfig.resultColumns) || [];
            
            // Use traditional for loop for better compatibility with IBM ECM JSON responses
            for (var i = 0; i < resultArray.length; i++) {
                var record = resultArray[i];
                
                var row = domConstruct.create("tr", {
                    "class": "dropdownRow"
                }, this.dropdownBody);
                
                // Create cells for each column
                for (var j = 0; j < resultColumns.length; j++) {
                    var colName = resultColumns[j];
                    domConstruct.create("td", { 
                        innerHTML: record[colName] || "" 
                    }, row);
                }
                
                // Add click handler - use closure to capture correct record
                (function(currentRecord) {
                    this.own(on(row, "click", lang.hitch(this, function() {
                        this._selectRecord(currentRecord);
                    })));
                }).call(this, record);
            }
            
            console.log("Dropdown populated with " + resultArray.length + " rows");
        },
        
        _selectRecord: function(record) {
            console.log("Selected record:", record);
            
            // Store selected record
            this._selectedRecord = record;
            
            // Get the primary key column (first in resultColumns)
            var resultColumns = (this.lookupConfig && this.lookupConfig.queryConfig && this.lookupConfig.queryConfig.resultColumns) || [];
            var primaryKey = resultColumns[0];
            var primaryValue = record[primaryKey];
            
            // Set the account number value
            this.set("value", primaryValue);
            
            // CRITICAL: Mark THIS field as touched and trigger its onChange
            this._hasBeenBlurred = true;
            this.focused = true;
            
            if (typeof this.onChange === "function") {
                console.log("Calling this.onChange()");
                this.onChange(primaryValue);
            }
            
            // Get the properties pane and trigger its onChange
            var propertiesPane = this._getPropertiesPane();
            if (propertiesPane && typeof propertiesPane.onPropertyChanged === "function") {
                console.log("Calling propertiesPane.onPropertyChanged() for field");
                propertiesPane.onPropertyChanged();
            }
            
            // Populate related fields
            this._populateRelatedFields(record);
            
            // Clear field after selection if configured
            if (this.clearAfterSelection) {
                console.log("Clearing field after selection (clearAfterSelection: true)");
                setTimeout(lang.hitch(this, function() {
                    this.set("value", "");
                    console.log("Field cleared");
                }), 100); // Small delay to ensure dependent fields are populated first
            }
            
            // Hide dropdown
            this._hideDropdown();
            
            console.log("Fields populated with selected record");
        },
        
        _populateRelatedFields: function(record) {
            console.log("=== Populating related fields ===");
            console.log("Record:", record);
            
            var propertiesPane = this._getPropertiesPane();
            if (!propertiesPane) {
                console.error("Properties pane not found");
                return;
            }
            
            var fieldMappings = (this.lookupConfig && this.lookupConfig.fieldMappings) || {};
            
            for (var sourceField in fieldMappings) {
                var mappingConfig = fieldMappings[sourceField];
                
                // Support both old format (string) and new format (object)
                var targetField, dataType, cardinality, separator, format;
                
                if (typeof mappingConfig === "string") {
                    // Old format: "fieldMappings": { "customerName": "CustomerName" }
                    targetField = mappingConfig;
                    dataType = "xs:string";
                    cardinality = "SINGLE";
                } else {
                    // New format with metadata
                    targetField = mappingConfig.targetProperty;
                    dataType = mappingConfig.dataType || "xs:string";
                    cardinality = mappingConfig.cardinality || "SINGLE";
                    separator = mappingConfig.separator || ",";
                    format = mappingConfig.format;
                }
                
                var sourceValue = record[sourceField];
                
                console.log("Mapping:", sourceField, "→", targetField);
                console.log("  Source value:", sourceValue);
                console.log("  Data type:", dataType);
                console.log("  Cardinality:", cardinality);
                
                // Convert and format the value
                var formattedValue = this._formatValue(sourceValue, dataType, cardinality, separator, format);
                
                console.log("  Formatted value:", formattedValue);
                
                // Set the value (fields remain editable)
                this.setICNPropertyValue(propertiesPane, targetField, formattedValue, cardinality);
            }
            
            console.log("=== Field population complete ===");
        },
        
        _formatValue: function(value, dataType, cardinality, separator, format) {
            if (value == null || value === "") {
                return cardinality === "LIST" ? [] : "";
            }
            
            // Handle multi-value properties
            if (cardinality === "LIST" || cardinality === "MULTI") {
                var values;
                
                if (Array.isArray(value)) {
                    values = value;
                } else if (typeof value === "string") {
                    values = value.split(separator).map(function(v) { 
                        return v.trim(); 
                    }).filter(function(v) { 
                        return v.length > 0; 
                    });
                } else {
                    values = [value];
                }
                
                return array.map(values, lang.hitch(this, function(v) {
                    return this._formatSingleValue(v, dataType, format);
                }));
            } else {
                return this._formatSingleValue(value, dataType, format);
            }
        },
        
        _formatSingleValue: function(value, dataType, format) {
            if (value == null || value === "") {
                return "";
            }
            
            switch (dataType) {
                case "xs:string":
                    return String(value);
                    
                case "xs:integer":
                case "xs:int":
                case "xs:long":
                    return parseInt(value, 10);
                    
                case "xs:double":
                case "xs:decimal":
                case "xs:float":
                    return parseFloat(value);
                    
                case "xs:boolean":
                    if (typeof value === "boolean") return value;
                    if (typeof value === "string") {
                        return value.toLowerCase() === "true" || value === "1";
                    }
                    return Boolean(value);
                    
                case "xs:date":
                case "xs:timestamp":
                case "xs:time":
                    return this._formatDateValue(value, format);
                    
                default:
                    return String(value);
            }
        },
        
        _formatDateValue: function(value, format) {
            if (value instanceof Date) {
                return value.getTime();
            }
            
            if (typeof value === "string") {
                try {
                    var date = new Date(value);
                    if (!isNaN(date.getTime())) {
                        return date.getTime();
                    }
                } catch (e) {
                    console.error("Error parsing date:", value, e);
                }
            }
            
            if (typeof value === "number") {
                return value;
            }
            
            return value;
        },
        
        setICNPropertyValue: function(propertiesPane, propertyName, newValue, cardinality) {
            console.log("=== setICNPropertyValue ===");
            console.log("Property:", propertyName);
            console.log("Value:", newValue);
            console.log("Cardinality:", cardinality);
            
            if (!propertiesPane || !propertiesPane._propertyEditors) {
                console.error("Properties pane or property editors not found");
                return;
            }
            
            // Find the field
            var field = null;
            for (var i = 0; i < propertiesPane._propertyEditors._fields.length; i++) {
                var f = propertiesPane._propertyEditors._fields[i];
                if (f && f.name === propertyName) {
                    field = f;
                    break;
                }
            }
            
            if (!field) {
                console.warn("Field not found:", propertyName);
                return;
            }
            
            console.log("Found field:", field.name);
            
            // Handle based on cardinality
            if (cardinality === "LIST" || cardinality === "MULTI" || 
                field.cardinality === "LIST" || field.cardinality === "MULTI") {
                
                console.log("Setting multi-value field");
                var valueArray = Array.isArray(newValue) ? newValue : [newValue];
                
                if (field.setValueAsArray) {
                    field.setValueAsArray(valueArray);
                } else if (field.setValue && field.getValue) {
                    try {
                        field.setValue(valueArray);
                    } catch (e) {
                        console.warn("setValue failed, trying set('value'):", e);
                        field.set("value", valueArray);
                    }
                } else {
                    field.set("value", valueArray);
                }
            } else {
                console.log("Setting single-value field");
                var singleValue = Array.isArray(newValue) ? newValue[0] : newValue;
                field.set("value", singleValue);
            }
            
            // Mark field as changed
            field._hasBeenBlurred = true;
            field.focused = true;
            
            // Trigger onChange
            if (typeof field.onChange === "function") {
                console.log("Calling field.onChange()");
                try {
                    var currentValue = field.getValue ? field.getValue() : field.get("value");
                    field.onChange(currentValue);
                } catch (e) {
                    console.warn("onChange call failed:", e);
                }
            }
            
            // Notify properties pane
            if (typeof propertiesPane.onPropertyChanged === "function") {
                console.log("Calling propertiesPane.onPropertyChanged()");
                propertiesPane.onPropertyChanged();
            }
            
            console.log("=== setICNPropertyValue complete ===");
        },
        
        _getPropertiesPane: function() {
            var widget = this.getParent();
            while (widget) {
                if (widget.declaredClass === "ecm.widget.CommonPropertiesPane" || 
                    widget.declaredClass === "ecm.widget.AddContentItemPropertiesPane") {
                    return widget;
                }
                if (widget._propertiesPane) return widget._propertiesPane;
                if (widget.propertiesPane) return widget.propertiesPane;
                
                widget = widget.getParent ? widget.getParent() : null;
            }
            return null;
        },
        
        destroy: function() {
            if (this._debounceTimer) {
                clearTimeout(this._debounceTimer);
            }
            if (this._dropdownVisible) {
                this._hideDropdown();
            }
            this._preloadedData = null;
            this.inherited(arguments);
        }
    });
});

=======

<div class="dijit dijitReset dijitInline dijitLeft inlineAutocompleteCombo" id="widget_${id}" role="presentation">
	<div class="dijit dijitReset dijitInline dijitLeft comboButtonContainer" data-dojo-attach-point="comboContainer">
		<div class="dijit dijitReset dijitInline dijitLeft" data-dojo-attach-point="stateNode">
			<div class='dijitReset dijitValidationContainer'>
				<input class="dijitReset dijitInputField dijitValidationIcon dijitValidationInner" value="&#935; " type="text" tabIndex="-1" readonly="readonly" role="presentation"/>
			</div>
			<div class="dijitReset dijitInputField dijitInputContainer">
				<input class="dijitReset dijitInputInner" data-dojo-attach-point='textbox,focusNode' autocomplete="off"
					${!nameAttrSetting} type='${type}' placeholder=""/>
			</div>
		</div>
		<div class="comboButtonArrow" data-dojo-attach-point="arrowButton" data-dojo-attach-event="onClick: _toggleDropdown">
			<span class="dijitArrowButtonInner"></span>
		</div>
	</div>
	<div class="inlineDropdown" data-dojo-attach-point="dropdownNode" style="display: none;">
		<div class="dropdownTableContainer" data-dojo-attach-point="dropdownContainer">
			<table class="dropdownTable" data-dojo-attach-point="dropdownTable">
				<thead>
					<tr data-dojo-attach-point="dropdownHeader">
						<!-- Headers will be populated dynamically based on config -->
					</tr>
				</thead>
				<tbody data-dojo-attach-point="dropdownBody">
					<!-- Results populated here -->
				</tbody>
			</table>
		</div>
	</div>
</div>

