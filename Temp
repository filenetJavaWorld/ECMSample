import java.io.*;
import java.sql.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.nio.file.*;
import java.time.*;
import java.time.format.*;

/**
 * CC Document External ID Importer
 * 
 * Multi-threaded Java program to import CSV files into cc_document_externalID table.
 * 
 * Features:
 * - Multi-threaded file processing
 * - Batch inserts for performance
 * - Duplicate handling
 * - Progress tracking
 * - Error logging
 * 
 * Compile: javac CCDocumentExternalIDImporter.java
 * Run:     java -cp ".;mssql-jdbc-12.4.2.jre11.jar" CCDocumentExternalIDImporter
 * 
 * Download JDBC Driver: https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server
 */
public class CCDocumentExternalIDImporter {

    // ========================================================================
    // CONFIGURATION - UPDATE THESE VALUES
    // ========================================================================
    
    // SQL Server connection
    private static final String DB_SERVER = "your-sql-server-name";  // ‚Üê Change this
    private static final String DB_NAME = "Wawa_DMS_Conversion_UAT";
    private static final String DB_PORT = "1433";
    
    // Authentication: Windows Auth or SQL Auth
    private static final boolean USE_WINDOWS_AUTH = true;  // Set to false for SQL Auth
    private static final String DB_USERNAME = "your_username";  // Only if USE_WINDOWS_AUTH = false
    private static final String DB_PASSWORD = "your_password";  // Only if USE_WINDOWS_AUTH = false
    
    // Folder paths
    private static final String CSV_FOLDER_PATH = "C:\\Rameshwar\\cc_document\\chunks";
    private static final String ERROR_FOLDER_PATH = "C:\\Rameshwar\\cc_document\\errors";
    
    // Performance settings
    private static final int BATCH_SIZE = 10000;           // Rows per batch insert
    private static final int THREAD_COUNT = 4;             // Number of parallel threads
    private static final int CONNECTION_POOL_SIZE = 8;     // Database connections
    
    // ========================================================================
    // DO NOT MODIFY BELOW THIS LINE
    // ========================================================================
    
    // Thread-safe set for tracking existing/processed externalIDs
    private static final Set<String> existingExternalIDs = ConcurrentHashMap.newKeySet();
    
    // Counters
    private static final AtomicLong totalRowsProcessed = new AtomicLong(0);
    private static final AtomicLong totalInserted = new AtomicLong(0);
    private static final AtomicLong totalDuplicates = new AtomicLong(0);
    private static final AtomicLong totalErrors = new AtomicLong(0);
    
    // Connection pool
    private static final BlockingQueue<Connection> connectionPool = new LinkedBlockingQueue<>();
    
    // Date formatter
    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        
        printHeader();
        
        try {
            // Step 1: Initialize connection pool
            log("Step 1: Initializing database connections...");
            initializeConnectionPool();
            log("  Created " + CONNECTION_POOL_SIZE + " database connections");
            
            // Step 2: Load existing externalIDs
            log("\nStep 2: Loading existing externalIDs from database...");
            loadExistingExternalIDs();
            log("  Loaded " + existingExternalIDs.size() + " existing externalIDs");
            
            // Step 3: Create error folder
            log("\nStep 3: Creating error folder...");
            Files.createDirectories(Paths.get(ERROR_FOLDER_PATH));
            log("  Error folder: " + ERROR_FOLDER_PATH);
            
            // Step 4: Get CSV files
            log("\nStep 4: Finding CSV files...");
            List<File> csvFiles = getCsvFiles();
            if (csvFiles.isEmpty()) {
                log("  ERROR: No CSV files found in " + CSV_FOLDER_PATH);
                return;
            }
            log("  Found " + csvFiles.size() + " CSV file(s)");
            
            // Step 5: Process files with multi-threading
            log("\nStep 5: Processing files with " + THREAD_COUNT + " threads...");
            log("=" .repeat(80));
            
            ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
            List<Future<FileResult>> futures = new ArrayList<>();
            
            for (File csvFile : csvFiles) {
                futures.add(executor.submit(() -> processFile(csvFile)));
            }
            
            // Wait for all files to complete
            List<FileResult> results = new ArrayList<>();
            for (Future<FileResult> future : futures) {
                try {
                    results.add(future.get());
                } catch (Exception e) {
                    log("  ERROR processing file: " + e.getMessage());
                }
            }
            
            executor.shutdown();
            executor.awaitTermination(1, TimeUnit.HOURS);
            
            // Step 6: Print final summary
            printFinalSummary(results, startTime);
            
        } catch (Exception e) {
            log("FATAL ERROR: " + e.getMessage());
            e.printStackTrace();
        } finally {
            closeConnectionPool();
        }
    }
    
    /**
     * Initialize the database connection pool
     */
    private static void initializeConnectionPool() throws SQLException {
        String connectionUrl = buildConnectionUrl();
        
        for (int i = 0; i < CONNECTION_POOL_SIZE; i++) {
            Connection conn = DriverManager.getConnection(connectionUrl);
            conn.setAutoCommit(false);
            connectionPool.offer(conn);
        }
    }
    
    /**
     * Build the JDBC connection URL
     */
    private static String buildConnectionUrl() {
        StringBuilder url = new StringBuilder();
        url.append("jdbc:sqlserver://").append(DB_SERVER).append(":").append(DB_PORT);
        url.append(";databaseName=").append(DB_NAME);
        url.append(";encrypt=true;trustServerCertificate=true");
        
        if (USE_WINDOWS_AUTH) {
            url.append(";integratedSecurity=true");
        } else {
            url.append(";user=").append(DB_USERNAME);
            url.append(";password=").append(DB_PASSWORD);
        }
        
        return url.toString();
    }
    
    /**
     * Get a connection from the pool
     */
    private static Connection getConnection() throws InterruptedException {
        return connectionPool.take();
    }
    
    /**
     * Return a connection to the pool
     */
    private static void returnConnection(Connection conn) {
        if (conn != null) {
            connectionPool.offer(conn);
        }
    }
    
    /**
     * Close all connections in the pool
     */
    private static void closeConnectionPool() {
        Connection conn;
        while ((conn = connectionPool.poll()) != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                // Ignore
            }
        }
    }
    
    /**
     * Load existing externalIDs from the database
     */
    private static void loadExistingExternalIDs() throws Exception {
        Connection conn = getConnection();
        try {
            String sql = "SELECT externalID FROM [dbo].[cc_document_externalID]";
            try (Statement stmt = conn.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {
                while (rs.next()) {
                    existingExternalIDs.add(rs.getString("externalID"));
                }
            }
        } finally {
            returnConnection(conn);
        }
    }
    
    /**
     * Get list of CSV files from the folder
     */
    private static List<File> getCsvFiles() {
        File folder = new File(CSV_FOLDER_PATH);
        File[] files = folder.listFiles((dir, name) -> name.toLowerCase().endsWith(".csv"));
        
        if (files == null) {
            return new ArrayList<>();
        }
        
        List<File> fileList = Arrays.asList(files);
        fileList.sort(Comparator.comparing(File::getName));
        return fileList;
    }
    
    /**
     * Process a single CSV file
     */
    private static FileResult processFile(File csvFile) {
        String fileName = csvFile.getName();
        long fileStartTime = System.currentTimeMillis();
        
        FileResult result = new FileResult(fileName);
        
        log("\n[" + Thread.currentThread().getName() + "] Processing: " + fileName);
        
        // Track duplicates within this file
        Set<String> inFileDuplicates = new HashSet<>();
        
        // Batch for inserts
        List<String> batch = new ArrayList<>();
        
        // Error file
        String errorFilePath = ERROR_FOLDER_PATH + File.separator + fileName + ".duplicates.csv";
        
        try (BufferedReader reader = new BufferedReader(new FileReader(csvFile));
             PrintWriter errorWriter = new PrintWriter(new FileWriter(errorFilePath))) {
            
            errorWriter.println("externalID,errorType,errorMessage");
            
            // Skip header
            String header = reader.readLine();
            
            String line;
            while ((line = reader.readLine()) != null) {
                result.totalRows++;
                totalRowsProcessed.incrementAndGet();
                
                // Parse externalID (first column)
                String externalID = line.trim();
                if (externalID.contains(",")) {
                    externalID = externalID.split(",")[0].trim();
                }
                
                // Skip empty lines
                if (externalID.isEmpty()) {
                    continue;
                }
                
                // Check for duplicate in file
                if (inFileDuplicates.contains(externalID)) {
                    result.duplicates++;
                    totalDuplicates.incrementAndGet();
                    errorWriter.println(externalID + ",DUPLICATE_IN_FILE,Appears multiple times in file");
                    continue;
                }
                inFileDuplicates.add(externalID);
                
                // Check for duplicate in database (thread-safe)
                if (!existingExternalIDs.add(externalID)) {
                    result.duplicates++;
                    totalDuplicates.incrementAndGet();
                    errorWriter.println(externalID + ",DUPLICATE,Already exists in database");
                    continue;
                }
                
                // Add to batch
                batch.add(externalID);
                
                // Insert batch when full
                if (batch.size() >= BATCH_SIZE) {
                    int inserted = insertBatch(batch);
                    result.inserted += inserted;
                    totalInserted.addAndGet(inserted);
                    batch.clear();
                    
                    // Progress log
                    if (result.totalRows % 100000 == 0) {
                        log("  [" + Thread.currentThread().getName() + "] " + fileName + 
                            ": " + result.totalRows + " rows processed, " + 
                            result.inserted + " inserted");
                    }
                }
            }
            
            // Insert remaining batch
            if (!batch.isEmpty()) {
                int inserted = insertBatch(batch);
                result.inserted += inserted;
                totalInserted.addAndGet(inserted);
            }
            
        } catch (Exception e) {
            result.errors++;
            totalErrors.incrementAndGet();
            log("  ERROR in " + fileName + ": " + e.getMessage());
        }
        
        // Remove empty error file
        File errorFile = new File(errorFilePath);
        if (result.duplicates == 0 && errorFile.exists()) {
            errorFile.delete();
        }
        
        result.durationSeconds = (System.currentTimeMillis() - fileStartTime) / 1000.0;
        
        // Print file summary
        log(String.format("\n[%s] Completed: %s", Thread.currentThread().getName(), fileName));
        log(String.format("  Rows: %,d | Inserted: %,d | Duplicates: %,d | Time: %.2fs | Speed: %,.0f rows/sec",
            result.totalRows, result.inserted, result.duplicates, result.durationSeconds,
            result.totalRows / Math.max(result.durationSeconds, 0.001)));
        
        return result;
    }
    
    /**
     * Insert a batch of externalIDs
     */
    private static int insertBatch(List<String> batch) throws Exception {
        if (batch.isEmpty()) return 0;
        
        Connection conn = getConnection();
        try {
            String sql = "INSERT INTO [dbo].[cc_document_externalID] (externalID) VALUES (?)";
            
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                for (String externalID : batch) {
                    pstmt.setString(1, externalID);
                    pstmt.addBatch();
                }
                
                int[] results = pstmt.executeBatch();
                conn.commit();
                
                return results.length;
            }
        } catch (SQLException e) {
            conn.rollback();
            throw e;
        } finally {
            returnConnection(conn);
        }
    }
    
    /**
     * Print header
     */
    private static void printHeader() {
        log("=".repeat(80));
        log("CC DOCUMENT EXTERNAL ID IMPORTER");
        log("=".repeat(80));
        log("Server:      " + DB_SERVER);
        log("Database:    " + DB_NAME);
        log("CSV Folder:  " + CSV_FOLDER_PATH);
        log("Threads:     " + THREAD_COUNT);
        log("Batch Size:  " + BATCH_SIZE);
        log("Started:     " + LocalDateTime.now().format(formatter));
        log("=".repeat(80));
    }
    
    /**
     * Print final summary
     */
    private static void printFinalSummary(List<FileResult> results, long startTime) throws Exception {
        long totalDuration = (System.currentTimeMillis() - startTime) / 1000;
        
        // Get final count from database
        long finalCount = 0;
        Connection conn = getConnection();
        try {
            String sql = "SELECT COUNT(*) FROM [dbo].[cc_document_externalID]";
            try (Statement stmt = conn.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {
                if (rs.next()) {
                    finalCount = rs.getLong(1);
                }
            }
        } finally {
            returnConnection(conn);
        }
        
        log("\n" + "=".repeat(80));
        log("FINAL SUMMARY");
        log("=".repeat(80));
        log(String.format("  Files processed:       %d", results.size()));
        log(String.format("  Total rows in CSVs:    %,d", totalRowsProcessed.get()));
        log(String.format("  New records inserted:  %,d", totalInserted.get()));
        log(String.format("  Duplicates skipped:    %,d", totalDuplicates.get()));
        log(String.format("  Errors:                %,d", totalErrors.get()));
        log("  " + "-".repeat(40));
        log(String.format("  Total in database:     %,d", finalCount));
        log(String.format("  Total duration:        %d seconds (%.2f minutes)", totalDuration, totalDuration / 60.0));
        log(String.format("  Average speed:         %,.0f rows/second", 
            totalRowsProcessed.get() / Math.max(totalDuration, 1.0)));
        log("=".repeat(80));
        log("Completed: " + LocalDateTime.now().format(formatter));
        log("=".repeat(80));
        
        if (totalDuplicates.get() > 0) {
            log("\nDuplicate files saved to: " + ERROR_FOLDER_PATH);
        }
        
        log("\nNext step: Run 03_find_missing_externalIDs.sql to find missing records");
    }
    
    /**
     * Log message with timestamp
     */
    private static void log(String message) {
        System.out.println(message);
    }
    
    /**
     * Result class for file processing
     */
    static class FileResult {
        String fileName;
        long totalRows = 0;
        long inserted = 0;
        long duplicates = 0;
        long errors = 0;
        double durationSeconds = 0;
        
        FileResult(String fileName) {
            this.fileName = fileName;
        }
    }
}

