package com.cnb;

import com.google.gson.*;

import java.io.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class EDS_TestCase_CSV_Generator {

    private static final AtomicInteger COUNTER = new AtomicInteger(1);

    private static final String[] HEADERS = {
            "Test case ID",
            "Document class",
            "Entry Template Name",
            "Test case type",
            "Input scenario",
            "Input values",
            "Output scenario",
            "Expected result",
            "Actual Results",
            "Testing Status",
            "Test result",
            "Comments"
    };

    public static void main(String[] args) throws Exception {

    	 String jsonPath = args.length > 0 ? args[0] : "D:\\Data\\cnb\\lookupConfig.json";
         String csvPath  = args.length > 1 ? args[1] : "D:\\Data\\cnb\\EDS_Test_Cases.csv";

        JsonObject root;
        try (FileReader fr = new FileReader(jsonPath)) {
            root = JsonParser.parseReader(fr).getAsJsonObject();
        }

        JsonObject documentClasses = root.getAsJsonObject("documentClasses");
        if (documentClasses == null) {
            System.out.println("ERROR: documentClasses not found.");
            return;
        }

        try (PrintWriter writer = new PrintWriter(new FileWriter(csvPath))) {

            writer.println(String.join(",", HEADERS));

            for (String docClass : documentClasses.keySet()) {

                JsonObject dcObj = documentClasses.getAsJsonObject(docClass);
                if (dcObj == null) continue;

                // Gather template names under this docClass
                List<String> templates = new ArrayList<>();
                for (String key : dcObj.keySet()) {
                    if (!key.equalsIgnoreCase("desktops") && !key.equalsIgnoreCase("properties")) {
                        templates.add(key);
                    }
                }

                // 1) Desktop visibility testcases
                String desktopList = dcObj.has("desktops")
                        ? clean(dcObj.getAsJsonArray("desktops").toString())
                        : "Not configured";

                writeRow(writer,
                        "Desktop visibility validation",
                        docClass,
                        "",
                        "User logs in and navigates to each configured desktop; verify EDS/EDS-driven UI appears only on the desktops where it is configured.",
                        "As per the configuration desktops = " + desktopList,
                        "EDS should be visible only in configured desktops",
                        "EDS should be displayed only in configured desktops and hidden in others"
                );

                // For each entry template
                for (String templateName : templates) {

                    JsonObject templateObj = dcObj.getAsJsonObject(templateName);
                    if (templateObj == null) continue;

                    // 2) Entry-template visibility testcase
                    writeRow(writer,
                            "Entry template visibility validation",
                            docClass,
                            templateName,
                            "User selects this document class and switches between entry templates; verify EDS form is shown only when the configured entry template is selected.",
                            "As per the configuration entry templates for this class = " + String.join(" | ", templates),
                            "EDS should be displayed only for the selected entry template",
                            "EDS should not be displayed for other entry templates under the same document class"
                    );

                    // 3) propertyDisplayOrder
                    writeRow(writer,
                            "Properties display order validation",
                            docClass,
                            templateName,
                            "User opens the EDS form and checks the order of properties on the page from top to bottom.",
                            "As per the configuration propertyDisplayOrder = " + arrayAsCsv(templateObj, "propertyDisplayOrder"),
                            "Properties should be displayed in the same order we mentioned",
                            "Properties should be displayed in the same order we mentioned"
                    );

                    // 4) showProperties
                    writeRow(writer,
                            "Properties visibility (show/hide) validation",
                            docClass,
                            templateName,
                            "User opens the EDS form and verifies which properties are visible; hidden properties should not appear on the form.",
                            "As per the configuration showProperties = " + arrayAsCsv(templateObj, "showProperties"),
                            "Only showProperties should be displayed; remaining properties should be hidden",
                            "Properties configured should be displayed in 'showProperties'"
                    );

                    // 5) customLabelsAndDesc
                    writeRow(writer,
                            "Properties custom label and description validation",
                            docClass,
                            templateName,
                            "User opens the form and checks the label text and description (or tooltip) shown for each property that has custom label or description.",
                            "As per the configuration customLabelsAndDesc: " + labelsDescText(templateObj),
                            "Properties should show as per the label and description configured",
                            "Properties should show as per the label and description configured"
                    );

                    // 6) requiredProperties
                    writeRow(writer,
                            "Required properties validation",
                            docClass,
                            templateName,
                            "User opens the form and attempts to save or submit without filling mandatory fields; verify validation messages and that required fields are marked.",
                            "As per the configuration requiredProperties = " + arrayAsCsv(templateObj, "requiredProperties"),
                            "Properties should show as per required configured",
                            "Properties should have required mandate as per the configuration"
                    );

                    // 6a) Default values validation (template-level defaultValues)
                    if (templateObj.has("defaultValues") && templateObj.get("defaultValues").isJsonObject()) {
                        JsonObject defaultValues = templateObj.getAsJsonObject("defaultValues");
                        if (defaultValues != null && defaultValues.size() > 0) {
                            writeRow(writer,
                                    "Default values validation",
                                    docClass,
                                    templateName,
                                    "User opens a new EDS form (or navigates to this template) and checks that certain fields are already pre-filled when the form loads.",
                                    "As per the configuration defaultValues = " + clean(defaultValues.toString()),
                                    "Properties should be pre-filled with configured default values on load",
                                    "Default values should be applied as per configuration"
                            );
                        }
                    }

                    // 7) Record lookup + autocomplete behaviors (template or DC-level properties)
                    JsonObject propsObj = templateObj.getAsJsonObject("properties");
                    if (propsObj == null) propsObj = dcObj.getAsJsonObject("properties");
                    if (propsObj != null) {
                        for (String propName : propsObj.keySet()) {
                            JsonObject propCfg = propsObj.getAsJsonObject(propName);
                            if (propCfg == null) continue;

                            // We only generate autocomplete/lookup cases if queryConfig or searchConfig exists
                            JsonObject searchConfig = propCfg.getAsJsonObject("searchConfig");
                            JsonObject queryConfig  = propCfg.getAsJsonObject("queryConfig");
                            JsonObject displayCols  = propCfg.getAsJsonObject("displayColumns");
                            JsonObject fieldMaps    = propCfg.getAsJsonObject("fieldMappings");

                            if (searchConfig == null && queryConfig == null && displayCols == null && fieldMaps == null) {
                                continue;
                            }

                            // 7.1 minLength
                            if (searchConfig != null && searchConfig.has("minLength")) {
                                String minLen = safeStr(searchConfig, "minLength");
                                String placeholder = safeStr(searchConfig, "placeholder");
                                writeRow(writer,
                                        "Record lookup min length validation",
                                        docClass,
                                        templateName,
                                        "User focuses on the lookup field for '" + propName + "', types fewer than the minimum characters, then types up to the minimum; verify search runs only after the minimum number of characters is entered.",
                                        "As per the configuration minLength = " + minLen + "; placeholder = " + placeholder,
                                        "Search should trigger only after entering minimum configured characters",
                                        "Search must trigger only after entering " + minLen + " characters"
                                );
                            }

                            // 7.2 placeholder
                            if (searchConfig != null && searchConfig.has("placeholder")) {
                                String placeholder = safeStr(searchConfig, "placeholder");
                                writeRow(writer,
                                        "Record lookup placeholder validation",
                                        docClass,
                                        templateName,
                                        "User opens the form and looks at the lookup field for '" + propName + "' when it is empty; verify the hint text (placeholder) shown inside the field.",
                                        "As per the configuration placeholder = " + placeholder,
                                        "Placeholder should match configuration",
                                        "Correct placeholder should be displayed"
                                );
                            }

                            // 7.3 limit
                            if (searchConfig != null && searchConfig.has("limit")) {
                                String limit = safeStr(searchConfig, "limit");
                                writeRow(writer,
                                        "Record lookup result limit validation",
                                        docClass,
                                        templateName,
                                        "User performs a search in the lookup for '" + propName + "' that could return many rows; verify the number of results shown does not exceed the configured maximum.",
                                        "As per the configuration limit = " + limit,
                                        "Result count should not exceed configured limit",
                                        "Results should be limited as configured"
                                );
                            }

                            // 7.4 searchPattern contains/startsWith/equals
                            if (queryConfig != null && queryConfig.has("searchPattern")) {
                                String pattern = safeStr(queryConfig, "searchPattern");
                                String whereMeaning = patternMeaning(pattern);
                                writeRow(writer,
                                        "Record lookup search pattern validation",
                                        docClass,
                                        templateName,
                                        "User enters a search value in the lookup for '" + propName + "' and checks which rows are returned (e.g. contains vs starts with vs exact match).",
                                        "As per the configuration searchPattern = " + pattern,
                                        "Lookup should return results as per configured search pattern",
                                        "Results should be returned where the search value " + whereMeaning
                                );
                            }

                            // 7.5 display columns count/visibility
                            if (displayCols != null && displayCols.size() > 0) {
                                writeRow(writer,
                                        "Record lookup display columns validation",
                                        docClass,
                                        templateName,
                                        "User opens the lookup popup for '" + propName + "' and verifies which columns appear in the result list and their headers.",
                                        "As per the configuration displayColumns = " + clean(displayCols.toString()),
                                        "Popup should show only configured display columns",
                                        "Popup should show exactly the configured display columns"
                                );
                            }

                            // 7.6 fieldMappings auto-population
                            if (fieldMaps != null && fieldMaps.size() > 0) {
                                writeRow(writer,
                                        "Record lookup field mapping auto-population validation",
                                        docClass,
                                        templateName,
                                        "User selects a row from the lookup popup for '" + propName + "' and verifies that the related fields on the form are filled automatically with the correct values.",
                                        "As per the configuration fieldMappings = " + clean(fieldMaps.toString()),
                                        "On selecting a row in popup, mapped target properties should be auto-populated",
                                        "Target properties should be auto-populated as per configured fieldMappings"
                                );
                            }

                            // 7.7 Preload mode validation
                            if (propCfg.has("preloadMode")) {
                                String preloadMode = safeStr(propCfg, "preloadMode");
                                String expectedBehavior = "none".equalsIgnoreCase(preloadMode.trim())
                                        ? "No initial data load; search triggers on user input"
                                        : "top500".equalsIgnoreCase(preloadMode.trim())
                                                ? "Initial load of top 500 records (or configured limit) on focus/open"
                                                : "Preload behavior as per preloadMode: " + preloadMode;
                                writeRow(writer,
                                        "Record lookup preload mode validation",
                                        docClass,
                                        templateName,
                                        "User focuses or opens the lookup for '" + propName + "' and observes whether a list of values is loaded immediately or only after typing (search).",
                                        "As per the configuration preloadMode = " + preloadMode,
                                        "Lookup should load data as per preloadMode configuration",
                                        expectedBehavior
                                );
                            }

                            // 7.8 UI behaviour: allowClear
                            if (propCfg.has("allowClear")) {
                                String allowClear = safeStr(propCfg, "allowClear");
                                writeRow(writer,
                                        "Record lookup allowClear (clear button) validation",
                                        docClass,
                                        templateName,
                                        "User selects a value in the lookup for '" + propName + "' then looks for a clear (X) control to remove the selection; verify presence and that it clears the value.",
                                        "As per the configuration allowClear = " + allowClear,
                                        "Clear button should be shown/hidden as per configuration",
                                        "true".equalsIgnoreCase(allowClear) ? "Clear button should be visible and clear the value" : "Clear button should not be shown"
                                );
                            }

                            // 7.9 UI behaviour: allowEdit
                            if (propCfg.has("allowEdit")) {
                                String allowEdit = safeStr(propCfg, "allowEdit");
                                writeRow(writer,
                                        "Record lookup allowEdit (editable) validation",
                                        docClass,
                                        templateName,
                                        "User tries to type or change the value in the lookup field for '" + propName + "' (e.g. after selecting from list); verify whether the field accepts manual edit or is read-only.",
                                        "As per the configuration allowEdit = " + allowEdit,
                                        "Property editability should match configuration",
                                        "true".equalsIgnoreCase(allowEdit) ? "User can type/edit value manually" : "Value is read-only (selection only)"
                                );
                            }

                            // 7.10 UI behaviour: clearAfterSelection
                            if (propCfg.has("clearAfterSelection")) {
                                String clearAfterSelection = safeStr(propCfg, "clearAfterSelection");
                                writeRow(writer,
                                        "Record lookup clearAfterSelection validation",
                                        docClass,
                                        templateName,
                                        "User selects a lookup value for '" + propName + "' (so mapped fields are filled), then clears or changes the selection; verify whether the auto-filled fields clear or stay.",
                                        "As per the configuration clearAfterSelection = " + clearAfterSelection,
                                        "Behavior after selecting a lookup result should match configuration",
                                        "true".equalsIgnoreCase(clearAfterSelection) ? "Mapped fields should clear when selection is changed/cleared" : "Mapped fields should retain until explicitly changed"
                                );
                            }

                            // 7.11 Query config: filterColumns
                            if (queryConfig != null && queryConfig.has("filterColumns")) {
                                String filterCols = arrayAsCsv(queryConfig, "filterColumns");
                                writeRow(writer,
                                        "Record lookup filter columns (query config) validation",
                                        docClass,
                                        templateName,
                                        "User enters a search term in the lookup for '" + propName + "' and verifies that results are filtered by the expected database column(s) (e.g. account number, name).",
                                        "As per the configuration filterColumns = " + filterCols,
                                        "Search should apply user input to filterColumns in the query",
                                        "Query should filter on columns: " + filterCols
                                );
                            }

                            // 7.12 Query config: resultColumns
                            if (queryConfig != null && queryConfig.has("resultColumns")) {
                                String resultCols = arrayAsCsv(queryConfig, "resultColumns");
                                writeRow(writer,
                                        "Record lookup result columns (query config) validation",
                                        docClass,
                                        templateName,
                                        "User runs a lookup search for '" + propName + "' and verifies that the result set includes the expected columns (data available for display and mapping).",
                                        "As per the configuration resultColumns = " + resultCols,
                                        "Query result should contain exactly the configured result columns",
                                        "Result set should include columns: " + resultCols
                                );
                            }

                            // 7.13 Field mapping: dataType, cardinality, separator
                            if (fieldMaps != null && fieldMaps.size() > 0) {
                                String mappingDetails = fieldMappingDetails(fieldMaps);
                                writeRow(writer,
                                        "Record lookup field mapping dataType and cardinality validation",
                                        docClass,
                                        templateName,
                                        "User selects a lookup row for '" + propName + "' and checks that each mapped form field gets the correct type (e.g. text, date), single vs multi-value, and that multi-value fields use the correct separator.",
                                        "As per the configuration field mappings (dataType, cardinality, separator): " + mappingDetails,
                                        "SINGLE fields get one value; MULTI fields get concatenated values with configured separator",
                                        "Data types and cardinality (SINGLE/MULTI) and separator for MULTI should match configuration"
                                );
                            }
                        }
                    }
                }
            }
        }

        System.out.println("CSV generated successfully: " + csvPath);
    }

    // ---------------- CSV helpers ----------------

    private static void writeRow(
            PrintWriter writer,
            String testCaseType,
            String docClass,
            String entryTemplate,
            String inputScenario,
            String inputValues,
            String outputScenario,
            String expectedResult
    ) {
        writer.println(csv(
                String.format("TC%05d", COUNTER.getAndIncrement()),
                docClass,
                entryTemplate,
                testCaseType,
                inputScenario,
                inputValues,
                outputScenario,
                expectedResult,
                "Same with expected Results",
                "Completed",
                "Success",
                ""
        ));
    }

    private static String csv(String... values) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < values.length; i++) {
            sb.append("\"")
              .append(values[i] == null ? "" : values[i].replace("\"", "\"\""))
              .append("\"");
            if (i < values.length - 1) sb.append(",");
        }
        return sb.toString();
    }

    // ---------------- JSON helpers ----------------

    private static String arrayAsCsv(JsonObject obj, String key) {
        if (obj == null || !obj.has(key) || obj.get(key).isJsonNull()) return "Not configured";
        JsonArray arr = obj.getAsJsonArray(key);
        if (arr == null || arr.size() == 0) return "Not configured";
        List<String> out = new ArrayList<>();
        for (JsonElement e : arr) {
            if (e != null && !e.isJsonNull()) out.add(e.getAsString());
        }
        return String.join(",", out);
    }

    private static String labelsDescText(JsonObject templateObj) {
        JsonObject cld = templateObj.getAsJsonObject("customLabelsAndDesc");
        if (cld == null) return "No custom labels exist. No custom descriptions exist.";

        JsonObject labels = cld.getAsJsonObject("labels");
        JsonObject desc   = cld.getAsJsonObject("desc");

        String labelsText = (labels != null && labels.size() > 0)
                ? "Labels: " + clean(labels.toString())
                : "No custom labels exist.";

        String descText = (desc != null && desc.size() > 0)
                ? "Descriptions: " + clean(desc.toString())
                : "No custom descriptions exist.";

        return labelsText + " " + descText;
    }

    private static String safeStr(JsonObject obj, String key) {
        if (obj == null || !obj.has(key) || obj.get(key).isJsonNull()) return "Not configured";
        JsonElement el = obj.get(key);
        if (el.isJsonPrimitive()) return el.getAsString();
        return clean(el.toString());
    }

    private static String clean(String s) {
        if (s == null) return "";
        return s.replace("\r", " ").replace("\n", " ").replace("\"", "");
    }

    private static String patternMeaning(String pattern) {
        if (pattern == null) return "matches configured rule";
        switch (pattern.trim().toLowerCase()) {
            case "contains":   return "is contained in the search column values (LIKE %value%)";
            case "startswith": return "starts with the search value (LIKE value%)";
            case "equals":     return "exactly equals the search value (= value)";
            default:           return "matches configured rule (" + pattern + ")";
        }
    }

    /** Builds a short description of fieldMappings: source -> target (dataType, cardinality, separator). */
    private static String fieldMappingDetails(JsonObject fieldMaps) {
        if (fieldMaps == null || fieldMaps.size() == 0) return "Not configured";
        List<String> parts = new ArrayList<>();
        for (String key : fieldMaps.keySet()) {
            JsonObject m = fieldMaps.getAsJsonObject(key);
            if (m == null) continue;
            String target = safeStr(m, "targetProperty");
            String dataType = safeStr(m, "dataType");
            String card = safeStr(m, "cardinality");
            String sep = m.has("separator") ? " separator=" + safeStr(m, "separator") : "";
            parts.add(key + "->" + target + "(" + dataType + "," + card + sep + ")");
        }
        return String.join("; ", parts);
    }
}
