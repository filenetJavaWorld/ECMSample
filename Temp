-- VERIFY THIS INDEX EXISTS:
SELECT * FROM sys.indexes 
WHERE object_id = OBJECT_ID('Wawa_DMS_Conversion_UAT.[dbo].[Wawa_Doc_Migration_Transit_Data]')
AND name LIKE '%externalID%';

-- IF NOT EXISTS, CREATE IT:
CREATE NONCLUSTERED INDEX idx_externalID 
ON [Wawa_DMS_Conversion_UAT].[dbo].[Wawa_Doc_Migration_Transit_Data](externalID);

package com.wawanesa.ace.merge.utils;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.wawanesa.ace.merge.configuration.PropertiesConfigLoader;
import com.wawanesa.ace.merge.connection.ConnectionManager;
import com.wawanesa.ace.merge.constants.Constants;
import com.wawanesa.ace.merge.model.ClaimCenterDocumentDTO;

/**
 * Utility class for processing ClaimCenter CSV extracts and updating database records
 */
public class Utils {
    
    private static final Logger logger = LogManager.getLogger(Utils.class);
    
    private PropertiesConfigLoader config;
    private ConnectionManager connectionManager;
    private String basePath;
    private String dbTableName;
    private String updateMergeQuery;
    
    public Utils(PropertiesConfigLoader config, ConnectionManager connectionManager) {
        this.config = config;
        this.connectionManager = connectionManager;
        this.basePath = config.getProperty("app.base_path");
        this.dbTableName = config.getProperty("db.staging.claimcenterdbtable");
        
        // Load SQL query from properties and replace table name placeholder
        String queryTemplate = config.getProperty("db.query.update.merge");
        this.updateMergeQuery = queryTemplate.replace("%TABLE_NAME%", this.dbTableName);
    }
    
    /**
     * Inner class to track processing results
     * Made public for GlobalProcessingReport integration
     */
    public static class ProcessingResult {
        public int totalRows = 0;
        public int successCount = 0;
        public int failureCount = 0;
        public int skippedEmptyLines = 0;
    }
    
    /**
     * Process a single CSV file from Input folder
     * Returns ProcessingResult for global reporting
     */
    public ProcessingResult processCSVFile(Path csvFilePath) {
        String csvFileName = csvFilePath.getFileName().toString();
        logger.info("===== Starting processing of CSV file: {} =====", csvFileName);
        
        Path inprogressDir = Paths.get(basePath, Constants.INPROGRESS_FOLDER);
        Path inprogressFile = inprogressDir.resolve(csvFileName);
        
        try {
            // Step 1: Move file to Inprogress folder
            logger.info("Moving {} to Inprogress folder", csvFileName);
            Files.move(csvFilePath, inprogressFile, StandardCopyOption.REPLACE_EXISTING);
            logger.info("File moved to: {}", inprogressFile);
            
            // Step 2: Process the CSV file
            ProcessingResult result = processCSVWithTracking(inprogressFile);
            
            // Step 3: Handle file lifecycle based on results
            handleFileLifecycle(inprogressFile, result);
            
            logger.info("===== Completed processing of CSV file: {} =====", csvFileName);
            logger.info("Total Rows: {}, Success: {}, Failed: {}, Empty Lines Skipped: {}", 
                       result.totalRows, result.successCount, result.failureCount, result.skippedEmptyLines);
            
            return result;
            
        } catch (Exception e) {
            logger.error("Critical error processing CSV file: {}", csvFileName, e);
            // Move to Failed folder on critical error
            try {
                Path failedDir = Paths.get(basePath, Constants.FAILED_FOLDER);
                Path failedFile = failedDir.resolve(csvFileName);
                Files.move(inprogressFile, failedFile, StandardCopyOption.REPLACE_EXISTING);
                
                // Create error log file
                createErrorLogFile(failedDir, csvFileName, "Critical processing error: " + e.getMessage());
                
            } catch (IOException ioe) {
                logger.error("Failed to move file to Failed folder: {}", csvFileName, ioe);
            }
            
            // Return empty result on critical error
            return new ProcessingResult();
        }
    }
    
    /**
     * Process CSV file with row-level tracking
     */
    private ProcessingResult processCSVWithTracking(Path csvFilePath) throws IOException {
        ProcessingResult result = new ProcessingResult();
        String csvFileName = csvFilePath.getFileName().toString();
        
        // Prepare output files for success and failure tracking
        Path completedDir = Paths.get(basePath, Constants.COMPLETED_FOLDER);
        Path failedDir = Paths.get(basePath, Constants.FAILED_FOLDER);
        
        String baseFileName = csvFileName.replace(".csv", "");
        Path successFile = completedDir.resolve(baseFileName + "_SUCCESS.csv");
        Path failedFile = failedDir.resolve(baseFileName + "_FAILED.csv");
        
        List<String> successRows = new ArrayList<>();
        List<String> failedRows = new ArrayList<>();
        
        String skipHeaderProp = config.getProperty("app.skipHeaderRow");
        boolean skipHeaderRow = skipHeaderProp == null ? true : Boolean.parseBoolean(skipHeaderProp);
        String headerLine = null;
        
        // Get batch size from configuration
        String batchSizeStr = config.getProperty("db.batch.update.size");
        int batchSize = (batchSizeStr != null) ? Integer.parseInt(batchSizeStr) : 1000;
        
        logger.info("Processing CSV file: {}", csvFilePath);
        logger.info("Delimiter: pipe (|), Skip header: {}, Batch size: {}", skipHeaderRow, batchSize);
        
        Connection conn = null;
        try (BufferedReader reader = new BufferedReader(new FileReader(csvFilePath.toFile()))) {
            
            conn = connectionManager.getConnection();
            
            String line;
            int rowNum = 0;
            
            // Read and process header
            if (skipHeaderRow && (line = reader.readLine()) != null) {
                headerLine = line.trim();
                logger.debug("Header: {}", headerLine);
            }
            
            // Build header index map
            Map<String, Integer> headerIndex = buildHeaderIndex(headerLine);
            
            // Validate required columns exist
            if (!validateRequiredColumns(headerIndex, csvFileName)) {
                result.failureCount = 1;
                return result;
            }
            
            // Batch processing buffers
            List<ClaimCenterDocumentDTO> batchDTOs = new ArrayList<>();
            List<String> batchLines = new ArrayList<>();
            
            // Process each row
            while ((line = reader.readLine()) != null) {
                rowNum++;
                
                // Skip empty lines
                if (line.trim().length() == 0) {
                    result.skippedEmptyLines++;
                    continue;
                }
                
                result.totalRows++;
                String currentLine = line;
                
                try {
                    // Parse CSV row
                    String[] cells = parseCSVLine(line);
                    
                    // Build DTO from CSV row
                    ClaimCenterDocumentDTO dto = buildDTOFromCSV(cells, headerIndex, csvFileName);
                    
                    dto.setDataMerged(true);
                    
                    // Validate DTO
                    validateDTO(dto, rowNum);
                    
                    // Add to batch
                    batchDTOs.add(dto);
                    batchLines.add(currentLine);
                    
                    // Process batch when it reaches batch size
                    if (batchDTOs.size() >= batchSize) {
                        processBatchWithFallback(batchDTOs, batchLines, conn, batchSize, 
                                               successRows, failedRows, result);
                        batchDTOs.clear();
                        batchLines.clear();
                        
                        logger.debug("Processed batch at row {}", rowNum);
                    }
                    
                } catch (Exception e) {
                    result.failureCount++;
                    String errorMsg = e.getMessage().replace("\"", "'").replace("|", ";");
                    failedRows.add(currentLine + "|" + errorMsg);
                    logger.error("Row {}: Failed to process - {}", rowNum, e.getMessage());
                }
            }
            
            // Process remaining batch
            if (!batchDTOs.isEmpty()) {
                processBatchWithFallback(batchDTOs, batchLines, conn, batchSize, 
                                       successRows, failedRows, result);
                logger.debug("Processed final batch of {} rows", batchDTOs.size());
            }
            
            // Commit all successful transactions
            conn.commit();
            logger.info("Transaction committed successfully");
            
            logger.info("CSV processing completed: Total={}, Success={}, Failed={}, Skipped Empty={}", 
                       result.totalRows, result.successCount, result.failureCount, result.skippedEmptyLines);
            
        } catch (SQLException e) {
            logger.error("Database error while processing CSV: {}", csvFileName, e);
            // Rollback on error
            if (conn != null) {
                try {
                    conn.rollback();
                    logger.warn("Transaction rolled back due to error");
                } catch (SQLException rollbackEx) {
                    logger.error("Error during rollback", rollbackEx);
                }
            }
            throw new IOException("Database error: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Unexpected error while processing CSV: {}", csvFileName, e);
            // Rollback on error
            if (conn != null) {
                try {
                    conn.rollback();
                    logger.warn("Transaction rolled back due to error");
                } catch (SQLException rollbackEx) {
                    logger.error("Error during rollback", rollbackEx);
                }
            }
            throw new IOException("Processing error: " + e.getMessage(), e);
        } finally {
            // Close connection
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException closeEx) {
                    logger.error("Error closing connection", closeEx);
                }
            }
        }
        
        // Write success file
        if (!successRows.isEmpty()) {
            writeSuccessFile(successFile, headerLine, successRows);
            logger.info("Created success file with {} rows: {}", successRows.size(), successFile);
        }
        
        // Write failed file (only if there are failures)
        if (!failedRows.isEmpty()) {
            writeFailedFile(failedFile, headerLine, failedRows);
            logger.info("Created failed file with {} rows: {}", failedRows.size(), failedFile);
        }
        
        return result;
    }
    
    /**
     * Build header index map for CSV columns
     */
    private Map<String, Integer> buildHeaderIndex(String headerLine) {
        Map<String, Integer> index = new HashMap<>();
        if (headerLine == null || headerLine.trim().isEmpty()) {
            return index;
        }
        
        String[] headers = headerLine.split("\\|", -1);
        for (int i = 0; i < headers.length; i++) {
            String header = headers[i].trim().replace("\"", "");
            index.put(header, i);
        }
        
        logger.debug("Header index built with {} columns", index.size());
        return index;
    }
    
    /**
     * Validate that all required columns exist in CSV
     */
    private boolean validateRequiredColumns(Map<String, Integer> headerIndex, String csvFileName) {
    	// NAME|DOCUMENT_TYPE|CLAIM_NUMBER|POLICY_NUMBER|DOCUMENT_SUBTYPE|AUTHOR|DOCUMENT_DESCRIPTION|STATUS|EXTERNALID|ID|CLAIMID
    	String[] requiredColumns = {
    	    "NAME", "DOCUMENT_TYPE", "CLAIM_NUMBER", "POLICY_NUMBER", "DOCUMENT_SUBTYPE",
    	    "AUTHOR", "DOCUMENT_DESCRIPTION", "STATUS", "EXTERNALID", "ID", "CLAIMID"
    	};
        
        List<String> missingColumns = new ArrayList<>();
        for (String col : requiredColumns) {
            if (!headerIndex.containsKey(col)) {
                missingColumns.add(col);
            }
        }
        
        if (!missingColumns.isEmpty()) {
            logger.error("CSV file {} is missing required columns: {}", csvFileName, missingColumns);
            return false;
        }
        
        return true;
    }
    
    /**
     * Parse CSV line handling pipe delimiter
     */
    private String[] parseCSVLine(String line) {
        // Simple split by pipe - handles basic CSV
        return line.split("\\|", -1);
    }
    
    /**
     * Build DTO from CSV row
     */
    private ClaimCenterDocumentDTO buildDTOFromCSV(String[] cells, Map<String, Integer> headerIndex, String csvFileName) {
        ClaimCenterDocumentDTO dto = new ClaimCenterDocumentDTO();

        // NAME|DOCUMENT_TYPE|CLAIM_NUMBER|POLICY_NUMBER|DOCUMENT_SUBTYPE|AUTHOR|DOCUMENT_DESCRIPTION|STATUS|EXTERNALID|ID|CLAIMID
        dto.setDocumentTitle(safeTrim(getCell(cells, headerIndex.get("NAME"))));
        dto.setDocumentType(safeTrim(getCell(cells, headerIndex.get("DOCUMENT_TYPE"))));
        dto.setClaimNumber(safeTrim(getCell(cells, headerIndex.get("CLAIM_NUMBER"))));
        dto.setPolicyNumber(safeTrim(getCell(cells, headerIndex.get("POLICY_NUMBER"))));
        dto.setDocumentSubtype(safeTrim(getCell(cells, headerIndex.get("DOCUMENT_SUBTYPE"))));
        dto.setAuthor(safeTrim(getCell(cells, headerIndex.get("AUTHOR"))));
        dto.setDocumentDescription(safeTrim(getCell(cells, headerIndex.get("DOCUMENT_DESCRIPTION"))));
        dto.setClaimType(safeTrim(getCell(cells, headerIndex.get("STATUS"))));
        dto.setExternalID(safeTrim(getCell(cells, headerIndex.get("EXTERNALID"))));
        dto.setGwDocumentID(safeTrim(getCell(cells, headerIndex.get("ID"))));
        dto.setClaimID(safeTrim(getCell(cells, headerIndex.get("CLAIMID"))));
        dto.setCsvFileName(csvFileName);

        return dto;
    }

    
    /**
     * Validate DTO has required fields
     */
    private void validateDTO(ClaimCenterDocumentDTO dto, int rowNum) throws Exception {
        if (dto.getExternalID() == null || dto.getExternalID().trim().isEmpty()) {
            throw new Exception("Missing required field: externalID");
        }
    }
    
    /**
     * Update database record matching externalID
     */
    private int updateDatabaseRecord(ClaimCenterDocumentDTO dto, Connection conn) throws SQLException {
        // NAME|DOCUMENT_TYPE|CLAIM_NUMBER|POLICY_NUMBER|DOCUMENT_SUBTYPE|AUTHOR|DOCUMENT_DESCRIPTION|STATUS|EXTERNALID|ID|CLAIMID
        try (PreparedStatement pstmt = conn.prepareStatement(updateMergeQuery)) {
        	 pstmt.setString(1, dto.getDocumentTitle());
             pstmt.setString(2, dto.getDocumentType());
             pstmt.setString(3, dto.getDocumentSubtype());
             //pstmt.setLong(4, Long.parseLong(dto.getClaimID()));
             pstmt.setString(4, dto.getClaimNumber());
             pstmt.setString(5, dto.getPolicyNumber());
             pstmt.setString(6, dto.getAuthor());
             pstmt.setString(7, dto.getDocumentDescription());
             pstmt.setString(8, dto.getClaimType());
             pstmt.setString(9, dto.getGwDocumentID());
             pstmt.setBoolean(10, true);
             pstmt.setString(11, dto.getCsvFileName());
             pstmt.setTimestamp(12, Timestamp.valueOf(LocalDateTime.now().truncatedTo(ChronoUnit.MILLIS)));
             pstmt.setString(13, dto.getExternalID());

            System.out.println("UPDATE SQL executed: rows affected for externalID=" + dto.getExternalID());
            int rowsUpdated = pstmt.executeUpdate();

            if (logger.isDebugEnabled()) {
                logger.debug("UPDATE SQL executed: {} rows affected for externalID={}", rowsUpdated, dto.getExternalID());
            }

            return rowsUpdated;
        }
    }
    
    /**
     * Update multiple database records using JDBC batch processing
     * Significantly faster than individual UPDATEs for large datasets
     * 
     * @param dtoList List of DTOs to update
     * @param conn Database connection
     * @param batchSize Maximum batch size
     * @return Number of rows successfully updated
     */
    private int updateDatabaseRecordsBatch(List<ClaimCenterDocumentDTO> dtoList, Connection conn, int batchSize) 
            throws SQLException {
        
        if (dtoList == null || dtoList.isEmpty()) {
            return 0;
        }
        
        int totalUpdated = 0;
        
        try (PreparedStatement pstmt = conn.prepareStatement(updateMergeQuery)) {
            int batchCount = 0;
            
            for (ClaimCenterDocumentDTO dto : dtoList) {
                pstmt.setString(1, dto.getDocumentTitle());
                pstmt.setString(2, dto.getDocumentType());
                pstmt.setString(3, dto.getDocumentSubtype());
                //pstmt.setLong(4, Long.parseLong(dto.getClaimID()));
                pstmt.setString(4, dto.getClaimNumber());
                pstmt.setString(5, dto.getPolicyNumber());
                pstmt.setString(6, dto.getAuthor());
                pstmt.setString(7, dto.getDocumentDescription());
                pstmt.setString(8, dto.getClaimType());
                pstmt.setString(9, dto.getGwDocumentID());
                pstmt.setBoolean(10, true);
                pstmt.setString(11, dto.getCsvFileName());
                pstmt.setTimestamp(12, Timestamp.valueOf(LocalDateTime.now().truncatedTo(ChronoUnit.MILLIS)));
                pstmt.setString(13, dto.getExternalID());
                
                pstmt.addBatch();
                batchCount++;
                
                // Execute batch when reaching batch size
                if (batchCount >= batchSize) {
                    int[] updateCounts = pstmt.executeBatch();
                    totalUpdated += countSuccessfulUpdates(updateCounts);
                    batchCount = 0;
                    
                    logger.debug("Executed batch of {} updates", batchSize);
                }
            }
            
            // Execute remaining batch
            if (batchCount > 0) {
                int[] updateCounts = pstmt.executeBatch();
                totalUpdated += countSuccessfulUpdates(updateCounts);
                
                logger.debug("Executed final batch of {} updates", batchCount);
            }
            
            logger.info("Batch UPDATE completed: {} records updated from {} DTOs", totalUpdated, dtoList.size());
            
            return totalUpdated;
        }
    }
    
    /**
     * Count successful updates from batch execution results
     */
    private int countSuccessfulUpdates(int[] updateCounts) {
        int count = 0;
        for (int updateCount : updateCounts) {
            if (updateCount > 0) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Process a batch of DTOs with fallback to individual processing on failure
     */
    private void processBatchWithFallback(List<ClaimCenterDocumentDTO> dtoList,
                                          List<String> linesList,
                                          Connection conn,
                                          int batchSize,
                                          List<String> successRows,
                                          List<String> failedRows,
                                          ProcessingResult result) throws SQLException {
        
        if (dtoList.isEmpty()) {
            return;
        }
        
        try {
            // Attempt batch UPDATE
            int successCount = updateDatabaseRecordsBatch(dtoList, conn, batchSize);
            
            // Commit after batch
            conn.commit();
            logger.debug("Batch committed: {} records", successCount);
            
            // If all records updated successfully, add to success rows
            if (successCount == dtoList.size()) {
                successRows.addAll(linesList);
                result.successCount += successCount;
                logger.debug("Batch UPDATE successful: {}/{} records", successCount, dtoList.size());
            } else {
                // Partial success - some records didn't exist in DB (externalID not found)
                // Since updates are atomic, we still committed what worked
                // Log this as a warning but don't fall back - batch updates already succeeded
                logger.warn("Batch UPDATE partial match: {}/{} records updated (some externalIDs not found in DB)", 
                           successCount, dtoList.size());
                
                // For tracking purposes, add successful updates to success list
                // Note: We can't identify which specific records failed in batch mode
                // This is a trade-off for performance
                successRows.addAll(linesList);
                result.successCount += successCount;
                result.failureCount += (dtoList.size() - successCount);
                
                // Add note to failed rows about unmatched externalIDs
                int unmatchedCount = dtoList.size() - successCount;
                if (unmatchedCount > 0) {
                    String warningMsg = String.format("Batch contained %d record(s) with externalID not found in database", unmatchedCount);
                    logger.warn(warningMsg);
                }
            }
            
        } catch (SQLException e) {
            // Batch failed - rollback and fall back to individual processing
            logger.warn("Batch UPDATE failed, rolling back and falling back to individual processing: {}", e.getMessage());
            conn.rollback();
            processBatchIndividually(dtoList, linesList, conn, successRows, failedRows, result);
            // Commit individual updates
            conn.commit();
        }
    }
    
    /**
     * Process DTOs individually (fallback method)
     */
    private void processBatchIndividually(List<ClaimCenterDocumentDTO> dtoList,
                                         List<String> linesList,
                                         Connection conn,
                                         List<String> successRows,
                                         List<String> failedRows,
                                         ProcessingResult result) {
        
        for (int i = 0; i < dtoList.size(); i++) {
            ClaimCenterDocumentDTO dto = dtoList.get(i);
            String line = linesList.get(i);
            
            try {
                int rowsUpdated = updateDatabaseRecord(dto, conn);
                
                if (rowsUpdated > 0) {
                    result.successCount++;
                    successRows.add(line);
                } else {
                    result.failureCount++;
                    String errorMsg = "No record found with externalID=" + dto.getExternalID();
                    failedRows.add(line + "|" + errorMsg);
                    logger.warn("No record found for externalID={}", dto.getExternalID());
                }
                
            } catch (Exception e) {
                result.failureCount++;
                String errorMsg = e.getMessage().replace("\"", "'").replace("|", ";");
                failedRows.add(line + "|" + errorMsg);
                logger.error("Failed to update externalID={}: {}", dto.getExternalID(), e.getMessage());
            }
        }
    }

    
    /**
     * Write success rows to file
     */
    private void writeSuccessFile(Path successFile, String headerLine, List<String> successRows) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(successFile.toFile()))) {
            // Write header
            if (headerLine != null) {
                writer.write(headerLine);
                writer.newLine();
            }
            
            // Write success rows
            for (String row : successRows) {
                writer.write(row);
                writer.newLine();
            }
        }
    }
    
    /**
     * Write failed rows to file with error messages
     */
    private void writeFailedFile(Path failedFile, String headerLine, List<String> failedRows) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(failedFile.toFile()))) {
            // Write header with error_message column
            if (headerLine != null) {
                writer.write(headerLine + "|error_message");
                writer.newLine();
            }
            
            // Write failed rows (already have error message appended)
            for (String row : failedRows) {
                writer.write(row);
                writer.newLine();
            }
        }
    }
    
    /**
     * Handle file lifecycle after processing
     */
    private void handleFileLifecycle(Path inprogressFile, ProcessingResult result) throws IOException {
        String csvFileName = inprogressFile.getFileName().toString();
        String archiveProp = config.getProperty("app.archive.after.processing");
        boolean archiveAfterProcessing = archiveProp == null ? true : Boolean.parseBoolean(archiveProp);
        
        if (archiveAfterProcessing) {
            // Move to Archive folder
            Path archiveDir = Paths.get(basePath, Constants.ARCHIVE_FOLDER);
            Path archiveFile = archiveDir.resolve(csvFileName);
            
            Files.move(inprogressFile, archiveFile, StandardCopyOption.REPLACE_EXISTING);
            logger.info("Moved processed file to Archive: {}", archiveFile);
        } else {
            // Delete the file
            Files.delete(inprogressFile);
            logger.info("Deleted processed file from Inprogress: {}", csvFileName);
        }
    }
    
    /**
     * Create error log file for critical failures
     */
    private void createErrorLogFile(Path directory, String csvFileName, String errorMessage) {
        try {
            String baseFileName = csvFileName.replace(".csv", "");
            Path errorLogFile = directory.resolve(baseFileName + "_error.log");
            
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(errorLogFile.toFile()))) {
                writer.write("Error processing file: " + csvFileName);
                writer.newLine();
                writer.write("Timestamp: " + java.time.LocalDateTime.now());
                writer.newLine();
                writer.write("Error: " + errorMessage);
                writer.newLine();
            }
            
            logger.info("Created error log file: {}", errorLogFile);
        } catch (IOException e) {
            logger.error("Failed to create error log file for {}", csvFileName, e);
        }
    }
    
    /**
     * Safe trim utility
     */
    private String safeTrim(String value) {
        if (value == null) return "";
        String trimmed = value.trim();
        // Handle "null" string as empty
        if (trimmed.equalsIgnoreCase("null")) return "";
        return trimmed;
    }
    
    /**
     * Safe get cell from array
     */
    private String getCell(String[] cells, Integer index) {
        if (index == null || index < 0 || index >= cells.length) {
            return "";
        }
        return cells[index];
    }
}

