define([
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/dom-class",
	"dojo/dom-style",
	"dojo/dom-construct",
	"dojo/dom-attr",
	"dojo/on",
	"dojo/query",
	"dojo/date/locale",
	"dijit/registry",
	"dijit/form/ValidationTextBox",
	"dijit/form/DateTextBox",
	"dijit/form/Button",
	"idx/layout/BorderContainer",
	"dijit/layout/ContentPane",
	"ecm/model/Request",
	"ecm/model/ResultSet",
	"ecm/widget/layout/_LaunchBarPane",
	"ecm/widget/layout/_RepositorySelectorMixin",
	"ecm/widget/listView/ContentList",
	"ecm/widget/listView/gridModules/RowContextMenu",
	"ecm/widget/listView/gridModules/DndRowMoveCopy",
	"ecm/widget/listView/gridModules/DndFromDesktopAddDoc",
	"ecm/widget/listView/modules/Toolbar2",
	"ecm/widget/listView/modules/DocInfo",
	"ecm/widget/listView/modules/Bar",
	"ecm/widget/listView/modules/ViewDetail",
	"ecm/widget/listView/modules/ViewMagazine",
	"dojo/text!./templates/MultiRepoSearchFeature.html"
],
function(declare, lang, array, domClass, domStyle, domConstruct, domAttr, on, query,
		dateLocale, registry, ValidationTextBox, DateTextBox, Button, idxBorderContainer, ContentPane,
		Request, ResultSet, _LaunchBarPane, _RepositorySelectorMixin, ContentList, RowContextMenu, DndRowMoveCopy, DndFromDesktopAddDoc, Toolbar,
		DocInfo, Bar, ViewDetail, ViewMagazine, template) {

	/**
	 * @name cNBMultiRepoSearchPluginDojo.MultiRepoSearchFeature
	 * @class Multi-repository search feature pane with dynamic search fields
	 * and aggregated results from multiple P8 object stores.
	 * @augments ecm.widget.layout._LaunchBarPane, ecm.widget.layout._RepositorySelectorMixin
	 */
	return declare("cNBMultiRepoSearchPluginDojo.MultiRepoSearchFeature", [
		_LaunchBarPane,
		_RepositorySelectorMixin
	], {
		/** @lends cNBMultiRepoSearchPluginDojo.MultiRepoSearchFeature.prototype */

		templateString: template,
		widgetsInTemplate: true,

		// Configuration loaded from server
		_config: null,
		
		// Dynamic field widgets
		_fieldWidgets: {},
		
		// Pagination state (using ICN continuation tokens)
		_pageSize: 50,
		_isLoading: false,

		postCreate: function() {
			this.logEntry("postCreate");
			this.inherited(arguments);
			
			console.log("[MultiRepoSearchFeature] *** VERSION 2.1 LOADED - Document properties and context menu fix ***");
			
			// Set up result list
			domAttr.set(this.searchResults.domNode, "role", "region");
			domAttr.set(this.searchResults.domNode, "aria-label", "Search Results");
			this.searchResults.setContentListModules(this._getContentListModules());
			this.searchResults.setGridExtensionModules(this._getGridModules());
			
			// Initialize repository selector from _RepositorySelectorMixin
			// This is CRITICAL for context menu and document properties to work
			this.defaultLayoutRepositoryComponent = "others";
			this.setRepositoryTypes("p8");  // We only support P8 repositories
			this.createRepositorySelector();
			this.doRepositorySelectorConnections();
			
			// ICN handles infinite scroll automatically via ResultSet.retrieveNextPage()
			
			this.logExit("postCreate");
		},
		
		/**
		 * Loads the content of the pane.
		 */
		loadContent: function() {
			this.logEntry("loadContent");
			
			// Initialize repository from _RepositorySelectorMixin
			if (!this.repository) {
				this.setPaneDefaultLayoutRepository();
			}
			
			if (!this.isLoaded) {
				this._loadConfiguration();
				this.isLoaded = true;
				this.needReset = false;
			}
			
			this.logExit("loadContent");
		},
		
		/**
		 * Sets the repository being used for search.
		 * Called by _RepositorySelectorMixin when repository changes.
		 * 
		 * @param repository
		 *            An instance of {@link ecm.model.Repository}
		 */
		setRepository: function(repository) {
			this.repository = repository;
			console.log("[MultiRepoSearchFeature] Repository set to: " + (repository ? repository.id : "null"));
			if (this.repositorySelector && this.repository) {
				this.repositorySelector.getDropdown().set("value", this.repository.id);
			}
			// Clear previous results when repository changes
			this._doClear();
		},

		/**
		 * Loads configuration from the server and builds dynamic UI.
		 */
		_loadConfiguration: function() {
			var self = this;
			console.log("test test");
			this._showLoading(true);
			
			Request.invokePluginService("CNBMultiRepoSearchPlugin", "multiRepoSearchService", {
				requestParams: {
					action_Type: "getConfiguration"
				},
				requestCompleteCallback: lang.hitch(this, function(response) {
					self._showLoading(false);
					
					if (response && response.success && response.configuration) {
						self._config = response.configuration;
						self._buildSearchForm();
						self._setupResultColumns();
					} else {
						self._showError("Failed to load configuration");
					}
				}),
				requestFailedCallback: lang.hitch(this, function(error) {
					self._showLoading(false);
					self._showError("Error loading configuration: " + error.message);
				})
			});
		},

		/**
		 * Builds dynamic search form fields based on configuration.
		 */
		_buildSearchForm: function() {
			var self = this;
			var container = this.searchFieldsContainer;
			
			// Clear existing fields
			domConstruct.empty(container);
			this._fieldWidgets = {};
			
			if (!this._config || !this._config.searchFields) {
				return;
			}
			
			array.forEach(this._config.searchFields, function(field) {
				var fieldRow = domConstruct.create("div", {
					"class": "cnb-search-field-row"
				}, container);
				
				// Label
				domConstruct.create("label", {
					"class": "cnb-search-label",
					"for": "cnb_field_" + field.fieldId,
					innerHTML: field.fieldLabel + (field.required ? " <span class='cnb-required'>*</span>" : "")
				}, fieldRow);
				
				// Input container
				var inputContainer = domConstruct.create("div", {
					"class": "cnb-search-input"
				}, fieldRow);
				
				// Create appropriate widget based on field type
				var widget;
				var fieldType = (field.fieldType || "string").toLowerCase();
				
				if (fieldType === "date") {
					// Use Dojo DateTextBox
					widget = new DateTextBox({
						id: "cnb_field_" + field.fieldId,
						name: field.fieldId,
						required: field.required || false,
						style: "width: 100%;",
						constraints: { datePattern: "yyyy-MM-dd" },
						promptMessage: field.placeholder || "Select a date",
						invalidMessage: "Please enter a valid date"
					});
				} else if (fieldType === "integer" || fieldType === "number") {
					// Use ValidationTextBox for numbers
					widget = new ValidationTextBox({
						id: "cnb_field_" + field.fieldId,
						name: field.fieldId,
						required: field.required || false,
						style: "width: 100%;",
						placeHolder: field.placeholder || "",
						regExp: "\\d*",
						invalidMessage: "Please enter a valid number",
						trim: true
					});
				} else {
					// Default: ValidationTextBox for strings
					widget = new ValidationTextBox({
						id: "cnb_field_" + field.fieldId,
						name: field.fieldId,
						required: field.required || false,
						style: "width: 100%;",
						placeHolder: field.placeholder || "",
						trim: true
					});
				}
				
				widget.placeAt(inputContainer);
				widget.startup();
				
				// Enable search on Enter key
				on(widget.domNode, "keypress", function(evt) {
					if (evt.keyCode === 13) {
						self._doSearch();
					}
				});
				
				self._fieldWidgets[field.fieldId] = widget;
			});
			
			// Update repository info
			this._updateRepositoryInfo();
		},

		/**
		 * Updates the repository info display.
		 */
		_updateRepositoryInfo: function() {
			if (!this._config || !this._config.repositories) {
				return;
			}
			
			var repoNames = array.map(this._config.repositories, function(repo) {
				return repo.repoName;
			});
			
			if (this.repoInfoText) {
				this.repoInfoText.innerHTML = "Searching: " + repoNames.join(", ");
			}
		},

		/**
		 * Sets up result grid columns based on configuration.
		 */
		_setupResultColumns: function() {
			// Result columns are configured through the ContentList modules
			// The actual column definitions come from the search results
		},

		/**
		 * Returns grid extension modules for the content list.
		 * Includes DnD support and context menu for full document actions.
		 */
		_getGridModules: function() {
			var array = [];
			array.push(DndRowMoveCopy);
			array.push(DndFromDesktopAddDoc);
			array.push(RowContextMenu);
			return array;
		},

		/**
		 * Returns content list modules.
		 */
		_getContentListModules: function() {
			var viewModules = [ViewDetail, ViewMagazine];
			
			return [
				DocInfo,
				{
					moduleClass: Bar,
					top: [
						[
							[
								{ moduleClass: Toolbar },
								{ moduleClasses: viewModules, "className": "BarViewModules" }
							]
						]
					]
				}
			];
		},

		/**
		 * Sets up infinite scroll - ICN handles this automatically via ResultSet.retrieveNextPage()
		 * We just need to override retrieveNextPage to call our plugin service.
		 */
		_setupInfiniteScroll: function() {
			// ICN's ContentList automatically handles infinite scroll
			// We override ResultSet.retrieveNextPage() to call our plugin service
		},

		/**
		 * Performs the search.
		 */
		_doSearch: function() {
			this.logEntry("_doSearch");
			
			// Collect search criteria
			var criteria = this._getSearchCriteria();
			
			// Show loading
			this._showLoading(true);
			this.searchResults.reset();
			
			// Execute search (no continuationData on first search)
			this._executeSearch(criteria, null);
			
			this.logExit("_doSearch");
		},


		/**
		 * Collects search criteria from form fields.
		 */
		_getSearchCriteria: function() {
			var criteria = {};
			
			for (var fieldId in this._fieldWidgets) {
				var widget = this._fieldWidgets[fieldId];
				var value = widget.get("value");
				
				if (value !== null && value !== undefined && value !== "") {
					// Format date values for DateTextBox
					if (widget.declaredClass === "dijit/form/DateTextBox" && value instanceof Date) {
						value = dateLocale.format(value, { selector: "date", datePattern: "yyyy-MM-dd" });
					}
					// Trim string values
					if (typeof value === "string") {
						value = value.trim();
						if (value === "") continue;
					}
					criteria[fieldId] = value;
				}
			}
			
			return criteria;
		},

		/**
		 * Executes search request to the server.
		 * @param criteria Search criteria object
		 * @param continuationData Continuation token from previous request (null for first request)
		 */
		_executeSearch: function(criteria, continuationData) {
			var self = this;
			this._isLoading = true;
			this._hideMessages();
			
			console.log("[MultiRepoSearchFeature] _executeSearch - continuationData: " + (continuationData ? "present" : "null") + 
			            ", pageSize: " + this._pageSize);
			
			if (!continuationData) {
				this._showLoading(true);
			}
			
			var requestParams = {
				action_Type: "search",
				searchCriteria: JSON.stringify(criteria),
				pageSize: this._pageSize
			};
			
			// Add continuationData if present (ICN will pass this automatically via ResultSet)
			if (continuationData) {
				requestParams.continuationData = continuationData;
			}
			
			Request.invokePluginService("CNBMultiRepoSearchPlugin", "multiRepoSearchService", {
				requestParams: requestParams,
				requestCompleteCallback: lang.hitch(this, function(response) {
					self._isLoading = false;
					self._showLoading(false);
					
					console.log("[MultiRepoSearchFeature] Search response received:", response);
					
					// The response is a JSONResultSetResponse with continuationData
					// Pass it directly to ResultSet - ICN will handle continuation automatically
					self._processSearchResults(response);
				}),
				requestFailedCallback: lang.hitch(this, function(error) {
					self._isLoading = false;
					self._showLoading(false);
					console.error("[MultiRepoSearchFeature] Search error:", error);
					self._showError("Search error: " + (error.message || error));
				})
			});
		},

		/**
		 * Processes and displays search results.
		 * CRITICAL: Sets the repository from _RepositorySelectorMixin for proper
		 * document properties panel and context menu actions.
		 */
		_processSearchResults: function(response) {
			var rowCount = response && response.rows ? response.rows.length : 0;
			var pluginContinuationData = response._pluginContinuationData || null;
			
			// Store continuation token in standard continuationData field for ICN
			// Use a prefix to identify it as our custom token
			if (pluginContinuationData) {
				response.continuationData = "PLUGIN:" + pluginContinuationData;
			} else {
				response.continuationData = null;
			}
			
			// First page - create new ResultSet
			if (this.resultsHeader) {
				domStyle.set(this.resultsHeader, "display", "block");
			}
			if (this.resultCountText) {
				this.resultCountText.innerHTML = rowCount + " document(s) found" + (pluginContinuationData ? " (more available)" : "");
			}
			
			if (rowCount === 0) {
				this._showNoResults();
				return;
			}
			
			// CRITICAL: Set repository from _RepositorySelectorMixin
			// This is REQUIRED for document properties panel and context menu actions to work
			if (this.repository) {
				response.repository = this.repository;
				console.log("[MultiRepoSearchFeature] Set repository on response: " + this.repository.id);
			} else {
				// Fallback to default repository if mixin repository not available
				var defaultRepo = this._getDefaultRepository();
				if (defaultRepo) {
					response.repository = defaultRepo;
					console.log("[MultiRepoSearchFeature] Using fallback repository: " + defaultRepo.id);
				}
			}
			
			// Create new ResultSet
			var resultSet = new ResultSet(response);
			
			// Override retrieveNextPage to call our plugin service
			// ICN's ContentList will automatically call this when user scrolls near bottom
			var self = this;
			var originalRetrieveNextPage = resultSet.retrieveNextPage;
			
			resultSet.retrieveNextPage = function(retrievedCallback, itemsNeeded) {
				console.log("[MultiRepoSearchFeature] *** retrieveNextPage CALLED *** continuationData: " + this.continuationData);
				
				if (!this.continuationData || !this.continuationData.startsWith("PLUGIN:")) {
					console.log("[MultiRepoSearchFeature] Not our token, using default behavior");
					if (originalRetrieveNextPage) {
						return originalRetrieveNextPage.call(this, retrievedCallback, itemsNeeded);
					}
					return;
				}
				
				// Extract our continuation token (remove "PLUGIN:" prefix)
				var token = this.continuationData.substring(7).trim();
				var criteria = self._getSearchCriteria();
				
				console.log("[MultiRepoSearchFeature] Calling plugin service with token (length: " + token.length + ")");
				
				// Call our plugin service
				return Request.invokePluginService("CNBMultiRepoSearchPlugin", "multiRepoSearchService", {
					requestParams: {
						action_Type: "search",
						searchCriteria: JSON.stringify(criteria),
						pageSize: self._pageSize,
						continuationData: token
					},
					requestCompleteCallback: lang.hitch(this, function(response) {
						console.log("[MultiRepoSearchFeature] retrieveNextPage response received: " + (response.rows ? response.rows.length : 0) + " rows");
						
						// Process response
						var pluginContinuationData = response._pluginContinuationData || null;
						if (pluginContinuationData) {
							response.continuationData = "PLUGIN:" + pluginContinuationData;
						} else {
							response.continuationData = null;
						}
						
						// Build items and append to existing items
						var newItems = this.buildItems(response.rows, response.templates || []);
						console.log("[MultiRepoSearchFeature] Built " + newItems.length + " new items, appending to " + this.items.length + " existing");
						this.items = this.items.concat(newItems);
						this.continuationData = response.continuationData;
						
						// Trigger callback
						if (retrievedCallback) {
							retrievedCallback(this.items);
						}
						
						// Trigger ICN event to update UI
						if (this.onNextPageRetrieved) {
							this.onNextPageRetrieved(this);
						}
					}),
					requestFailedCallback: lang.hitch(this, function(error) {
						console.error("[MultiRepoSearchFeature] retrieveNextPage failed: ", error);
						if (retrievedCallback) {
							retrievedCallback(this.items); // Return existing items on error
						}
					})
				});
			};
			
			this.searchResults.setResultSet(resultSet);
			
			// Show error messages if any
			if (response && response.messages && response.messages.length > 0) {
				var errorMsgs = [];
				array.forEach(response.messages, function(msg) {
					if (msg.text) {
						errorMsgs.push(msg.text);
					}
				});
				if (errorMsgs.length > 0) {
					this._showPartialResultsWarning(errorMsgs);
				}
			}
		},
		
		/**
		 * Gets a default repository for display purposes.
		 * For multi-repo search, we use the first available P8 repository.
		 */
		_getDefaultRepository: function() {
			// Try to get from desktop repositories
			if (ecm && ecm.model && ecm.model.desktop) {
				var desktop = ecm.model.desktop;
				
				// Try default repository first
				if (desktop.defaultRepositoryId) {
					var repo = desktop.getRepository(desktop.defaultRepositoryId);
					if (repo && repo.type === "p8") {
						return repo;
					}
				}
				
				// Otherwise get first P8 repository
				var repositories = desktop.repositories;
				if (repositories) {
					for (var i = 0; i < repositories.length; i++) {
						if (repositories[i].type === "p8") {
							return repositories[i];
						}
					}
				}
				
				// Return any repository if no P8 found
				if (repositories && repositories.length > 0) {
					return repositories[0];
				}
			}
			return null;
		},

		/**
		 * Clears the search form and results.
		 */
		_doClear: function() {
			this.logEntry("_doClear");
			
			// Clear all field widgets
			for (var fieldId in this._fieldWidgets) {
				var widget = this._fieldWidgets[fieldId];
				// For DateTextBox, set displayedValue to empty string to clear properly
				if (widget.dropDown || (widget.declaredClass && widget.declaredClass.indexOf("DateTextBox") !== -1)) {
					widget.set("displayedValue", "");
				} else {
					widget.set("value", "");
				}
			}
			
			// Clear results
			this.searchResults.reset();
			
			// Hide result count
			if (this.resultCountText) {
				this.resultCountText.innerHTML = "";
			}
			
			// Hide results header
			if (this.resultsHeader) {
				domStyle.set(this.resultsHeader, "display", "none");
			}
			
			// Hide any messages
			this._hideMessages();
			
			this.logExit("_doClear");
		},

		/**
		 * Shows loading indicator.
		 */
		_showLoading: function(show) {
			if (this.loadingIndicator) {
				domStyle.set(this.loadingIndicator, "display", show ? "block" : "none");
			}
		},

		/**
		 * Shows error message.
		 */
		_showError: function(message) {
			if (this.errorMessage) {
				this.errorMessage.innerHTML = message;
				domStyle.set(this.errorMessage, "display", "block");
			}
		},

		/**
		 * Shows no results message.
		 */
		_showNoResults: function() {
			if (this.noResultsMessage) {
				domStyle.set(this.noResultsMessage, "display", "block");
			}
		},

		/**
		 * Shows partial results warning.
		 */
		_showPartialResultsWarning: function(errors) {
			if (this.warningMessage) {
				var errorText = "";
				if (Array.isArray(errors)) {
					if (typeof errors[0] === "string") {
						errorText = errors.join("; ");
					} else {
						var repoErrors = array.map(errors, function(err) {
							return (err.repository || "") + ": " + (err.message || err.text || "");
						});
						errorText = repoErrors.join("; ");
					}
				} else {
					errorText = String(errors);
				}
				this.warningMessage.innerHTML = "Note: " + errorText;
				domStyle.set(this.warningMessage, "display", "block");
			}
		},

		/**
		 * Hides all messages.
		 */
		_hideMessages: function() {
			if (this.errorMessage) {
				domStyle.set(this.errorMessage, "display", "none");
			}
			if (this.noResultsMessage) {
				domStyle.set(this.noResultsMessage, "display", "none");
			}
			if (this.warningMessage) {
				domStyle.set(this.warningMessage, "display", "none");
			}
		},

		/**
		 * Resets the feature pane.
		 */
		reset: function() {
			this.logEntry("reset");
			
			// Reset repository selector to current repository
			if (this.repositorySelector && this.repository) {
				this.repositorySelector.getDropdown().set("value", this.repository.id);
			}
			
			this._doClear();
			this.needReset = false;
			this.logExit("reset");
		}
	});
});




package com.cnb.search.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;

import javax.security.auth.Subject;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.cnb.search.model.ClassMapping;
import com.cnb.search.model.RepositoryConfig;
import com.cnb.search.model.ResultColumn;
import com.cnb.search.model.SearchConfiguration;
import com.cnb.search.model.SearchField;
import com.cnb.search.model.SearchSettings;
import com.filenet.api.collection.IndependentObjectSet;
import com.filenet.api.collection.PageIterator;
import com.filenet.api.core.Document;
import com.filenet.api.core.ObjectStore;
import com.filenet.api.property.FilterElement;
import com.filenet.api.property.Properties;
import com.filenet.api.property.Property;
import com.filenet.api.property.PropertyFilter;
import com.filenet.api.query.SearchSQL;
import com.filenet.api.query.SearchScope;
import com.filenet.api.util.UserContext;
import com.ibm.ecm.extension.PluginResponseUtil;
import com.ibm.ecm.extension.PluginService;
import com.ibm.ecm.extension.PluginServiceCallbacks;
import com.ibm.ecm.json.JSONResponse;
import com.ibm.ecm.json.JSONResultSetColumn;
import com.ibm.ecm.json.JSONResultSetResponse;
import com.ibm.ecm.json.JSONResultSetRow;
import com.ibm.json.java.JSONArray;
import com.ibm.json.java.JSONObject;

/**
 * Service that handles multi-repository search requests.
 * Executes searches across multiple P8 object stores in parallel
 * and returns aggregated results.
 */
public class MultiRepoSearchService extends PluginService {

    public static final String SERVICE_ID = "multiRepoSearchService";
    
    // Request parameters
    public static final String PARAM_ACTION = "action_Type";
    public static final String PARAM_SEARCH_CRITERIA = "searchCriteria";
    public static final String PARAM_PAGE_NUMBER = "pageNumber";
    public static final String PARAM_PAGE_SIZE = "pageSize";
    public static final String PARAM_CONTINUATION_DATA = "continuationData";
    
    // Actions
    public static final String ACTION_GET_CONFIG = "getConfiguration";
    public static final String ACTION_SEARCH = "search";
    public static final String ACTION_LIST_REPOSITORIES = "listRepositories";
    
    @Override
    public String getId() {
        return SERVICE_ID;
    }

    @Override
    public void execute(PluginServiceCallbacks callbacks, HttpServletRequest request, 
                        HttpServletResponse response) throws Exception {
        String methodName = "execute";
        callbacks.getLogger().logEntry(this, methodName, request);
        
        try {
            String action = request.getParameter(PARAM_ACTION);
            System.out.println("[MultiRepoSearchService.execute] Action received: " + action);
            
            if (ACTION_GET_CONFIG.equals(action)) {
                System.out.println("[MultiRepoSearchService.execute] Getting configuration...");
                // Return configuration for UI
                JSONResponse jsonResponse = getConfiguration();
                PluginResponseUtil.writeJSONResponse(request, response, jsonResponse, callbacks, SERVICE_ID);
            } else if (ACTION_LIST_REPOSITORIES.equals(action)) {
                System.out.println("[MultiRepoSearchService.execute] ACTION_LIST_REPOSITORIES - Listing available repositories...");
                // List available repositories
                JSONResponse jsonResponse = listAvailableRepositories(callbacks, request);
                PluginResponseUtil.writeJSONResponse(request, response, jsonResponse, callbacks, SERVICE_ID);
            } else if (ACTION_SEARCH.equals(action)) {
                System.out.println("[MultiRepoSearchService.execute] ACTION_SEARCH - Starting search...");
                // Execute search - returns JSONResultSetResponse
                String searchCriteriaJson = request.getParameter(PARAM_SEARCH_CRITERIA);
                String continuationData = request.getParameter(PARAM_CONTINUATION_DATA);
                int pageSize = getIntParameter(request, PARAM_PAGE_SIZE, 50);
                
                System.out.println("[MultiRepoSearchService.execute] Search parameters - Criteria: " + searchCriteriaJson + 
                                  ", ContinuationData: " + (continuationData != null ? "present" : "null") + 
                                  ", PageSize: " + pageSize);
                
                JSONResultSetResponse jsonResultSet = executeSearch(callbacks, request, searchCriteriaJson, continuationData, pageSize);
                
                System.out.println("[MultiRepoSearchService.execute] Search completed. Results count: " + jsonResultSet.getRowCount());
                
                // Write JSONResultSetResponse (like sample plugin)
                PluginResponseUtil.writeJSONResponse(request, response, jsonResultSet, callbacks, SERVICE_ID);
            } else {
                System.out.println("[MultiRepoSearchService.execute] Unknown action: " + action);
                JSONResponse jsonResponse = new JSONResponse();
                jsonResponse.put("error", "Unknown action: " + action);
                PluginResponseUtil.writeJSONResponse(request, response, jsonResponse, callbacks, SERVICE_ID);
            }
            
        } catch (Exception e) {
            callbacks.getLogger().logError(this, methodName, request, e);
            JSONResponse jsonResponse = new JSONResponse();
            jsonResponse.put("error", e.getMessage());
            jsonResponse.put("success", false);
            PluginResponseUtil.writeJSONResponse(request, response, jsonResponse, callbacks, SERVICE_ID);
        } finally {
            callbacks.getLogger().logExit(this, methodName, request);
        }
    }
    
    /**
     * Returns the search configuration for the UI.
     */
    private JSONResponse getConfiguration() {
        SearchConfiguration config = SearchConfiguration.getInstance();
        JSONResponse response = new JSONResponse();
        response.put("success", true);
        response.put("configuration", config.toJSON());
        return response;
    }
    
    /**
     * Lists available repositories by attempting to get connections.
     * This helps identify the correct repository IDs to use in search-config.json.
     */
    private JSONResponse listAvailableRepositories(PluginServiceCallbacks callbacks, HttpServletRequest request) {
        System.out.println("[listAvailableRepositories] START - Attempting to discover available repositories");
        JSONResponse response = new JSONResponse();
        JSONArray repositories = new JSONArray();
        
        // Get repositories from configuration
        SearchConfiguration config = SearchConfiguration.getInstance();
        List<RepositoryConfig> configRepos = config.getRepositories();
        
        System.out.println("[listAvailableRepositories] Testing " + configRepos.size() + " repositories from config...");
        
        for (RepositoryConfig configRepo : configRepos) {
            JSONObject repoInfo = new JSONObject();
            repoInfo.put("configRepoId", configRepo.getRepoId());
            repoInfo.put("configRepoName", configRepo.getRepoName());
            repoInfo.put("configClassName", configRepo.getClassName());
            
            System.out.println("[listAvailableRepositories] Testing repository ID: '" + configRepo.getRepoId() + "'");
            
            try {
                Subject subject = callbacks.getP8Subject(configRepo.getRepoId());
                ObjectStore objectStore = callbacks.getP8ObjectStore(configRepo.getRepoId());
                
                    if (subject != null && objectStore != null) {
                        repoInfo.put("available", true);
                        try {
                            repoInfo.put("objectStoreName", objectStore.get_Name());
                        } catch (Exception e) {
                            repoInfo.put("objectStoreName", "N/A");
                        }
                        repoInfo.put("objectStoreId", objectStore.get_Id().toString());
                        String osName = "N/A";
                        try {
                            osName = objectStore.get_Name();
                        } catch (Exception e) {
                            // Ignore
                        }
                        System.out.println("[listAvailableRepositories] âœ“ FOUND: " + configRepo.getRepoId() + 
                                      " -> ObjectStore: " + osName);
                    } else {
                    repoInfo.put("available", false);
                    repoInfo.put("error", "Subject or ObjectStore is NULL");
                    System.out.println("[listAvailableRepositories] âœ— NOT FOUND: " + configRepo.getRepoId());
                }
            } catch (Exception e) {
                repoInfo.put("available", false);
                repoInfo.put("error", e.getMessage());
                System.out.println("[listAvailableRepositories] âœ— ERROR for " + configRepo.getRepoId() + ": " + e.getMessage());
            }
            
            repositories.add(repoInfo);
        }
        
        // Also try to get repository info from request/desktop if available
        try {
            String desktopId = request.getParameter("desktopId");
            if (desktopId == null) {
                desktopId = (String) request.getAttribute("desktopId");
            }
            System.out.println("[listAvailableRepositories] Desktop ID: " + desktopId);
            
            // Try common repository ID patterns
            String[] commonPatterns = {
                "BankingOS", "BankingRepository", "Banking", "banking",
                "EducationOS", "EducationRepository", "Education", "education",
                "GovRecordsOS", "GovRecordsRepository", "GovRecords", "govrecords",
                "P8Repository", "FileNetRepository", "ContentEngine"
            };
            
            System.out.println("[listAvailableRepositories] Testing common repository ID patterns...");
            JSONArray discoveredRepos = new JSONArray();
            
            for (String pattern : commonPatterns) {
                try {
                    Subject subject = callbacks.getP8Subject(pattern);
                    ObjectStore objectStore = callbacks.getP8ObjectStore(pattern);
                    
                    if (subject != null && objectStore != null) {
                        JSONObject discovered = new JSONObject();
                        discovered.put("repoId", pattern);
                        try {
                            discovered.put("objectStoreName", objectStore.get_Name());
                        } catch (Exception e) {
                            discovered.put("objectStoreName", "N/A");
                        }
                        discovered.put("objectStoreId", objectStore.get_Id().toString());
                        discoveredRepos.add(discovered);
                        String osName = "N/A";
                        try {
                            osName = objectStore.get_Name();
                        } catch (Exception e) {
                            // Ignore
                        }
                        System.out.println("[listAvailableRepositories] âœ“ DISCOVERED: " + pattern + 
                                          " -> ObjectStore: " + osName);
                    }
                } catch (Exception e) {
                    // Ignore - this pattern doesn't exist
                }
            }
            
            if (discoveredRepos.size() > 0) {
                response.put("discoveredRepositories", discoveredRepos);
                System.out.println("[listAvailableRepositories] Discovered " + discoveredRepos.size() + " additional repositories");
            }
        } catch (Exception e) {
            System.out.println("[listAvailableRepositories] Error in discovery: " + e.getMessage());
        }
        
        response.put("success", true);
        response.put("repositories", repositories);
        response.put("message", "Check 'repositories' array for availability. Use 'available: true' repository IDs in search-config.json");
        
        System.out.println("[listAvailableRepositories] END - Found " + repositories.size() + " repositories");
        return response;
    }
    
    /**
     * Executes search across all enabled repositories using continuation token for pagination.
     * This implements ICN's continuation token pattern for multi-repository infinite scroll.
     */
    private JSONResultSetResponse executeSearch(PluginServiceCallbacks callbacks, HttpServletRequest request,
                                     String searchCriteriaJson, String continuationData, int pageSize) throws Exception {
        System.out.println("=========================================");
        System.out.println("[MultiRepoSearchService] executeSearch - START (Continuation Token Mode)");
        System.out.println("=========================================");
        System.out.println("[executeSearch] searchCriteriaJson: " + searchCriteriaJson);
        System.out.println("[executeSearch] continuationData: " + (continuationData != null ? "present" : "null"));
        System.out.println("[executeSearch] pageSize: " + pageSize);
        
        String methodName = "executeSearch";
        callbacks.getLogger().logDebug(this, methodName, request, "Search criteria: " + searchCriteriaJson);
        
        // Load configuration
        SearchConfiguration config = SearchConfiguration.getInstance();
        SearchSettings settings = config.getSearchSettings();
        List<RepositoryConfig> repos = config.getEnabledRepositories();
        System.out.println("[executeSearch] Enabled repositories: " + repos.size());
        
        // Parse search criteria
        JSONObject criteria = JSONObject.parse(searchCriteriaJson);
        Map<String, Object> searchCriteria = new HashMap<String, Object>();
        for (Object key : criteria.keySet()) {
            Object value = criteria.get(key);
            if (value != null && !value.toString().isEmpty()) {
                searchCriteria.put((String) key, value);
            }
        }
        
        // Decode or initialize continuation token
        ContinuationToken token = null;
        try {
            if (continuationData != null && !continuationData.isEmpty()) {
                // Remove "PLUGIN:" prefix if present (added by frontend to avoid P8 parser)
                String tokenData = continuationData.trim();
                if (tokenData.startsWith("PLUGIN:")) {
                    tokenData = tokenData.substring(7).trim();
                    System.out.println("[executeSearch] Removed PLUGIN: prefix from continuation token");
                }
                
                // URL decode in case it was encoded during transmission
                try {
                    tokenData = java.net.URLDecoder.decode(tokenData, "UTF-8");
                    System.out.println("[executeSearch] URL decoded continuation token");
                } catch (Exception urlEx) {
                    // Not URL encoded, that's fine
                    System.out.println("[executeSearch] Token not URL encoded, using as-is");
                }
                
                System.out.println("[executeSearch] Token data length: " + tokenData.length() + ", first 50 chars: " + 
                                  (tokenData.length() > 50 ? tokenData.substring(0, 50) : tokenData));
                token = ContinuationToken.fromBase64(tokenData);
                System.out.println("[executeSearch] Decoded continuation token - currentRepoIndex: " + token.getCurrentRepoIndex());
            }
        } catch (Exception e) {
            System.out.println("[executeSearch] ERROR decoding continuation token: " + e.getMessage());
            System.out.println("[executeSearch] Token data that failed (first 200 chars): " + 
                              (continuationData != null ? continuationData.substring(0, Math.min(200, continuationData.length())) : "null"));
            e.printStackTrace();
        }
        
        // Initialize token if not present
        if (token == null) {
            token = new ContinuationToken();
            token.setPageSize(pageSize);
            // Initialize repo states
            for (RepositoryConfig repo : repos) {
                token.getRepoStates().add(new RepoPagingState(repo.getRepoId()));
            }
            System.out.println("[executeSearch] Initialized new continuation token with " + token.getRepoStates().size() + " repositories");
        }
        
        // Create JSONResultSetResponse
        JSONResultSetResponse jsonResultSet = new JSONResultSetResponse();
        jsonResultSet.setPageSize(pageSize);
        buildResultStructure(jsonResultSet, config, callbacks, request.getLocale());
        
        List<JSONResultSetRow> resultRows = new ArrayList<JSONResultSetRow>();
        JSONArray errors = new JSONArray();
        int batchSize = Math.min(pageSize, 100); // Fetch in small batches per repo
        
        // Incremental aggregation using continuation token
        // Loop through repositories starting from currentRepoIndex
        int startRepoIndex = token.getCurrentRepoIndex();
        System.out.println("[executeSearch] Starting from repository index: " + startRepoIndex);
        
        for (int repoIdx = startRepoIndex; repoIdx < repos.size() && resultRows.size() < pageSize; repoIdx++) {
            RepositoryConfig repo = repos.get(repoIdx);
            RepoPagingState repoState = token.getRepoStates().get(repoIdx);
            
            if (repoState.done) {
                System.out.println("[executeSearch] Repository " + repo.getRepoId() + " is done, skipping");
                continue;
            }
            
            System.out.println("[executeSearch] Processing repository " + repo.getRepoId() + " (page " + repoState.currentPage + ")");
            
            try {
                // Get connection for this repository
                Subject subject = callbacks.getP8Subject(repo.getRepoId());
                if (subject == null) {
                    System.out.println("[executeSearch] Cannot get subject for " + repo.getRepoId() + ", marking as done");
                    repoState.done = true;
                    continue;
                }
                
                ObjectStore objectStore = callbacks.getP8ObjectStore(repo.getRepoId());
                if (objectStore == null) {
                    System.out.println("[executeSearch] Cannot get objectStore for " + repo.getRepoId() + ", marking as done");
                    repoState.done = true;
                    continue;
                }
                
                // Fetch a batch from this repository
                RepositorySearchResult batchResult = searchRepositoryBatch(
                    repo, config, searchCriteria, repoState.currentPage, batchSize,
                    subject, objectStore, callbacks
                );
                
                if (batchResult.isSuccess()) {
                    List<JSONResultSetRow> batchRows = batchResult.getResults();
                    System.out.println("[executeSearch] Got " + batchRows.size() + " rows from " + repo.getRepoId());
                    
                    // Add rows until we reach pageSize
                    int remaining = pageSize - resultRows.size();
                    for (int i = 0; i < Math.min(batchRows.size(), remaining); i++) {
                        resultRows.add(batchRows.get(i));
                    }
                    
                    // Check if this repo has more data
                    if (batchRows.size() < batchSize) {
                        repoState.done = true;
                        System.out.println("[executeSearch] Repository " + repo.getRepoId() + " exhausted");
                    } else {
                        repoState.currentPage++;
                        System.out.println("[executeSearch] Repository " + repo.getRepoId() + " has more, will continue from page " + repoState.currentPage);
                    }
                } else {
                    System.out.println("[executeSearch] Search failed for " + repo.getRepoId() + ": " + batchResult.getErrorMessage());
                    repoState.done = true;
                    JSONObject error = new JSONObject();
                    error.put("repository", repo.getRepoName());
                    error.put("message", batchResult.getErrorMessage());
                    errors.add(error);
                }
            } catch (Exception e) {
                System.out.println("[executeSearch] ERROR processing " + repo.getRepoId() + ": " + e.getMessage());
                e.printStackTrace();
                repoState.done = true;
                JSONObject error = new JSONObject();
                error.put("repository", repo.getRepoName());
                error.put("message", e.getMessage());
                errors.add(error);
            }
        }
        
        // Update token's current repo index
        boolean allDone = true;
        for (int i = 0; i < repos.size(); i++) {
            if (!token.getRepoStates().get(i).done) {
                token.setCurrentRepoIndex(i);
                allDone = false;
                break;
            }
        }
        
        // Add rows to result set
        for (JSONResultSetRow row : resultRows) {
            jsonResultSet.addRow(row);
        }
        
        // Set continuation data - use custom field to avoid ICN's P8 continuation parser
        // ICN's ResultSet.retrieveNextPage() tries to parse continuationData as P8 format,
        // which causes ArrayIndexOutOfBoundsException. We'll use a custom field instead.
        String nextContinuationData = null;
        if (!allDone && resultRows.size() == pageSize) {
            try {
                nextContinuationData = token.toBase64();
                System.out.println("[executeSearch] Generated continuation token for next page");
            } catch (Exception e) {
                System.out.println("[executeSearch] ERROR encoding continuation token: " + e.getMessage());
            }
        } else {
            System.out.println("[executeSearch] No more results - all repositories exhausted or partial page returned");
        }
        
        // Store in custom field to prevent ICN from trying to parse it as P8 continuation token
        if (nextContinuationData != null) {
            jsonResultSet.put("_pluginContinuationData", nextContinuationData);
            // Also set continuationData to null/empty to prevent ICN's standard mechanism
            jsonResultSet.put("continuationData", null);
        } else {
            jsonResultSet.put("continuationData", null);
            jsonResultSet.put("_pluginContinuationData", null);
        }
        
        // Set row count (optional - ICN doesn't require it for infinite scroll)
        // JSONResultSetResponse doesn't have setRowCount, but rowCount is set automatically from rows
        // We can optionally set it via put() if needed
        if (resultRows.size() > 0) {
            // Row count is automatically calculated from rows added
        }
        
        // Add error messages if any
        if (errors.size() > 0) {
            for (int i = 0; i < errors.size(); i++) {
                JSONObject error = (JSONObject) errors.get(i);
                com.ibm.ecm.json.JSONMessage jsonMessage = new com.ibm.ecm.json.JSONMessage(
                    0, 
                    (String) error.get("message"), 
                    "Search error for repository: " + error.get("repository"),
                    "Please check the repository configuration.",
                    "Check the IBM Content Navigator logs for more details.",
                    ""
                );
                jsonResultSet.addErrorMessage(jsonMessage);
            }
        }
        
        System.out.println("[executeSearch] Returning " + resultRows.size() + " rows" + 
                          (nextContinuationData != null ? " with continuation token" : " (final page)"));
        System.out.println("=========================================");
        System.out.println("[MultiRepoSearchService] executeSearch - END");
        System.out.println("=========================================");
        
        return jsonResultSet;
    }
    
    /**
     * Searches a single repository and returns a batch of results for a specific page.
     * This is used for incremental fetching with continuation tokens.
     * Returns only the requested page of results, not all results.
     */
    private RepositorySearchResult searchRepositoryBatch(RepositoryConfig repo, SearchConfiguration config,
            Map<String, Object> searchCriteria, int pageNumber, int batchSize,
            Subject subject, ObjectStore objectStore, PluginServiceCallbacks callbacks) {
        
        System.out.println("[searchRepositoryBatch] START - Repository: " + repo.getRepoId() + 
                          ", Page: " + pageNumber + ", BatchSize: " + batchSize);
        
        RepositorySearchResult result = new RepositorySearchResult(repo.getRepoName());
        
        try {
            if (objectStore == null || subject == null) {
                result.setSuccess(false);
                result.setErrorMessage("Connection not available");
                return result;
            }
            
            UserContext.get().pushSubject(subject);
            
            // Build our own PropertyFilter (ICN's built-in filter requires ClassDescription which may not exist)
            PropertyFilter propFilter = buildPropertyFilter(config, repo.getClassMappings());
            
            // Get all class mappings
            List<ClassMapping> classMappings = repo.getClassMappings();
            List<Object[]> allDocumentsWithMappings = new ArrayList<Object[]>();
            
            // Collect documents from all classes
            // For continuation tokens, we need to fetch enough documents to cover the requested page
            // Calculate how many documents we need: (pageNumber - 1) * batchSize + batchSize
            int documentsNeeded = pageNumber * batchSize;
            int fetchLimit = Math.max(documentsNeeded, config.getSearchSettings().getMaxResultsPerRepo());
            
            System.out.println("[searchRepositoryBatch] Fetching up to " + fetchLimit + " documents to cover page " + pageNumber);
            
            for (ClassMapping classMapping : classMappings) {
                // BUG FIX: Skip classes that don't have ANY of the searched fields mapped
                // This prevents returning ALL documents from classes that can't filter by the search criteria
                if (!classHasAnySearchCriteriaMapped(classMapping, searchCriteria)) {
                    System.out.println("[searchRepositoryBatch] SKIPPING class " + classMapping.getClassName() + 
                                      " - no search criteria fields are mapped for this class");
                    continue;
                }
                
                String query = buildSearchQueryForClass(classMapping, config, searchCriteria);
                SearchSQL searchSQL = new SearchSQL(query);
                SearchScope searchScope = new SearchScope(objectStore);
                
                // Fetch enough documents to cover the requested page
                IndependentObjectSet resultSet = searchScope.fetchObjects(searchSQL, fetchLimit, propFilter, true);
                
                PageIterator pageIterator = resultSet.pageIterator();
                while (pageIterator.nextPage()) {
                    for (Object obj : pageIterator.getCurrentPage()) {
                        Document doc = (Document) obj;
                        allDocumentsWithMappings.add(new Object[] { doc, classMapping });
                        
                        // Stop if we have enough documents for this page
                        if (allDocumentsWithMappings.size() >= documentsNeeded) {
                            break;
                        }
                    }
                    if (allDocumentsWithMappings.size() >= documentsNeeded) {
                        break;
                    }
                }
                if (allDocumentsWithMappings.size() >= documentsNeeded) {
                    break; // Stop fetching from other classes if we have enough
                }
            }
            
            // Apply pagination to aggregated results from this repo
            int skip = (pageNumber - 1) * batchSize;
            int endIndex = Math.min(skip + batchSize, allDocumentsWithMappings.size());
            
            System.out.println("[searchRepositoryBatch] Total docs in repo: " + allDocumentsWithMappings.size() + 
                              ", Page " + pageNumber + ": skip=" + skip + ", endIndex=" + endIndex);
            
            // Process only the documents for this page
            // Note: We use default privileges because callbacks.getP8PrivilegeMasks() requires
            // the ICN repository ID which may differ from our config's repo.getRepoId()
            List<JSONResultSetRow> rows = new ArrayList<JSONResultSetRow>();
            for (int i = skip; i < endIndex; i++) {
                Object[] docWithMapping = allDocumentsWithMappings.get(i);
                Document doc = (Document) docWithMapping[0];
                ClassMapping docClassMapping = (ClassMapping) docWithMapping[1];
                
                try {
                    // Use default privileges (view, export, email, print, edit properties, delete)
                    // These provide document actions in the context menu
                    long privileges = JSONResultSetRow.PRIV_VIEWDOC | JSONResultSetRow.PRIV_EXPORT | 
                                     JSONResultSetRow.PRIV_EMAILDOC | JSONResultSetRow.PRIV_PRINTDOC | 
                                     JSONResultSetRow.PRIV_EDITPROPERTIES | JSONResultSetRow.PRIV_DELETE;
                    JSONResultSetRow row = documentToJSONResultSetRow(doc, repo, docClassMapping, config, objectStore, privileges);
                    rows.add(row);
                } catch (Exception docEx) {
                    System.out.println("[searchRepositoryBatch] ERROR processing document: " + docEx.getMessage());
                }
            }
            
            result.setSuccess(true);
            result.setResults(rows);
            result.setTotalCount(allDocumentsWithMappings.size());
            
            System.out.println("[searchRepositoryBatch] Returning " + rows.size() + " rows for page " + pageNumber);
            
        } catch (Exception e) {
            System.out.println("[searchRepositoryBatch] ERROR: " + e.getMessage());
            e.printStackTrace();
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
        } finally {
            UserContext.get().popSubject();
        }
        
        return result;
    }
    
    /**
     * Checks if a class has at least one of the search criteria fields mapped.
     * If no search criteria fields are mapped, the class should be skipped to avoid
     * returning ALL documents (query without WHERE clause).
     * 
     * @param classMapping The class mapping to check
     * @param searchCriteria The search criteria from the user
     * @return true if at least one search criteria field is mapped for this class
     */
    private boolean classHasAnySearchCriteriaMapped(ClassMapping classMapping, Map<String, Object> searchCriteria) {
        if (searchCriteria == null || searchCriteria.isEmpty()) {
            // No search criteria means we should search all classes
            return true;
        }
        
        for (String fieldId : searchCriteria.keySet()) {
            Object value = searchCriteria.get(fieldId);
            // Skip empty values
            if (value == null || value.toString().isEmpty()) {
                continue;
            }
            
            // Check if this field is mapped in the class
            String mappedProperty = classMapping.getMappedProperty(fieldId);
            if (mappedProperty != null) {
                System.out.println("[classHasAnySearchCriteriaMapped] Class " + classMapping.getClassName() + 
                                  " HAS mapping for field '" + fieldId + "' -> " + mappedProperty);
                return true;
            }
        }
        
        System.out.println("[classHasAnySearchCriteriaMapped] Class " + classMapping.getClassName() + 
                          " has NO mappings for any of the search criteria fields");
        return false;
    }
    
    /**
     * Builds PropertyFilter for a repository based on configuration.
     * This includes standard properties, lock/version properties for context menu,
     * direct properties from resultColumns, and mapped properties for _searchField columns.
     */
    private PropertyFilter buildPropertyFilter(SearchConfiguration config, List<ClassMapping> classMappings) {
        PropertyFilter propFilter = new PropertyFilter();
        java.util.Set<String> addedProps = new java.util.HashSet<String>();
        
        // Standard properties
        String[] standardProps = {"Id", "Name", "DocumentTitle", "DateCreated", "Creator", "MimeType", "ContentSize"};
        for (String stdProp : standardProps) {
            propFilter.addIncludeProperty(new FilterElement(null, null, null, stdProp, null));
            addedProps.add(stdProp);
        }
        
        // Lock and version properties (required for context menu and properties panel)
        String[] lockVersionProps = {"IsLocked", "LockOwner", "IsCurrentVersion", "MajorVersionNumber", 
                                     "MinorVersionNumber", "LastModifier", "DateLastModified", "IsReserved"};
        for (String prop : lockVersionProps) {
            if (!addedProps.contains(prop)) {
                propFilter.addIncludeProperty(new FilterElement(null, null, null, prop, null));
                addedProps.add(prop);
            }
        }
        
        // Add direct properties from result columns (e.g., RMApprovalDept)
        for (ResultColumn col : config.getResultColumns()) {
            String propName = col.getPropertyName();
            if (propName != null && !propName.startsWith("_") && !addedProps.contains(propName)) {
                propFilter.addIncludeProperty(new FilterElement(null, null, null, propName, null));
                addedProps.add(propName);
            }
        }
        
        // Add mapped properties for _searchField columns
        for (ResultColumn col : config.getResultColumns()) {
            String propName = col.getPropertyName();
            if (propName != null && propName.startsWith("_searchField:")) {
                String searchFieldId = propName.substring("_searchField:".length());
                for (ClassMapping cm : classMappings) {
                    String mappedProp = cm.getMappedProperty(searchFieldId);
                    if (mappedProp != null && !addedProps.contains(mappedProp)) {
                        propFilter.addIncludeProperty(new FilterElement(null, null, null, mappedProp, null));
                        addedProps.add(mappedProp);
                    }
                }
            }
        }
        
        // Also add all field mappings from all classes (for search criteria)
        for (ClassMapping cm : classMappings) {
            Map<String, String> fieldMappings = cm.getFieldMappings();
            if (fieldMappings != null) {
                for (String mappedProp : fieldMappings.values()) {
                    if (mappedProp != null && !addedProps.contains(mappedProp)) {
                        propFilter.addIncludeProperty(new FilterElement(null, null, null, mappedProp, null));
                        addedProps.add(mappedProp);
                    }
                }
            }
        }
        
        return propFilter;
    }
    
    /**
     * Searches a single repository using pre-obtained subject and object store.
     * @deprecated This method returns all results. Use searchRepositoryBatch for continuation token pagination.
     * This version is used for parallel execution where connections are obtained in the main thread.
     * 
     * IMPORTANT: This method does NOT use callbacks or request - it's safe for worker threads.
     * All session-bound resources (Subject, ObjectStore) must be pre-obtained in the main thread.
     * 
     * Supports multiple classes per repository - searches each class and combines results.
     */
    private RepositorySearchResult searchRepositoryWithConnection(RepositoryConfig repo, SearchConfiguration config,
            Map<String, Object> searchCriteria, int pageNumber, int pageSize,
            Subject subject, ObjectStore objectStore) {
        
        // Get all class mappings for this repository
        List<ClassMapping> classMappings = repo.getClassMappings();
        System.out.println("[searchRepositoryWithConnection] START - Repository: " + repo.getRepoId() + 
                          " (" + repo.getRepoName() + "), Classes: " + classMappings.size());
        
        for (ClassMapping cm : classMappings) {
            System.out.println("[searchRepositoryWithConnection]   - Class: " + cm.getClassName());
        }
        
        RepositorySearchResult result = new RepositorySearchResult(repo.getRepoName());
        
        try {
            if (objectStore == null) {
                System.out.println("[searchRepositoryWithConnection] ERROR: ObjectStore is NULL for " + repo.getRepoId());
                result.setSuccess(false);
                result.setErrorMessage("Repository not found: " + repo.getRepoId());
                return result;
            }
            
            if (subject == null) {
                System.out.println("[searchRepositoryWithConnection] ERROR: Subject is NULL for " + repo.getRepoId());
                result.setSuccess(false);
                result.setErrorMessage("Subject not available for: " + repo.getRepoId());
                return result;
            }
            
            try {
                System.out.println("[searchRepositoryWithConnection] ObjectStore name: " + objectStore.get_Name());
            } catch (Exception nameEx) {
                System.out.println("[searchRepositoryWithConnection] ObjectStore name: (not available - " + nameEx.getMessage() + ")");
            }
            System.out.println("[searchRepositoryWithConnection] Pushing subject to UserContext...");
            // Push subject for this thread
            UserContext.get().pushSubject(subject);
            System.out.println("[searchRepositoryWithConnection] Subject pushed successfully");
            
            // Create PropertyFilter to load required properties
            System.out.println("[searchRepositoryWithConnection] Building PropertyFilter...");
            PropertyFilter propFilter = new PropertyFilter();
            
            // Standard properties
            String[] standardProps = {"Id", "Name", "DocumentTitle", "DateCreated", "Creator", "MimeType", "ContentSize"};
            for (String stdProp : standardProps) {
                propFilter.addIncludeProperty(new FilterElement(null, null, null, stdProp, null));
            }
            System.out.println("[searchRepositoryWithConnection] Added standard properties: " + java.util.Arrays.toString(standardProps));
            
            // Add custom properties from result columns configuration
            System.out.println("[searchRepositoryWithConnection] Processing result columns for PropertyFilter...");
            for (ResultColumn col : config.getResultColumns()) {
                String propName = col.getPropertyName();
                if (propName != null && !propName.startsWith("_")) {
                    System.out.println("[searchRepositoryWithConnection]   Adding direct property: " + propName + " (from column: " + col.getColumnId() + ")");
                    propFilter.addIncludeProperty(new FilterElement(null, null, null, propName, null));
                }
            }
            
            // Add mapped properties for _searchField columns from ALL class mappings
            System.out.println("[searchRepositoryWithConnection] Processing _searchField columns for PropertyFilter...");
            for (ResultColumn col : config.getResultColumns()) {
                String propName = col.getPropertyName();
                if (propName != null && propName.startsWith("_searchField:")) {
                    String searchFieldId = propName.substring("_searchField:".length());
                    System.out.println("[searchRepositoryWithConnection]   Column '" + col.getColumnId() + "' -> _searchField:" + searchFieldId);
                    
                    // Add the mapped property for each class
                    for (ClassMapping cm : classMappings) {
                        String mappedProp = cm.getMappedProperty(searchFieldId);
                        if (mappedProp != null) {
                            System.out.println("[searchRepositoryWithConnection]     -> Class '" + cm.getClassName() + "' maps to property: " + mappedProp);
                            propFilter.addIncludeProperty(new FilterElement(null, null, null, mappedProp, null));
                        } else {
                            System.out.println("[searchRepositoryWithConnection]     -> Class '" + cm.getClassName() + "' has NO mapping for field: " + searchFieldId);
                        }
                    }
                }
            }
            System.out.println("[searchRepositoryWithConnection] PropertyFilter build complete.");
            
            int maxResults = config.getSearchSettings().getMaxResultsPerRepo();
            
            // Collect documents from ALL classes in this repository
            // Use a list of Object arrays to track [Document, ClassMapping] pairs
            List<Object[]> allDocumentsWithMappings = new ArrayList<Object[]>();
            int totalCount = 0;
            
            for (ClassMapping classMapping : classMappings) {
                System.out.println("[searchRepositoryWithConnection] ========================================");
                System.out.println("[searchRepositoryWithConnection] Searching class: " + classMapping.getClassName());
                System.out.println("[searchRepositoryWithConnection] ClassMapping field mappings: " + classMapping.getFieldMappings());
                
                // Build query for this class
                String query = buildSearchQueryForClass(classMapping, config, searchCriteria);
                System.out.println("[searchRepositoryWithConnection] Generated SQL Query: " + query);
                
                // Execute search
                SearchSQL searchSQL = new SearchSQL(query);
                SearchScope searchScope = new SearchScope(objectStore);
                
                System.out.println("[searchRepositoryWithConnection] Executing search with maxResults: " + maxResults);
                IndependentObjectSet resultSet = searchScope.fetchObjects(searchSQL, maxResults, propFilter, true);
                
                // Collect documents from this class - store with their ClassMapping
                PageIterator pageIterator = resultSet.pageIterator();
                int classDocCount = 0;
                while (pageIterator.nextPage()) {
                    for (Object obj : pageIterator.getCurrentPage()) {
                        Document doc = (Document) obj;
                        // Store document with its ClassMapping so we don't need to look it up later
                        allDocumentsWithMappings.add(new Object[] { doc, classMapping });
                        classDocCount++;
                        totalCount++;
                    }
                }
                System.out.println("[searchRepositoryWithConnection] Found " + classDocCount + " documents in class " + classMapping.getClassName());
            }
            
            System.out.println("[searchRepositoryWithConnection] ========================================");
            System.out.println("[searchRepositoryWithConnection] Total documents from all classes: " + totalCount);
            
            // Apply pagination for this repository (for continuation token support)
            // Calculate skip and endIndex for this page
            int skip = (pageNumber - 1) * pageSize;
            int endIndex = Math.min(skip + pageSize, allDocumentsWithMappings.size());
            
            System.out.println("[searchRepositoryWithConnection] Pagination - pageNumber: " + pageNumber + 
                              ", pageSize: " + pageSize + 
                              ", skip: " + skip + 
                              ", endIndex: " + endIndex + 
                              ", totalDocs: " + allDocumentsWithMappings.size());
            
            List<JSONResultSetRow> rows = new ArrayList<JSONResultSetRow>();
            
            // Process only the documents for this page
            for (int i = skip; i < endIndex; i++) {
                Object[] docWithMapping = allDocumentsWithMappings.get(i);
                Document doc = (Document) docWithMapping[0];
                ClassMapping docClassMapping = (ClassMapping) docWithMapping[1];
                
                try {
                    System.out.println("[searchRepositoryWithConnection] Processing document " + (i + 1) + " of " + allDocumentsWithMappings.size() + 
                                      " (ID: " + doc.get_Id() + ")");
                    System.out.println("[searchRepositoryWithConnection] Using ClassMapping: " + docClassMapping.getClassName() + 
                                      " with field mappings: " + docClassMapping.getFieldMappings());
                    
                    // Use default privileges since this deprecated method doesn't have callbacks access
                    long defaultPrivs = JSONResultSetRow.PRIV_VIEWDOC | JSONResultSetRow.PRIV_EXPORT | 
                                       JSONResultSetRow.PRIV_EMAILDOC | JSONResultSetRow.PRIV_PRINTDOC | 
                                       JSONResultSetRow.PRIV_EDITPROPERTIES;
                    JSONResultSetRow row = documentToJSONResultSetRow(doc, repo, docClassMapping, config, objectStore, defaultPrivs);
                    rows.add(row);
                } catch (Exception docEx) {
                    System.out.println("[searchRepositoryWithConnection] ERROR processing document: " + docEx.getMessage());
                    docEx.printStackTrace();
                    // Continue with next document
                }
            }
            
            System.out.println("[searchRepositoryWithConnection] Search complete - Total documents: " + totalCount + 
                              ", Documents in page: " + rows.size());
            
            result.setSuccess(true);
            result.setResults(rows);
            result.setTotalCount(totalCount); // Total count includes all documents, not just this page
            System.out.println("[searchRepositoryWithConnection] SUCCESS - Returning " + rows.size() + " results for page " + pageNumber + 
                              " (total in repo: " + totalCount + ")");
            
        } catch (Exception e) {
            System.out.println("[searchRepositoryWithConnection] ERROR: " + e.getMessage());
            e.printStackTrace();
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
        } finally {
            // Pop subject for this thread
            System.out.println("[searchRepositoryWithConnection] Popping subject from UserContext");
            UserContext.get().popSubject();
            System.out.println("[searchRepositoryWithConnection] END - Repository: " + repo.getRepoId());
        }
        
        return result;
    }
    
    /**
     * Builds a P8 SQL query for a specific class mapping based on search criteria.
     * This method uses the field mappings from the ClassMapping object.
     * 
     * IMPORTANT: All properties that need to be retrieved must be in the SELECT clause.
     * The PropertyFilter alone is not sufficient - properties must be explicitly selected.
     */
    private String buildSearchQueryForClass(ClassMapping classMapping, SearchConfiguration config, 
                                            Map<String, Object> searchCriteria) {
        System.out.println("[buildSearchQueryForClass] START - Class: " + classMapping.getClassName());
        System.out.println("[buildSearchQueryForClass] Search criteria size: " + searchCriteria.size());
        
        StringBuilder sql = new StringBuilder();
        
        // Build SELECT clause with standard properties
        StringBuilder selectClause = new StringBuilder();
        selectClause.append("SELECT This, DocumentTitle, DateCreated, Creator, MimeType, Id");
        
        // Add mapped properties from this class to the SELECT clause
        // This is required because P8 only loads properties that are in the SELECT clause
        java.util.Set<String> addedProperties = new java.util.HashSet<String>();
        addedProperties.add("This");
        addedProperties.add("DocumentTitle");
        addedProperties.add("DateCreated");
        addedProperties.add("Creator");
        addedProperties.add("MimeType");
        addedProperties.add("Id");
        
        Map<String, String> fieldMappings = classMapping.getFieldMappings();
        if (fieldMappings != null) {
            System.out.println("[buildSearchQueryForClass] Adding mapped properties to SELECT clause...");
            for (Map.Entry<String, String> mapping : fieldMappings.entrySet()) {
                String mappedProp = mapping.getValue();
                if (mappedProp != null && !addedProperties.contains(mappedProp)) {
                    selectClause.append(", ").append(mappedProp);
                    addedProperties.add(mappedProp);
                    System.out.println("[buildSearchQueryForClass]   Added to SELECT: " + mappedProp + " (from field: " + mapping.getKey() + ")");
                }
            }
        }
        
        // BUG FIX: Add direct properties from resultColumns to the SELECT clause
        // These are properties like "RMApprovalDept" that are not _searchField mappings
        // but are direct property names configured in resultColumns
        System.out.println("[buildSearchQueryForClass] Adding direct properties from resultColumns...");
        for (ResultColumn col : config.getResultColumns()) {
            String propName = col.getPropertyName();
            // Only add direct property names (not special columns like _repositoryName, _className, _searchField:xxx)
            if (propName != null && !propName.startsWith("_") && !addedProperties.contains(propName)) {
                selectClause.append(", ").append(propName);
                addedProperties.add(propName);
                System.out.println("[buildSearchQueryForClass]   Added to SELECT: " + propName + " (from resultColumn: " + col.getColumnId() + ")");
            }
        }
        
        sql.append(selectClause.toString());
        sql.append(" FROM ").append(classMapping.getClassName());
        System.out.println("[buildSearchQueryForClass] Base SQL: " + sql.toString());
        
        List<String> conditions = new ArrayList<String>();
        
        for (Map.Entry<String, Object> entry : searchCriteria.entrySet()) {
            String fieldId = entry.getKey();
            Object value = entry.getValue();
            
            System.out.println("[buildSearchQueryForClass] Processing field: " + fieldId + " = " + value);
            
            if (value == null || value.toString().isEmpty()) {
                System.out.println("[buildSearchQueryForClass] Skipping empty field: " + fieldId);
                continue;
            }
            
            // Use ClassMapping's field mappings
            String propertyName = classMapping.getMappedProperty(fieldId);
            if (propertyName == null) {
                System.out.println("[buildSearchQueryForClass] Field " + fieldId + " not mapped for class " + classMapping.getClassName());
                continue; // Field not mapped for this class
            }
            System.out.println("[buildSearchQueryForClass] Field " + fieldId + " maps to property: " + propertyName);
            
            SearchField field = config.getSearchFieldById(fieldId);
            if (field == null) {
                System.out.println("[buildSearchQueryForClass] Field " + fieldId + " not found in configuration");
                continue;
            }
            System.out.println("[buildSearchQueryForClass] Field type: " + field.getFieldType() + ", Operator: " + field.getOperator());
            
            String condition = buildCondition(propertyName, value, field);
            if (condition != null) {
                conditions.add(condition);
                System.out.println("[buildSearchQueryForClass] Added condition: " + condition);
            } else {
                System.out.println("[buildSearchQueryForClass] No condition generated for " + fieldId);
            }
        }
        
        if (!conditions.isEmpty()) {
            sql.append(" WHERE ");
            StringBuffer whereClause = new StringBuffer();
            for (int i = 0; i < conditions.size(); i++) {
                if (i > 0) whereClause.append(" AND ");
                whereClause.append(conditions.get(i));
            }
            sql.append(whereClause.toString());
            System.out.println("[buildSearchQueryForClass] WHERE clause: " + whereClause.toString());
        } else {
            System.out.println("[buildSearchQueryForClass] No WHERE conditions - will return all documents");
        }
        
        sql.append(" ORDER BY DateCreated DESC");
        
        String finalQuery = sql.toString();
        System.out.println("[buildSearchQueryForClass] Final SQL Query: " + finalQuery);
        System.out.println("[buildSearchQueryForClass] END");
        
        return finalQuery;
    }
    
    /**
     * Builds a P8 SQL query for a repository based on search criteria.
     * @deprecated Use buildSearchQueryForClass with ClassMapping instead
     */
    @Deprecated
    private String buildSearchQuery(RepositoryConfig repo, SearchConfiguration config, 
                                    Map<String, Object> searchCriteria) {
        // For backward compatibility - use first class mapping
        List<ClassMapping> classMappings = repo.getClassMappings();
        if (classMappings != null && !classMappings.isEmpty()) {
            return buildSearchQueryForClass(classMappings.get(0), config, searchCriteria);
        }
        
        // Legacy fallback
        System.out.println("[buildSearchQuery] START - Repository: " + repo.getRepoId() + 
                          ", Class: " + repo.getClassName());
        System.out.println("[buildSearchQuery] Search criteria size: " + searchCriteria.size());
        
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT This, DocumentTitle, DateCreated, Creator, MimeType, Id ");
        sql.append("FROM ").append(repo.getClassName());
        System.out.println("[buildSearchQuery] Base SQL: " + sql.toString());
        
        List<String> conditions = new ArrayList<String>();
        
        for (Map.Entry<String, Object> entry : searchCriteria.entrySet()) {
            String fieldId = entry.getKey();
            Object value = entry.getValue();
            
            System.out.println("[buildSearchQuery] Processing field: " + fieldId + " = " + value);
            
            if (value == null || value.toString().isEmpty()) {
                System.out.println("[buildSearchQuery] Skipping empty field: " + fieldId);
                continue;
            }
            
            String propertyName = repo.getMappedProperty(fieldId);
            if (propertyName == null) {
                System.out.println("[buildSearchQuery] Field " + fieldId + " not mapped for repository " + repo.getRepoId());
                continue; // Field not mapped for this repository
            }
            System.out.println("[buildSearchQuery] Field " + fieldId + " maps to property: " + propertyName);
            
            SearchField field = config.getSearchFieldById(fieldId);
            if (field == null) {
                System.out.println("[buildSearchQuery] Field " + fieldId + " not found in configuration");
                continue;
            }
            System.out.println("[buildSearchQuery] Field type: " + field.getFieldType() + ", Operator: " + field.getOperator());
            
            String condition = buildCondition(propertyName, value, field);
            if (condition != null) {
                conditions.add(condition);
                System.out.println("[buildSearchQuery] Added condition: " + condition);
            } else {
                System.out.println("[buildSearchQuery] No condition generated for " + fieldId);
            }
        }
        
        if (!conditions.isEmpty()) {
            sql.append(" WHERE ");
            StringBuffer whereClause = new StringBuffer();
            for (int i = 0; i < conditions.size(); i++) {
                if (i > 0) whereClause.append(" AND ");
                whereClause.append(conditions.get(i));
            }
            sql.append(whereClause.toString());
            System.out.println("[buildSearchQuery] WHERE clause: " + whereClause.toString());
        } else {
            System.out.println("[buildSearchQuery] No WHERE conditions - will return all documents");
        }
        
        sql.append(" ORDER BY DateCreated DESC");
        
        String finalQuery = sql.toString();
        System.out.println("[buildSearchQuery] Final SQL Query: " + finalQuery);
        System.out.println("[buildSearchQuery] END");
        
        return finalQuery;
    }
    
    /**
     * Builds a single WHERE condition based on field type and operator.
     */
    private String buildCondition(String propertyName, Object value, SearchField field) {
        System.out.println("[buildCondition] Property: " + propertyName + ", Value: " + value + 
                          ", Type: " + field.getFieldType() + ", Operator: " + field.getOperator());
        
        String operator = field.getOperator();
        String valueStr = value.toString().replace("'", "''"); // Escape single quotes
        
        /*switch (field.getFieldType().toLowerCase()) {
            case "string":
                switch (operator.toUpperCase()) {
                    case "LIKE":
                        return propertyName + " LIKE '%" + valueStr + "%'";
                    case "STARTSWITH":
                        return propertyName + " LIKE '" + valueStr + "%'";
                    case "EQUALS":
                    default:
                        return propertyName + " = '" + valueStr + "'";
                }
                
            case "date":
                // Assuming ISO format date string
                return propertyName + " = " + valueStr;
                
            case "integer":
            case "number":
                return propertyName + " = " + valueStr;
                
            case "boolean":
                boolean boolVal = Boolean.parseBoolean(valueStr);
                return propertyName + " = " + boolVal;
                
            default:
                return propertyName + " = '" + valueStr + "'";
        }*/
        
        String fieldType = field.getFieldType().toLowerCase();

        if ("string".equals(fieldType)) {

            String op = operator.toUpperCase();

            if ("LIKE".equals(op)) {
                String condition = propertyName + " LIKE '%" + valueStr + "%'";
                System.out.println("[buildCondition] Generated LIKE condition: " + condition);
                return condition;
            } 
            else if ("STARTSWITH".equals(op)) {
                String condition = propertyName + " LIKE '" + valueStr + "%'";
                System.out.println("[buildCondition] Generated STARTSWITH condition: " + condition);
                return condition;
            } 
            else { // EQUALS or default
                String condition = propertyName + " = '" + valueStr + "'";
                System.out.println("[buildCondition] Generated EQUALS condition: " + condition);
                return condition;
            }

        }
        else if ("date".equals(fieldType)) {
            // Assuming ISO format date string (YYYY-MM-DD)
            // For P8, dates need to be in specific format
            String condition = propertyName + " = DATE '" + valueStr + "'";
            System.out.println("[buildCondition] Generated date condition: " + condition);
            return condition;
        }
        else if ("integer".equals(fieldType) || "number".equals(fieldType)) {
            String condition = propertyName + " = " + valueStr;
            System.out.println("[buildCondition] Generated number condition: " + condition);
            return condition;
        }
        else if ("boolean".equals(fieldType)) {
            boolean boolVal = Boolean.parseBoolean(valueStr);
            String condition = propertyName + " = " + boolVal;
            System.out.println("[buildCondition] Generated boolean condition: " + condition);
            return condition;
        }
        else {
            String condition = propertyName + " = '" + valueStr + "'";
            System.out.println("[buildCondition] Generated default condition: " + condition);
            return condition;
        }

    }
    
    /**
     * Converts a P8 Document to JSONResultSetRow for the result grid.
     * 
     * This method creates a properly structured result row that works with ICN's
     * ContentList for document properties panel and context menu actions.
     * 
     * @param doc The P8 Document object
     * @param repo The repository configuration
     * @param classMapping The class mapping for this document (used to resolve _searchField columns)
     * @param config The search configuration
     * @param objectStore The P8 ObjectStore (for building proper item ID)
     * @param privileges The document privilege mask from callbacks.getP8PrivilegeMasks()
     */
    private JSONResultSetRow documentToJSONResultSetRow(Document doc, RepositoryConfig repo, 
                                      ClassMapping classMapping, SearchConfiguration config,
                                      ObjectStore objectStore, long privileges) {
        // Get basic info first - these should always work
        String docId = "";
        String docClassName = "";
        String osId = "";
        
        try {
            docId = doc.get_Id().toString();
        } catch (Exception e) {
            docId = "unknown";
        }
        try {
            docClassName = doc.getClassName();
        } catch (Exception e) {
            docClassName = "Document";
        }
        try {
            osId = objectStore.get_Id().toString();
        } catch (Exception e) {
            try {
                osId = doc.getObjectStore().get_Id().toString();
            } catch (Exception e2) {
                osId = "unknown";
            }
        }
        
        // Build item ID (like sample plugin: className,objectStoreId,objectId)
        String itemId = docClassName + "," + osId + "," + docId;
        
        // Get document name safely
        String docName = "";
        try {
            docName = doc.get_Name();
            if (docName == null) docName = "";
        } catch (Exception e) {
            // Name not available, try to get from properties later
        }
        
        // Get mime type safely
        String mimeType = "";
        try {
            mimeType = doc.get_MimeType();
            if (mimeType == null) mimeType = "";
        } catch (Exception e) {
            // MimeType not available
        }
        
        // Create JSONResultSetRow with actual privileges (from callbacks.getP8PrivilegeMasks)
        JSONResultSetRow row = new JSONResultSetRow(itemId, docName, mimeType, privileges);
        
        // ===== CRITICAL: Add lock and version attributes for context menu and properties panel =====
        // These are REQUIRED for ICN's ContentList to show proper context menu actions
        try {
            boolean isLocked = doc.isLocked();
            row.addAttribute("locked", isLocked, JSONResultSetRow.TYPE_BOOLEAN, null, String.valueOf(isLocked));
        } catch (Exception e) {
            row.addAttribute("locked", false, JSONResultSetRow.TYPE_BOOLEAN, null, "false");
        }
        
        try {
            String lockOwner = doc.get_LockOwner();
            row.addAttribute("lockedUser", lockOwner != null ? lockOwner : "", JSONResultSetRow.TYPE_STRING, null, lockOwner != null ? lockOwner : "");
        } catch (Exception e) {
            row.addAttribute("lockedUser", "", JSONResultSetRow.TYPE_STRING, null, "");
        }
        
        try {
            boolean isCurrentVersion = doc.get_IsCurrentVersion();
            row.addAttribute("currentVersion", isCurrentVersion, JSONResultSetRow.TYPE_BOOLEAN, null, String.valueOf(isCurrentVersion));
        } catch (Exception e) {
            row.addAttribute("currentVersion", true, JSONResultSetRow.TYPE_BOOLEAN, null, "true");
        }
        
        // Add version information
        try {
            int majorVersion = doc.get_MajorVersionNumber();
            int minorVersion = doc.get_MinorVersionNumber();
            String versionStr = majorVersion + "." + minorVersion;
            row.addAttribute("Version", versionStr, JSONResultSetRow.TYPE_STRING, null, versionStr);
        } catch (Exception e) {
            row.addAttribute("Version", "1.0", JSONResultSetRow.TYPE_STRING, null, "1.0");
        }
        
        // Add last modifier information
        try {
            String lastModifier = doc.get_LastModifier();
            row.addAttribute("ModifiedBy", lastModifier != null ? lastModifier : "", JSONResultSetRow.TYPE_STRING, null, lastModifier != null ? lastModifier : "");
        } catch (Exception e) {
            row.addAttribute("ModifiedBy", "", JSONResultSetRow.TYPE_STRING, null, "");
        }
        
        try {
            java.util.Date lastModified = doc.get_DateLastModified();
            if (lastModified != null) {
                row.addAttribute("LastModified", lastModified.toString(), JSONResultSetRow.TYPE_TIMESTAMP, null, lastModified.toString());
            }
        } catch (Exception e) {
            // LastModified not available
        }
        
        // Add standard attributes
        row.addAttribute("ID", docId, JSONResultSetRow.TYPE_STRING, null, docId);
        row.addAttribute("className", docClassName, JSONResultSetRow.TYPE_STRING, null, docClassName);
        
        // Get properties collection for configured columns
        Properties allProperties = null;
        try {
            allProperties = doc.getProperties();
            //System.out.println("[documentToJSONResultSetRow] Properties collection obtained, size: " + allProperties.size());
        } catch (Exception e) {
            System.out.println("[documentToJSONResultSetRow] Could not get properties collection: " + e.getMessage());
        }
        
        // Add configured result columns - extract ACTUAL property values
        for (ResultColumn col : config.getResultColumns()) {
            String propName = col.getPropertyName();
            String value = "";
            String displayValue = "";
            String attrType = JSONResultSetRow.TYPE_STRING;
            
            try {
                if ("_repositoryName".equals(propName)) {
                    // Special column for repository name
                    value = repo.getRepoName();
                    displayValue = repo.getRepoName();
                } else if ("_className".equals(propName)) {
                    // Special column for document class name
                    value = docClassName;
                    displayValue = docClassName;
                } else if (propName != null && propName.startsWith("_searchField:")) {
                    // Special column for search field value - resolve using class mapping
                    String searchFieldId = propName.substring("_searchField:".length());
                    //System.out.println("[documentToJSONResultSetRow] *** Resolving _searchField: " + searchFieldId);
                    //System.out.println("[documentToJSONResultSetRow]     Document class: " + docClassName);
                    //System.out.println("[documentToJSONResultSetRow]     ClassMapping available: " + (classMapping != null));
                    
                    if (classMapping != null) {
                        //System.out.println("[documentToJSONResultSetRow]     ClassMapping className: " + classMapping.getClassName());
                        //System.out.println("[documentToJSONResultSetRow]     ClassMapping fieldMappings: " + classMapping.getFieldMappings());
                        
                        String actualPropName = classMapping.getMappedProperty(searchFieldId);
                        //System.out.println("[documentToJSONResultSetRow]     Field '" + searchFieldId + "' maps to property: " + actualPropName);
                        
                        if (actualPropName != null && allProperties != null) {
                            //System.out.println("[documentToJSONResultSetRow]     Looking for property '" + actualPropName + "' in properties collection (size: " + allProperties.size() + ")");
                            Property prop = allProperties.find(actualPropName);
                            
                            if (prop != null) {
                                Object propValue = prop.getObjectValue();
                                //System.out.println("[documentToJSONResultSetRow]     Property found! Value: " + propValue + " (type: " + (propValue != null ? propValue.getClass().getName() : "null") + ")");
                                
                                if (propValue != null) {
                                    if (propValue instanceof java.util.Date) {
                                        java.util.Date dateVal = (java.util.Date) propValue;
                                        value = String.valueOf(dateVal.getTime());
                                        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                                        displayValue = sdf.format(dateVal);
                                        attrType = JSONResultSetRow.TYPE_TIMESTAMP;
                                    } else {
                                        value = propValue.toString();
                                        displayValue = value;
                                    }
                                    //System.out.println("[documentToJSONResultSetRow]     Extracted value: '" + value + "', displayValue: '" + displayValue + "'");
                                } else {
                                    System.out.println("[documentToJSONResultSetRow]     Property value is null");
                                }
                            } else {
                                System.out.println("[documentToJSONResultSetRow]     *** WARNING: Property '" + actualPropName + "' NOT FOUND in properties collection!");
                                // Try to list available properties for debugging
                                try {
                                    System.out.println("[documentToJSONResultSetRow]     Available properties in collection:");
                                    java.util.Iterator<?> propIter = allProperties.iterator();
                                    int propCount = 0;
                                    while (propIter.hasNext() && propCount < 20) {
                                        Property p = (Property) propIter.next();
                                        System.out.println("[documentToJSONResultSetRow]       - " + p.getPropertyName());
                                        propCount++;
                                    }
                                    if (propCount >= 20) {
                                        System.out.println("[documentToJSONResultSetRow]       ... (truncated, more properties exist)");
                                    }
                                } catch (Exception listEx) {
                                    System.out.println("[documentToJSONResultSetRow]     Could not list properties: " + listEx.getMessage());
                                }
                            }
                        } else if (actualPropName == null) {
                            System.out.println("[documentToJSONResultSetRow]     *** WARNING: Field '" + searchFieldId + "' has no mapping in ClassMapping!");
                        } else {
                            System.out.println("[documentToJSONResultSetRow]     *** WARNING: Properties collection is null!");
                        }
                    } else {
                        System.out.println("[documentToJSONResultSetRow]     *** WARNING: ClassMapping is NULL - cannot resolve field mapping!");
                    }
                } else if (allProperties != null) {
                    // Regular property - try to get by name
                    Property prop = allProperties.find(propName);
                    if (prop != null) {
                        Object propValue = prop.getObjectValue();
                        if (propValue != null) {
                            // Handle different property types
                            if (propValue instanceof java.util.Date) {
                                java.util.Date dateVal = (java.util.Date) propValue;
                                value = String.valueOf(dateVal.getTime());
                                java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                                displayValue = sdf.format(dateVal);
                                attrType = JSONResultSetRow.TYPE_TIMESTAMP;
                            } else if (propValue instanceof Integer || propValue instanceof Long) {
                                value = propValue.toString();
                                displayValue = value;
                                attrType = JSONResultSetRow.TYPE_INTEGER;
                            } else if (propValue instanceof Double || propValue instanceof Float) {
                                value = propValue.toString();
                                displayValue = value;
                                attrType = JSONResultSetRow.TYPE_DOUBLE;
                            } else if (propValue instanceof Boolean) {
                                value = propValue.toString();
                                displayValue = value;
                                attrType = JSONResultSetRow.TYPE_BOOLEAN;
                            } else {
                                value = propValue.toString();
                                displayValue = value;
                            }
                        }
                    } else {
                        System.out.println("[documentToJSONResultSetRow] Property not in collection: " + propName);
                    }
                }
            } catch (Exception propEx) {
                System.out.println("[documentToJSONResultSetRow] Error getting property " + propName + ": " + propEx.getMessage());
            }
            
            // Add attribute to row (even if empty)
            row.addAttribute(col.getColumnId(), value, attrType, null, displayValue);
        }
        
        //System.out.println("[documentToJSONResultSetRow] Successfully created row for doc: " + docId);
        return row;
    }
    
    /**
     * Builds the result structure with columns (like sample plugin buildP8ResultStructure).
     */
    private void buildResultStructure(JSONResultSetResponse jsonResultSet, SearchConfiguration config,
                                     PluginServiceCallbacks callbacks, Locale locale) {
        // Add standard columns
        String[] states = new String[1];
        states[0] = JSONResultSetColumn.STATE_LOCKED;
        jsonResultSet.addColumn(new JSONResultSetColumn("&nbsp;", "multiStateIcon", false, states));
        jsonResultSet.addColumn(new JSONResultSetColumn("&nbsp;", "17px", "mimeTypeIcon", null, false));
        
        // Add configured result columns
        for (com.cnb.search.model.ResultColumn col : config.getResultColumns()) {
            String width = col.getWidth() != null ? col.getWidth() : "150px";
            jsonResultSet.addColumn(new JSONResultSetColumn(col.getColumnLabel(), width, col.getColumnId(), null, col.isSortable()));
        }
    }
    
    
    /**
     * Helper to get integer parameter with default value.
     */
    private int getIntParameter(HttpServletRequest request, String name, int defaultValue) {
        String value = request.getParameter(name);
        if (value != null && !value.isEmpty()) {
            try {
                return Integer.parseInt(value);
            } catch (NumberFormatException e) {
                return defaultValue;
            }
        }
        return defaultValue;
    }
    
    /**
     * Callable task for parallel repository search.
     * Uses pre-obtained subject and object store to avoid session access issues.
     * 
     * IMPORTANT: This class does NOT hold callbacks or request references
     * to prevent SESN0008E errors when accessing HttpSession from worker threads.
     */
    private class RepositorySearchTask implements Callable<RepositorySearchResult> {
        private final RepositoryConfig repo;
        private final SearchConfiguration config;
        private final Map<String, Object> searchCriteria;
        private final int pageNumber;
        private final int pageSize;
        private final Subject subject;
        private final ObjectStore objectStore;
        
        public RepositorySearchTask(RepositoryConfig repo, SearchConfiguration config,
                                   Map<String, Object> searchCriteria, int pageNumber, int pageSize,
                                   Subject subject, ObjectStore objectStore) {
            this.repo = repo;
            this.config = config;
            this.searchCriteria = searchCriteria;
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.subject = subject;
            this.objectStore = objectStore;
        }
        
        public RepositorySearchResult call() throws Exception {
            // Call the thread-safe version that doesn't use callbacks or request
            return searchRepositoryWithConnection(repo, config, 
                    searchCriteria, pageNumber, pageSize, subject, objectStore);
        }
    }
    
    /**
     * Container for repository search results.
     */
    private static class RepositorySearchResult {
        private final String repoName;
        private boolean success;
        private List<JSONResultSetRow> results;
        private int totalCount;
        private String errorMessage;
        
        public RepositorySearchResult(String repoName) {
            this.repoName = repoName;
            this.results = new ArrayList<JSONResultSetRow>();
        }
        
        public String getRepoName() { return repoName; }
        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }
        public List<JSONResultSetRow> getResults() { return results; }
        public void setResults(List<JSONResultSetRow> results) { this.results = results; }
        public int getTotalCount() { return totalCount; }
        public void setTotalCount(int totalCount) { this.totalCount = totalCount; }
        public String getErrorMessage() { return errorMessage; }
        public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    }
    
    /**
     * Continuation token to track multi-repository pagination state.
     * Stores which repository we're currently reading and how far we've paged in each.
     */
    private static class ContinuationToken {
        private int currentRepoIndex;
        private List<RepoPagingState> repoStates;
        private int pageSize;
        
        public ContinuationToken() {
            this.currentRepoIndex = 0;
            this.repoStates = new ArrayList<RepoPagingState>();
            this.pageSize = 50;
        }
        
        public ContinuationToken(int currentRepoIndex, List<RepoPagingState> repoStates, int pageSize) {
            this.currentRepoIndex = currentRepoIndex;
            this.repoStates = repoStates;
            this.pageSize = pageSize;
        }
        
        /**
         * Simple Base64 encoder for Java 6 compatibility.
         */
        private static String encodeBase64(byte[] data) {
            final char[] base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();
            StringBuilder sb = new StringBuilder();
            int i = 0;
            while (i < data.length) {
                int b1 = data[i++] & 0xff;
                int b2 = (i < data.length) ? data[i++] & 0xff : 0;
                int b3 = (i < data.length) ? data[i++] & 0xff : 0;
                
                int bitmap = (b1 << 16) | (b2 << 8) | b3;
                
                sb.append(base64Chars[(bitmap >> 18) & 0x3f]);
                sb.append(base64Chars[(bitmap >> 12) & 0x3f]);
                
                if (i - 2 < data.length) {
                    sb.append(base64Chars[(bitmap >> 6) & 0x3f]);
                } else {
                    sb.append('=');
                }
                
                if (i - 1 < data.length) {
                    sb.append(base64Chars[bitmap & 0x3f]);
                } else {
                    sb.append('=');
                }
            }
            return sb.toString();
        }
        
        /**
         * Simple Base64 decoder for Java 6 compatibility.
         */
        private static byte[] decodeBase64(String base64) {
            final String base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            // Clean the base64 string
            base64 = base64.trim().replaceAll("[^A-Za-z0-9+/=]", "");
            
            // Calculate output length
            int len = base64.length();
            int padCount = 0;
            if (len > 0) {
                if (base64.charAt(len - 1) == '=') padCount++;
                if (len > 1 && base64.charAt(len - 2) == '=') padCount++;
            }
            
            int outputLength = (len * 3) / 4 - padCount;
            byte[] data = new byte[outputLength];
            
            int dataIndex = 0;
            for (int i = 0; i < len; i += 4) {
                // Get 4 base64 characters
                int bitmap = 0;
                int charsProcessed = 0;
                
                for (int j = 0; j < 4 && (i + j) < len; j++) {
                    char c = base64.charAt(i + j);
                    if (c == '=') {
                        break; // Padding, stop here
                    }
                    int charIndex = base64Chars.indexOf(c);
                    if (charIndex < 0) {
                        throw new IllegalArgumentException("Invalid Base64 character: " + c);
                    }
                    bitmap |= (charIndex << (18 - j * 6));
                    charsProcessed++;
                }
                
                // Extract bytes based on how many characters we processed
                if (charsProcessed >= 2 && dataIndex < outputLength) {
                    data[dataIndex++] = (byte) ((bitmap >> 16) & 0xff);
                }
                if (charsProcessed >= 3 && dataIndex < outputLength) {
                    data[dataIndex++] = (byte) ((bitmap >> 8) & 0xff);
                }
                if (charsProcessed >= 4 && dataIndex < outputLength) {
                    data[dataIndex++] = (byte) (bitmap & 0xff);
                }
            }
            
            return data;
        }
        
        public static ContinuationToken fromBase64(String base64) throws Exception {
            if (base64 == null || base64.isEmpty()) {
                return null;
            }
            // Clean the base64 string - remove any whitespace or invalid characters
            base64 = base64.trim().replaceAll("[^A-Za-z0-9+/=]", "");
            
            byte[] decoded = decodeBase64(base64);
            String json = new String(decoded, "UTF-8");
            
            // Find the last closing brace to get valid JSON (Base64 padding might add null bytes)
            int lastBrace = json.lastIndexOf('}');
            if (lastBrace > 0) {
                json = json.substring(0, lastBrace + 1);
                System.out.println("[ContinuationToken.fromBase64] Trimmed to valid JSON (ending at position " + lastBrace + ")");
            } else {
                json = json.trim();
            }
            
            System.out.println("[ContinuationToken.fromBase64] Decoded JSON length: " + json.length());
            System.out.println("[ContinuationToken.fromBase64] Full decoded JSON: " + json);
            
            // Check for any invalid characters
            for (int i = 0; i < json.length(); i++) {
                char c = json.charAt(i);
                if (c < 32 && c != '\n' && c != '\r' && c != '\t') {
                    System.out.println("[ContinuationToken.fromBase64] WARNING: Invalid control character at position " + i + ": " + (int)c);
                }
            }
            
            JSONObject obj = JSONObject.parse(json);
            
            ContinuationToken token = new ContinuationToken();
            token.currentRepoIndex = ((Number) obj.get("currentRepoIndex")).intValue();
            token.pageSize = ((Number) obj.get("pageSize")).intValue();
            
            JSONArray statesArray = (JSONArray) obj.get("repoStates");
            token.repoStates = new ArrayList<RepoPagingState>();
            for (Object stateObj : statesArray) {
                JSONObject state = (JSONObject) stateObj;
                RepoPagingState rps = new RepoPagingState();
                rps.repoId = (String) state.get("repoId");
                rps.currentPage = ((Number) state.get("currentPage")).intValue();
                rps.done = Boolean.TRUE.equals(state.get("done"));
                token.repoStates.add(rps);
            }
            return token;
        }
        
        public String toBase64() throws Exception {
            // Build compact JSON manually to avoid any formatting/spaces from serialize()
            StringBuilder json = new StringBuilder();
            json.append("{");
            json.append("\"currentRepoIndex\":").append(currentRepoIndex);
            json.append(",\"pageSize\":").append(pageSize);
            json.append(",\"repoStates\":[");
            
            boolean first = true;
            for (RepoPagingState state : repoStates) {
                if (!first) json.append(",");
                first = false;
                json.append("{");
                json.append("\"repoId\":\"").append(escapeJsonString(state.repoId)).append("\"");
                json.append(",\"currentPage\":").append(state.currentPage);
                json.append(",\"done\":").append(state.done);
                json.append("}");
            }
            json.append("]");
            json.append("}");
            
            String jsonStr = json.toString();
            System.out.println("[ContinuationToken.toBase64] JSON string: " + jsonStr);
            byte[] jsonBytes = jsonStr.getBytes("UTF-8");
            return encodeBase64(jsonBytes);
        }
        
        private String escapeJsonString(String str) {
            if (str == null) return "";
            return str.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
        }
        
        public int getCurrentRepoIndex() { return currentRepoIndex; }
        public void setCurrentRepoIndex(int currentRepoIndex) { this.currentRepoIndex = currentRepoIndex; }
        public List<RepoPagingState> getRepoStates() { return repoStates; }
        public void setRepoStates(List<RepoPagingState> repoStates) { this.repoStates = repoStates; }
        public int getPageSize() { return pageSize; }
        public void setPageSize(int pageSize) { this.pageSize = pageSize; }
    }
    
    /**
     * Tracks pagination state for a single repository.
     */
    private static class RepoPagingState {
        String repoId;
        int currentPage;
        boolean done;
        
        public RepoPagingState() {
            this.currentPage = 1;
            this.done = false;
        }
        
        public RepoPagingState(String repoId) {
            this();
            this.repoId = repoId;
        }
    }
}

